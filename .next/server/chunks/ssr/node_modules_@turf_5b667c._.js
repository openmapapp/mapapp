module.exports = {

"[project]/node_modules/@turf/turf/dist/esm/index.js [app-ssr] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({});
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/turf/dist/esm/index.js [app-ssr] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@turf/turf/dist/esm/index.js [app-ssr] (ecmascript) <locals>");
}}),
"[project]/node_modules/@turf/turf/dist/esm/index.js [app-ssr] (ecmascript) <exports>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "along": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$along$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["along"]),
    "angle": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$angle$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["angle"]),
    "applyFilter": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clusters$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["applyFilter"]),
    "area": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$area$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["area"]),
    "areaFactors": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["areaFactors"]),
    "azimuthToBearing": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["azimuthToBearing"]),
    "bbox": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bbox"]),
    "bboxClip": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2d$clip$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bboxClip"]),
    "bboxPolygon": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bboxPolygon"]),
    "bearing": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bearing"]),
    "bearingToAzimuth": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bearingToAzimuth"]),
    "bezierSpline": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bezier$2d$spline$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bezierSpline"]),
    "booleanClockwise": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$clockwise$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanClockwise"]),
    "booleanConcave": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$concave$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanConcave"]),
    "booleanContains": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$contains$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanContains"]),
    "booleanCrosses": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$crosses$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanCrosses"]),
    "booleanDisjoint": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$disjoint$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanDisjoint"]),
    "booleanEqual": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$equal$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanEqual"]),
    "booleanIntersects": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$intersects$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanIntersects"]),
    "booleanOverlap": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$overlap$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanOverlap"]),
    "booleanParallel": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$parallel$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanParallel"]),
    "booleanPointInPolygon": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"]),
    "booleanPointOnLine": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"]),
    "booleanTouches": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$touches$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanTouches"]),
    "booleanValid": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$valid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanValid"]),
    "booleanWithin": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$within$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanWithin"]),
    "buffer": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$buffer$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["buffer"]),
    "center": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["center"]),
    "centerMean": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2d$mean$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["centerMean"]),
    "centerMedian": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2d$median$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["centerMedian"]),
    "centerOfMass": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2d$of$2d$mass$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["centerOfMass"]),
    "centroid": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["centroid"]),
    "circle": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$circle$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["circle"]),
    "cleanCoords": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clean$2d$coords$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cleanCoords"]),
    "clone": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"]),
    "cloneProperties": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cloneProperties"]),
    "clusterEach": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clusters$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clusterEach"]),
    "clusterReduce": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clusters$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clusterReduce"]),
    "clusters": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clusters$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__),
    "clustersDbscan": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clusters$2d$dbscan$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clustersDbscan"]),
    "clustersKmeans": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clusters$2d$kmeans$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clustersKmeans"]),
    "collect": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$collect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["collect"]),
    "collectionOf": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["collectionOf"]),
    "combine": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$combine$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["combine"]),
    "concave": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$concave$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["concave"]),
    "containsNumber": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["containsNumber"]),
    "convertArea": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["convertArea"]),
    "convertLength": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["convertLength"]),
    "convex": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$convex$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["convex"]),
    "coordAll": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["coordAll"]),
    "coordEach": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["coordEach"]),
    "coordReduce": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["coordReduce"]),
    "createBins": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clusters$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createBins"]),
    "degreesToRadians": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["degreesToRadians"]),
    "destination": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["destination"]),
    "difference": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$difference$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["difference"]),
    "dissolve": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$dissolve$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["dissolve"]),
    "distance": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distance"]),
    "distanceWeight": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2d$weight$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distanceWeight"]),
    "earthRadius": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["earthRadius"]),
    "ellipse": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$ellipse$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ellipse"]),
    "envelope": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$envelope$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["envelope"]),
    "explode": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$explode$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["explode"]),
    "factors": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["factors"]),
    "feature": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["feature"]),
    "featureCollection": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"]),
    "featureEach": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"]),
    "featureOf": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureOf"]),
    "featureReduce": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureReduce"]),
    "filterProperties": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clusters$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["filterProperties"]),
    "findPoint": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["findPoint"]),
    "findSegment": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["findSegment"]),
    "flatten": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$flatten$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"]),
    "flattenEach": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flattenEach"]),
    "flattenReduce": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flattenReduce"]),
    "flip": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$flip$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flip"]),
    "geojsonRbush": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$geojson$2d$rbush$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["geojsonRbush"]),
    "geojsonType": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["geojsonType"]),
    "geomEach": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["geomEach"]),
    "geomReduce": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["geomReduce"]),
    "geometry": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["geometry"]),
    "geometryCollection": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["geometryCollection"]),
    "getCluster": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clusters$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCluster"]),
    "getCoord": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"]),
    "getCoords": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"]),
    "getGeom": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getGeom"]),
    "getType": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getType"]),
    "greatCircle": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$great$2d$circle$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["greatCircle"]),
    "helpers": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__),
    "hexGrid": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$hex$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hexGrid"]),
    "interpolate": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$interpolate$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["interpolate"]),
    "intersect": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["intersect"]),
    "invariant": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__),
    "isNumber": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"]),
    "isObject": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"]),
    "isobands": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$isobands$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isobands"]),
    "isolines": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$isolines$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isolines"]),
    "kinks": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$kinks$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["kinks"]),
    "length": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$length$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["length"]),
    "lengthToDegrees": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lengthToDegrees"]),
    "lengthToRadians": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lengthToRadians"]),
    "lineArc": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$arc$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineArc"]),
    "lineChunk": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$chunk$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineChunk"]),
    "lineEach": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineEach"]),
    "lineIntersect": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineIntersect"]),
    "lineOffset": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$offset$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineOffset"]),
    "lineOverlap": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$overlap$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineOverlap"]),
    "lineReduce": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineReduce"]),
    "lineSegment": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$segment$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineSegment"]),
    "lineSlice": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$slice$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineSlice"]),
    "lineSliceAlong": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$slice$2d$along$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineSliceAlong"]),
    "lineSplit": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$split$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineSplit"]),
    "lineString": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineString"]),
    "lineStrings": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineStrings"]),
    "lineToPolygon": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$to$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineToPolygon"]),
    "mask": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$mask$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mask"]),
    "meta": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__),
    "midpoint": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$midpoint$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["midpoint"]),
    "moranIndex": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$moran$2d$index$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["moranIndex"]),
    "multiLineString": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["multiLineString"]),
    "multiPoint": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["multiPoint"]),
    "multiPolygon": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["multiPolygon"]),
    "nearestNeighborAnalysis": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$neighbor$2d$analysis$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearestNeighborAnalysis"]),
    "nearestPoint": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearestPoint"]),
    "nearestPointOnLine": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearestPointOnLine"]),
    "nearestPointToLine": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2d$to$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearestPointToLine"]),
    "planepoint": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$planepoint$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["planepoint"]),
    "point": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"]),
    "pointGrid": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$point$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pointGrid"]),
    "pointOnFeature": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$point$2d$on$2d$feature$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pointOnFeature"]),
    "pointToLineDistance": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$point$2d$to$2d$line$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pointToLineDistance"]),
    "pointToPolygonDistance": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$point$2d$to$2d$polygon$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pointToPolygonDistance"]),
    "points": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["points"]),
    "pointsWithinPolygon": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$points$2d$within$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pointsWithinPolygon"]),
    "polygon": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"]),
    "polygonSmooth": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygon$2d$smooth$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygonSmooth"]),
    "polygonTangents": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygon$2d$tangents$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygonTangents"]),
    "polygonToLine": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygon$2d$to$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygonToLine"]),
    "polygonize": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygonize$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygonize"]),
    "polygons": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygons"]),
    "projection": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$projection$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__),
    "propEach": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["propEach"]),
    "propReduce": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["propReduce"]),
    "propertiesContainsFilter": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clusters$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["propertiesContainsFilter"]),
    "quadratAnalysis": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$quadrat$2d$analysis$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["quadratAnalysis"]),
    "radiansToDegrees": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["radiansToDegrees"]),
    "radiansToLength": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["radiansToLength"]),
    "random": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$random$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__),
    "randomLineString": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$random$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["randomLineString"]),
    "randomPoint": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$random$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["randomPoint"]),
    "randomPolygon": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$random$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["randomPolygon"]),
    "randomPosition": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$random$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["randomPosition"]),
    "rectangleGrid": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rectangle$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rectangleGrid"]),
    "rewind": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rewind$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rewind"]),
    "rhumbBearing": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rhumbBearing"]),
    "rhumbDestination": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rhumbDestination"]),
    "rhumbDistance": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rhumbDistance"]),
    "round": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["round"]),
    "sample": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$sample$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sample"]),
    "sector": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$sector$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sector"]),
    "segmentEach": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["segmentEach"]),
    "segmentReduce": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["segmentReduce"]),
    "shortestPath": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$shortest$2d$path$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["shortestPath"]),
    "simplify": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$simplify$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["simplify"]),
    "square": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$square$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["square"]),
    "squareGrid": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$square$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["squareGrid"]),
    "standardDeviationalEllipse": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$standard$2d$deviational$2d$ellipse$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["standardDeviationalEllipse"]),
    "tag": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$tag$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["tag"]),
    "tesselate": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$tesselate$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["tesselate"]),
    "tin": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$tin$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["tin"]),
    "toMercator": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$projection$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toMercator"]),
    "toWgs84": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$projection$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toWgs84"]),
    "transformRotate": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$transform$2d$rotate$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["transformRotate"]),
    "transformScale": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$transform$2d$scale$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["transformScale"]),
    "transformTranslate": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$transform$2d$translate$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["transformTranslate"]),
    "triangleGrid": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$triangle$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["triangleGrid"]),
    "truncate": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$truncate$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["truncate"]),
    "union": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$union$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["union"]),
    "unkinkPolygon": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$unkink$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unkinkPolygon"]),
    "validateBBox": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["validateBBox"]),
    "validateId": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["validateId"]),
    "voronoi": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$voronoi$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["voronoi"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$along$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/along/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$angle$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/angle/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$area$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/area/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2d$clip$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox-clip/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox-polygon/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bearing/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bezier$2d$spline$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bezier-spline/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$clockwise$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-clockwise/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$concave$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-concave/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$contains$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-contains/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$crosses$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-crosses/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$disjoint$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-disjoint/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$equal$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-equal/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$intersects$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-intersects/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$overlap$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-overlap/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$parallel$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-parallel/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-on-line/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$touches$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-touches/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$valid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-valid/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$within$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-within/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$buffer$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/buffer/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/center/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2d$mean$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/center-mean/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2d$median$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/center-median/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2d$of$2d$mass$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/center-of-mass/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/centroid/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$circle$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/circle/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clean$2d$coords$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clean-coords/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clusters$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clusters/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clusters$2d$dbscan$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clusters-dbscan/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clusters$2d$kmeans$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clusters-kmeans/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$collect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/collect/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$combine$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/combine/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$concave$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/concave/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$convex$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/convex/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/destination/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$difference$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/difference/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$dissolve$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/dissolve/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2d$weight$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance-weight/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$ellipse$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/ellipse/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$envelope$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/envelope/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$explode$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/explode/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$flatten$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/flatten/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$flip$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/flip/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$geojson$2d$rbush$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/geojson-rbush/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$great$2d$circle$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/great-circle/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$hex$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/hex-grid/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$interpolate$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/interpolate/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/intersect/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$isobands$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/isobands/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$isolines$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/isolines/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$kinks$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/kinks/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$length$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/length/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$arc$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-arc/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$chunk$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-chunk/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-intersect/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$offset$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-offset/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$overlap$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-overlap/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$segment$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-segment/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$slice$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-slice/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$slice$2d$along$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-slice-along/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$split$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-split/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$to$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-to-polygon/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$mask$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/mask/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$midpoint$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/midpoint/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$moran$2d$index$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/moran-index/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/nearest-point/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/nearest-point-on-line/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2d$to$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/nearest-point-to-line/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$planepoint$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/planepoint/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$point$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/point-grid/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$point$2d$on$2d$feature$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/point-on-feature/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$point$2d$to$2d$line$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/point-to-line-distance/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$point$2d$to$2d$polygon$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/point-to-polygon-distance/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$points$2d$within$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/points-within-polygon/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygon$2d$smooth$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/polygon-smooth/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygon$2d$tangents$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/polygon-tangents/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygon$2d$to$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/polygon-to-line/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygonize$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/polygonize/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$projection$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/projection/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$random$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/random/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rectangle$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rectangle-grid/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rewind$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rewind/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rhumb-bearing/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rhumb-destination/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rhumb-distance/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$sample$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/sample/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$sector$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/sector/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$shortest$2d$path$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/shortest-path/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$simplify$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/simplify/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$square$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/square/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$square$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/square-grid/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$standard$2d$deviational$2d$ellipse$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/standard-deviational-ellipse/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$tag$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/tag/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$tesselate$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/tesselate/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$tin$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/tin/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$transform$2d$rotate$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/transform-rotate/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$transform$2d$scale$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/transform-scale/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$transform$2d$translate$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/transform-translate/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$triangle$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/triangle-grid/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$truncate$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/truncate/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$union$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/union/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$unkink$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/unkink-polygon/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$voronoi$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/voronoi/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$neighbor$2d$analysis$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/nearest-neighbor-analysis/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$quadrat$2d$analysis$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/quadrat-analysis/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@turf/turf/dist/esm/index.js [app-ssr] (ecmascript) <locals>");
}}),
"[project]/node_modules/@turf/turf/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "along": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["along"]),
    "angle": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["angle"]),
    "applyFilter": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["applyFilter"]),
    "area": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["area"]),
    "areaFactors": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["areaFactors"]),
    "azimuthToBearing": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["azimuthToBearing"]),
    "bbox": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["bbox"]),
    "bboxClip": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["bboxClip"]),
    "bboxPolygon": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["bboxPolygon"]),
    "bearing": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["bearing"]),
    "bearingToAzimuth": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["bearingToAzimuth"]),
    "bezierSpline": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["bezierSpline"]),
    "booleanClockwise": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["booleanClockwise"]),
    "booleanConcave": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["booleanConcave"]),
    "booleanContains": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["booleanContains"]),
    "booleanCrosses": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["booleanCrosses"]),
    "booleanDisjoint": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["booleanDisjoint"]),
    "booleanEqual": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["booleanEqual"]),
    "booleanIntersects": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["booleanIntersects"]),
    "booleanOverlap": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["booleanOverlap"]),
    "booleanParallel": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["booleanParallel"]),
    "booleanPointInPolygon": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["booleanPointInPolygon"]),
    "booleanPointOnLine": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["booleanPointOnLine"]),
    "booleanTouches": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["booleanTouches"]),
    "booleanValid": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["booleanValid"]),
    "booleanWithin": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["booleanWithin"]),
    "buffer": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["buffer"]),
    "center": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["center"]),
    "centerMean": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["centerMean"]),
    "centerMedian": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["centerMedian"]),
    "centerOfMass": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["centerOfMass"]),
    "centroid": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["centroid"]),
    "circle": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["circle"]),
    "cleanCoords": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["cleanCoords"]),
    "clone": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["clone"]),
    "cloneProperties": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["cloneProperties"]),
    "clusterEach": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["clusterEach"]),
    "clusterReduce": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["clusterReduce"]),
    "clusters": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["clusters"]),
    "clustersDbscan": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["clustersDbscan"]),
    "clustersKmeans": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["clustersKmeans"]),
    "collect": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["collect"]),
    "collectionOf": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["collectionOf"]),
    "combine": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["combine"]),
    "concave": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["concave"]),
    "containsNumber": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["containsNumber"]),
    "convertArea": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["convertArea"]),
    "convertLength": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["convertLength"]),
    "convex": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["convex"]),
    "coordAll": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["coordAll"]),
    "coordEach": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["coordEach"]),
    "coordReduce": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["coordReduce"]),
    "createBins": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["createBins"]),
    "degreesToRadians": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["degreesToRadians"]),
    "destination": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["destination"]),
    "difference": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["difference"]),
    "dissolve": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["dissolve"]),
    "distance": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["distance"]),
    "distanceWeight": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["distanceWeight"]),
    "earthRadius": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["earthRadius"]),
    "ellipse": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["ellipse"]),
    "envelope": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["envelope"]),
    "explode": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["explode"]),
    "factors": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["factors"]),
    "feature": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["feature"]),
    "featureCollection": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["featureCollection"]),
    "featureEach": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["featureEach"]),
    "featureOf": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["featureOf"]),
    "featureReduce": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["featureReduce"]),
    "filterProperties": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["filterProperties"]),
    "findPoint": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["findPoint"]),
    "findSegment": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["findSegment"]),
    "flatten": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["flatten"]),
    "flattenEach": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["flattenEach"]),
    "flattenReduce": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["flattenReduce"]),
    "flip": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["flip"]),
    "geojsonRbush": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["geojsonRbush"]),
    "geojsonType": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["geojsonType"]),
    "geomEach": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["geomEach"]),
    "geomReduce": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["geomReduce"]),
    "geometry": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["geometry"]),
    "geometryCollection": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["geometryCollection"]),
    "getCluster": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["getCluster"]),
    "getCoord": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["getCoord"]),
    "getCoords": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["getCoords"]),
    "getGeom": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["getGeom"]),
    "getType": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["getType"]),
    "greatCircle": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["greatCircle"]),
    "helpers": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["helpers"]),
    "hexGrid": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["hexGrid"]),
    "interpolate": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["interpolate"]),
    "intersect": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["intersect"]),
    "invariant": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["invariant"]),
    "isNumber": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["isNumber"]),
    "isObject": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["isObject"]),
    "isobands": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["isobands"]),
    "isolines": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["isolines"]),
    "kinks": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["kinks"]),
    "length": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["length"]),
    "lengthToDegrees": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["lengthToDegrees"]),
    "lengthToRadians": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["lengthToRadians"]),
    "lineArc": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["lineArc"]),
    "lineChunk": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["lineChunk"]),
    "lineEach": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["lineEach"]),
    "lineIntersect": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["lineIntersect"]),
    "lineOffset": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["lineOffset"]),
    "lineOverlap": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["lineOverlap"]),
    "lineReduce": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["lineReduce"]),
    "lineSegment": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["lineSegment"]),
    "lineSlice": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["lineSlice"]),
    "lineSliceAlong": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["lineSliceAlong"]),
    "lineSplit": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["lineSplit"]),
    "lineString": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["lineString"]),
    "lineStrings": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["lineStrings"]),
    "lineToPolygon": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["lineToPolygon"]),
    "mask": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["mask"]),
    "meta": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["meta"]),
    "midpoint": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["midpoint"]),
    "moranIndex": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["moranIndex"]),
    "multiLineString": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["multiLineString"]),
    "multiPoint": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["multiPoint"]),
    "multiPolygon": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["multiPolygon"]),
    "nearestNeighborAnalysis": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["nearestNeighborAnalysis"]),
    "nearestPoint": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["nearestPoint"]),
    "nearestPointOnLine": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["nearestPointOnLine"]),
    "nearestPointToLine": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["nearestPointToLine"]),
    "planepoint": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["planepoint"]),
    "point": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["point"]),
    "pointGrid": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["pointGrid"]),
    "pointOnFeature": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["pointOnFeature"]),
    "pointToLineDistance": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["pointToLineDistance"]),
    "pointToPolygonDistance": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["pointToPolygonDistance"]),
    "points": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["points"]),
    "pointsWithinPolygon": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["pointsWithinPolygon"]),
    "polygon": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["polygon"]),
    "polygonSmooth": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["polygonSmooth"]),
    "polygonTangents": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["polygonTangents"]),
    "polygonToLine": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["polygonToLine"]),
    "polygonize": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["polygonize"]),
    "polygons": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["polygons"]),
    "projection": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["projection"]),
    "propEach": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["propEach"]),
    "propReduce": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["propReduce"]),
    "propertiesContainsFilter": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["propertiesContainsFilter"]),
    "quadratAnalysis": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["quadratAnalysis"]),
    "radiansToDegrees": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["radiansToDegrees"]),
    "radiansToLength": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["radiansToLength"]),
    "random": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["random"]),
    "randomLineString": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["randomLineString"]),
    "randomPoint": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["randomPoint"]),
    "randomPolygon": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["randomPolygon"]),
    "randomPosition": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["randomPosition"]),
    "rectangleGrid": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["rectangleGrid"]),
    "rewind": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["rewind"]),
    "rhumbBearing": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["rhumbBearing"]),
    "rhumbDestination": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["rhumbDestination"]),
    "rhumbDistance": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["rhumbDistance"]),
    "round": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["round"]),
    "sample": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["sample"]),
    "sector": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["sector"]),
    "segmentEach": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["segmentEach"]),
    "segmentReduce": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["segmentReduce"]),
    "shortestPath": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["shortestPath"]),
    "simplify": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["simplify"]),
    "square": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["square"]),
    "squareGrid": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["squareGrid"]),
    "standardDeviationalEllipse": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["standardDeviationalEllipse"]),
    "tag": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["tag"]),
    "tesselate": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["tesselate"]),
    "tin": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["tin"]),
    "toMercator": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["toMercator"]),
    "toWgs84": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["toWgs84"]),
    "transformRotate": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["transformRotate"]),
    "transformScale": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["transformScale"]),
    "transformTranslate": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["transformTranslate"]),
    "triangleGrid": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["triangleGrid"]),
    "truncate": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["truncate"]),
    "union": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["union"]),
    "unkinkPolygon": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["unkinkPolygon"]),
    "validateBBox": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["validateBBox"]),
    "validateId": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["validateId"]),
    "voronoi": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["voronoi"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@turf/turf/dist/esm/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__ = __turbopack_import__("[project]/node_modules/@turf/turf/dist/esm/index.js [app-ssr] (ecmascript) <exports>");
}}),
"[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "areaFactors": (()=>areaFactors),
    "azimuthToBearing": (()=>azimuthToBearing),
    "bearingToAzimuth": (()=>bearingToAzimuth),
    "convertArea": (()=>convertArea),
    "convertLength": (()=>convertLength),
    "degreesToRadians": (()=>degreesToRadians),
    "earthRadius": (()=>earthRadius),
    "factors": (()=>factors),
    "feature": (()=>feature),
    "featureCollection": (()=>featureCollection),
    "geometry": (()=>geometry),
    "geometryCollection": (()=>geometryCollection),
    "isNumber": (()=>isNumber),
    "isObject": (()=>isObject),
    "lengthToDegrees": (()=>lengthToDegrees),
    "lengthToRadians": (()=>lengthToRadians),
    "lineString": (()=>lineString),
    "lineStrings": (()=>lineStrings),
    "multiLineString": (()=>multiLineString),
    "multiPoint": (()=>multiPoint),
    "multiPolygon": (()=>multiPolygon),
    "point": (()=>point),
    "points": (()=>points),
    "polygon": (()=>polygon),
    "polygons": (()=>polygons),
    "radiansToDegrees": (()=>radiansToDegrees),
    "radiansToLength": (()=>radiansToLength),
    "round": (()=>round),
    "validateBBox": (()=>validateBBox),
    "validateId": (()=>validateId)
});
var earthRadius = 63710088e-1;
var factors = {
    centimeters: earthRadius * 100,
    centimetres: earthRadius * 100,
    degrees: 360 / (2 * Math.PI),
    feet: earthRadius * 3.28084,
    inches: earthRadius * 39.37,
    kilometers: earthRadius / 1e3,
    kilometres: earthRadius / 1e3,
    meters: earthRadius,
    metres: earthRadius,
    miles: earthRadius / 1609.344,
    millimeters: earthRadius * 1e3,
    millimetres: earthRadius * 1e3,
    nauticalmiles: earthRadius / 1852,
    radians: 1,
    yards: earthRadius * 1.0936
};
var areaFactors = {
    acres: 247105e-9,
    centimeters: 1e4,
    centimetres: 1e4,
    feet: 10.763910417,
    hectares: 1e-4,
    inches: 1550.003100006,
    kilometers: 1e-6,
    kilometres: 1e-6,
    meters: 1,
    metres: 1,
    miles: 386e-9,
    nauticalmiles: 29155334959812285e-23,
    millimeters: 1e6,
    millimetres: 1e6,
    yards: 1.195990046
};
function feature(geom, properties, options = {}) {
    const feat = {
        type: "Feature"
    };
    if (options.id === 0 || options.id) {
        feat.id = options.id;
    }
    if (options.bbox) {
        feat.bbox = options.bbox;
    }
    feat.properties = properties || {};
    feat.geometry = geom;
    return feat;
}
function geometry(type, coordinates, _options = {}) {
    switch(type){
        case "Point":
            return point(coordinates).geometry;
        case "LineString":
            return lineString(coordinates).geometry;
        case "Polygon":
            return polygon(coordinates).geometry;
        case "MultiPoint":
            return multiPoint(coordinates).geometry;
        case "MultiLineString":
            return multiLineString(coordinates).geometry;
        case "MultiPolygon":
            return multiPolygon(coordinates).geometry;
        default:
            throw new Error(type + " is invalid");
    }
}
function point(coordinates, properties, options = {}) {
    if (!coordinates) {
        throw new Error("coordinates is required");
    }
    if (!Array.isArray(coordinates)) {
        throw new Error("coordinates must be an Array");
    }
    if (coordinates.length < 2) {
        throw new Error("coordinates must be at least 2 numbers long");
    }
    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {
        throw new Error("coordinates must contain numbers");
    }
    const geom = {
        type: "Point",
        coordinates
    };
    return feature(geom, properties, options);
}
function points(coordinates, properties, options = {}) {
    return featureCollection(coordinates.map((coords)=>{
        return point(coords, properties);
    }), options);
}
function polygon(coordinates, properties, options = {}) {
    for (const ring of coordinates){
        if (ring.length < 4) {
            throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
        }
        if (ring[ring.length - 1].length !== ring[0].length) {
            throw new Error("First and last Position are not equivalent.");
        }
        for(let j = 0; j < ring[ring.length - 1].length; j++){
            if (ring[ring.length - 1][j] !== ring[0][j]) {
                throw new Error("First and last Position are not equivalent.");
            }
        }
    }
    const geom = {
        type: "Polygon",
        coordinates
    };
    return feature(geom, properties, options);
}
function polygons(coordinates, properties, options = {}) {
    return featureCollection(coordinates.map((coords)=>{
        return polygon(coords, properties);
    }), options);
}
function lineString(coordinates, properties, options = {}) {
    if (coordinates.length < 2) {
        throw new Error("coordinates must be an array of two or more positions");
    }
    const geom = {
        type: "LineString",
        coordinates
    };
    return feature(geom, properties, options);
}
function lineStrings(coordinates, properties, options = {}) {
    return featureCollection(coordinates.map((coords)=>{
        return lineString(coords, properties);
    }), options);
}
function featureCollection(features, options = {}) {
    const fc = {
        type: "FeatureCollection"
    };
    if (options.id) {
        fc.id = options.id;
    }
    if (options.bbox) {
        fc.bbox = options.bbox;
    }
    fc.features = features;
    return fc;
}
function multiLineString(coordinates, properties, options = {}) {
    const geom = {
        type: "MultiLineString",
        coordinates
    };
    return feature(geom, properties, options);
}
function multiPoint(coordinates, properties, options = {}) {
    const geom = {
        type: "MultiPoint",
        coordinates
    };
    return feature(geom, properties, options);
}
function multiPolygon(coordinates, properties, options = {}) {
    const geom = {
        type: "MultiPolygon",
        coordinates
    };
    return feature(geom, properties, options);
}
function geometryCollection(geometries, properties, options = {}) {
    const geom = {
        type: "GeometryCollection",
        geometries
    };
    return feature(geom, properties, options);
}
function round(num, precision = 0) {
    if (precision && !(precision >= 0)) {
        throw new Error("precision must be a positive number");
    }
    const multiplier = Math.pow(10, precision || 0);
    return Math.round(num * multiplier) / multiplier;
}
function radiansToLength(radians, units = "kilometers") {
    const factor = factors[units];
    if (!factor) {
        throw new Error(units + " units is invalid");
    }
    return radians * factor;
}
function lengthToRadians(distance, units = "kilometers") {
    const factor = factors[units];
    if (!factor) {
        throw new Error(units + " units is invalid");
    }
    return distance / factor;
}
function lengthToDegrees(distance, units) {
    return radiansToDegrees(lengthToRadians(distance, units));
}
function bearingToAzimuth(bearing) {
    let angle = bearing % 360;
    if (angle < 0) {
        angle += 360;
    }
    return angle;
}
function azimuthToBearing(angle) {
    angle = angle % 360;
    if (angle > 180) {
        return angle - 360;
    } else if (angle < -180) {
        return angle + 360;
    }
    return angle;
}
function radiansToDegrees(radians) {
    const normalisedRadians = radians % (2 * Math.PI);
    return normalisedRadians * 180 / Math.PI;
}
function degreesToRadians(degrees) {
    const normalisedDegrees = degrees % 360;
    return normalisedDegrees * Math.PI / 180;
}
function convertLength(length, originalUnit = "kilometers", finalUnit = "kilometers") {
    if (!(length >= 0)) {
        throw new Error("length must be a positive number");
    }
    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);
}
function convertArea(area, originalUnit = "meters", finalUnit = "kilometers") {
    if (!(area >= 0)) {
        throw new Error("area must be a positive number");
    }
    const startFactor = areaFactors[originalUnit];
    if (!startFactor) {
        throw new Error("invalid original units");
    }
    const finalFactor = areaFactors[finalUnit];
    if (!finalFactor) {
        throw new Error("invalid final units");
    }
    return area / startFactor * finalFactor;
}
function isNumber(num) {
    return !isNaN(num) && num !== null && !Array.isArray(num);
}
function isObject(input) {
    return input !== null && typeof input === "object" && !Array.isArray(input);
}
function validateBBox(bbox) {
    if (!bbox) {
        throw new Error("bbox is required");
    }
    if (!Array.isArray(bbox)) {
        throw new Error("bbox must be an Array");
    }
    if (bbox.length !== 4 && bbox.length !== 6) {
        throw new Error("bbox must be an Array of 4 or 6 numbers");
    }
    bbox.forEach((num)=>{
        if (!isNumber(num)) {
            throw new Error("bbox must only contain numbers");
        }
    });
}
function validateId(id) {
    if (!id) {
        throw new Error("id is required");
    }
    if ([
        "string",
        "number"
    ].indexOf(typeof id) === -1) {
        throw new Error("id must be a number or a string");
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "collectionOf": (()=>collectionOf),
    "containsNumber": (()=>containsNumber),
    "featureOf": (()=>featureOf),
    "geojsonType": (()=>geojsonType),
    "getCoord": (()=>getCoord),
    "getCoords": (()=>getCoords),
    "getGeom": (()=>getGeom),
    "getType": (()=>getType)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
function getCoord(coord) {
    if (!coord) {
        throw new Error("coord is required");
    }
    if (!Array.isArray(coord)) {
        if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
            return [
                ...coord.geometry.coordinates
            ];
        }
        if (coord.type === "Point") {
            return [
                ...coord.coordinates
            ];
        }
    }
    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
        return [
            ...coord
        ];
    }
    throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
function getCoords(coords) {
    if (Array.isArray(coords)) {
        return coords;
    }
    if (coords.type === "Feature") {
        if (coords.geometry !== null) {
            return coords.geometry.coordinates;
        }
    } else {
        if (coords.coordinates) {
            return coords.coordinates;
        }
    }
    throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}
function containsNumber(coordinates) {
    if (coordinates.length > 1 && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(coordinates[0]) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(coordinates[1])) {
        return true;
    }
    if (Array.isArray(coordinates[0]) && coordinates[0].length) {
        return containsNumber(coordinates[0]);
    }
    throw new Error("coordinates must only contain numbers");
}
function geojsonType(value, type, name) {
    if (!type || !name) {
        throw new Error("type and name required");
    }
    if (!value || value.type !== type) {
        throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + value.type);
    }
}
function featureOf(feature, type, name) {
    if (!feature) {
        throw new Error("No feature passed");
    }
    if (!name) {
        throw new Error(".featureOf() requires a name");
    }
    if (!feature || feature.type !== "Feature" || !feature.geometry) {
        throw new Error("Invalid input to " + name + ", Feature with geometry required");
    }
    if (!feature.geometry || feature.geometry.type !== type) {
        throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature.geometry.type);
    }
}
function collectionOf(featureCollection, type, name) {
    if (!featureCollection) {
        throw new Error("No featureCollection passed");
    }
    if (!name) {
        throw new Error(".collectionOf() requires a name");
    }
    if (!featureCollection || featureCollection.type !== "FeatureCollection") {
        throw new Error("Invalid input to " + name + ", FeatureCollection required");
    }
    for (const feature of featureCollection.features){
        if (!feature || feature.type !== "Feature" || !feature.geometry) {
            throw new Error("Invalid input to " + name + ", Feature with geometry required");
        }
        if (!feature.geometry || feature.geometry.type !== type) {
            throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature.geometry.type);
        }
    }
}
function getGeom(geojson) {
    if (geojson.type === "Feature") {
        return geojson.geometry;
    }
    return geojson;
}
function getType(geojson, _name) {
    if (geojson.type === "FeatureCollection") {
        return "FeatureCollection";
    }
    if (geojson.type === "GeometryCollection") {
        return "GeometryCollection";
    }
    if (geojson.type === "Feature" && geojson.geometry !== null) {
        return geojson.geometry.type;
    }
    return geojson.type;
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/bearing/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "bearing": (()=>bearing),
    "default": (()=>turf_bearing_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
function bearing(start, end, options = {}) {
    if (options.final === true) {
        return calculateFinalBearing(start, end);
    }
    const coordinates1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(start);
    const coordinates2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(end);
    const lon1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["degreesToRadians"])(coordinates1[0]);
    const lon2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["degreesToRadians"])(coordinates2[0]);
    const lat1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["degreesToRadians"])(coordinates1[1]);
    const lat2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["degreesToRadians"])(coordinates2[1]);
    const a = Math.sin(lon2 - lon1) * Math.cos(lat2);
    const b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["radiansToDegrees"])(Math.atan2(a, b));
}
function calculateFinalBearing(start, end) {
    let bear = bearing(end, start);
    bear = (bear + 180) % 360;
    return bear;
}
var turf_bearing_default = bearing;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/destination/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_destination_default),
    "destination": (()=>destination)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
function destination(origin, distance, bearing, options = {}) {
    const coordinates1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(origin);
    const longitude1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["degreesToRadians"])(coordinates1[0]);
    const latitude1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["degreesToRadians"])(coordinates1[1]);
    const bearingRad = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["degreesToRadians"])(bearing);
    const radians = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lengthToRadians"])(distance, options.units);
    const latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) + Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));
    const longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));
    const lng = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["radiansToDegrees"])(longitude2);
    const lat = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["radiansToDegrees"])(latitude2);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])([
        lng,
        lat
    ], options.properties);
}
var turf_destination_default = destination;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/distance/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_distance_default),
    "distance": (()=>distance)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
function distance(from, to, options = {}) {
    var coordinates1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(from);
    var coordinates2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(to);
    var dLat = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["degreesToRadians"])(coordinates2[1] - coordinates1[1]);
    var dLon = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["degreesToRadians"])(coordinates2[0] - coordinates1[0]);
    var lat1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["degreesToRadians"])(coordinates1[1]);
    var lat2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["degreesToRadians"])(coordinates2[1]);
    var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["radiansToLength"])(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);
}
var turf_distance_default = distance;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/along/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "along": (()=>along),
    "default": (()=>turf_along_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bearing/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/destination/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
;
function along(line, distance, options = {}) {
    const geom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getGeom"])(line);
    const coords = geom.coordinates;
    let travelled = 0;
    for(let i = 0; i < coords.length; i++){
        if (distance >= travelled && i === coords.length - 1) {
            break;
        } else if (travelled >= distance) {
            const overshot = distance - travelled;
            if (!overshot) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])(coords[i]);
            } else {
                const direction = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bearing"])(coords[i], coords[i - 1]) - 180;
                const interpolated = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["destination"])(coords[i], overshot, direction, options);
                return interpolated;
            }
        } else {
            travelled += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distance"])(coords[i], coords[i + 1], options);
        }
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])(coords[coords.length - 1]);
}
var turf_along_default = along;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/rhumb-bearing/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_rhumb_bearing_default),
    "rhumbBearing": (()=>rhumbBearing)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
function rhumbBearing(start, end, options = {}) {
    let bear360;
    if (options.final) {
        bear360 = calculateRhumbBearing((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(end), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(start));
    } else {
        bear360 = calculateRhumbBearing((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(start), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(end));
    }
    const bear180 = bear360 > 180 ? -(360 - bear360) : bear360;
    return bear180;
}
function calculateRhumbBearing(from, to) {
    const phi1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["degreesToRadians"])(from[1]);
    const phi2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["degreesToRadians"])(to[1]);
    let deltaLambda = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["degreesToRadians"])(to[0] - from[0]);
    if (deltaLambda > Math.PI) {
        deltaLambda -= 2 * Math.PI;
    }
    if (deltaLambda < -Math.PI) {
        deltaLambda += 2 * Math.PI;
    }
    const deltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
    const theta = Math.atan2(deltaLambda, deltaPsi);
    return ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["radiansToDegrees"])(theta) + 360) % 360;
}
var turf_rhumb_bearing_default = rhumbBearing;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/angle/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "angle": (()=>angle),
    "default": (()=>turf_angle_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rhumb-bearing/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bearing/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
function angle(startPoint, midPoint, endPoint, options = {}) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(options)) {
        throw new Error("options is invalid");
    }
    if (!startPoint) {
        throw new Error("startPoint is required");
    }
    if (!midPoint) {
        throw new Error("midPoint is required");
    }
    if (!endPoint) {
        throw new Error("endPoint is required");
    }
    const A = startPoint;
    const O = midPoint;
    const B = endPoint;
    const azimuthOA = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bearingToAzimuth"])(options.mercator !== true ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bearing"])(O, A) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rhumbBearing"])(O, A));
    let azimuthOB = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bearingToAzimuth"])(options.mercator !== true ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bearing"])(O, B) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rhumbBearing"])(O, B));
    if (azimuthOB < azimuthOA) {
        azimuthOB = azimuthOB + 360;
    }
    const angleAOB = azimuthOB - azimuthOA;
    if (options.explementary === true) {
        return 360 - angleAOB;
    }
    return angleAOB;
}
var turf_angle_default = angle;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.js
__turbopack_esm__({
    "coordAll": (()=>coordAll),
    "coordEach": (()=>coordEach),
    "coordReduce": (()=>coordReduce),
    "featureEach": (()=>featureEach),
    "featureReduce": (()=>featureReduce),
    "findPoint": (()=>findPoint),
    "findSegment": (()=>findSegment),
    "flattenEach": (()=>flattenEach),
    "flattenReduce": (()=>flattenReduce),
    "geomEach": (()=>geomEach),
    "geomReduce": (()=>geomReduce),
    "lineEach": (()=>lineEach),
    "lineReduce": (()=>lineReduce),
    "propEach": (()=>propEach),
    "propReduce": (()=>propReduce),
    "segmentEach": (()=>segmentEach),
    "segmentReduce": (()=>segmentReduce)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
function coordEach(geojson, callback, excludeWrapCoord) {
    if (geojson === null) return;
    var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === "FeatureCollection", isFeature = type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
    for(var featureIndex = 0; featureIndex < stop; featureIndex++){
        geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
        isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
        for(var geomIndex = 0; geomIndex < stopG; geomIndex++){
            var multiFeatureIndex = 0;
            var geometryIndex = 0;
            geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;
            if (geometry === null) continue;
            coords = geometry.coordinates;
            var geomType = geometry.type;
            wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;
            switch(geomType){
                case null:
                    break;
                case "Point":
                    if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                    coordIndex++;
                    multiFeatureIndex++;
                    break;
                case "LineString":
                case "MultiPoint":
                    for(j = 0; j < coords.length; j++){
                        if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                        coordIndex++;
                        if (geomType === "MultiPoint") multiFeatureIndex++;
                    }
                    if (geomType === "LineString") multiFeatureIndex++;
                    break;
                case "Polygon":
                case "MultiLineString":
                    for(j = 0; j < coords.length; j++){
                        for(k = 0; k < coords[j].length - wrapShrink; k++){
                            if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                            coordIndex++;
                        }
                        if (geomType === "MultiLineString") multiFeatureIndex++;
                        if (geomType === "Polygon") geometryIndex++;
                    }
                    if (geomType === "Polygon") multiFeatureIndex++;
                    break;
                case "MultiPolygon":
                    for(j = 0; j < coords.length; j++){
                        geometryIndex = 0;
                        for(k = 0; k < coords[j].length; k++){
                            for(l = 0; l < coords[j][k].length - wrapShrink; l++){
                                if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                                coordIndex++;
                            }
                            geometryIndex++;
                        }
                        multiFeatureIndex++;
                    }
                    break;
                case "GeometryCollection":
                    for(j = 0; j < geometry.geometries.length; j++)if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;
                    break;
                default:
                    throw new Error("Unknown Geometry Type");
            }
        }
    }
}
function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
    var previousValue = initialValue;
    coordEach(geojson, function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
        if (coordIndex === 0 && initialValue === void 0) previousValue = currentCoord;
        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);
    }, excludeWrapCoord);
    return previousValue;
}
function propEach(geojson, callback) {
    var i;
    switch(geojson.type){
        case "FeatureCollection":
            for(i = 0; i < geojson.features.length; i++){
                if (callback(geojson.features[i].properties, i) === false) break;
            }
            break;
        case "Feature":
            callback(geojson.properties, 0);
            break;
    }
}
function propReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    propEach(geojson, function(currentProperties, featureIndex) {
        if (featureIndex === 0 && initialValue === void 0) previousValue = currentProperties;
        else previousValue = callback(previousValue, currentProperties, featureIndex);
    });
    return previousValue;
}
function featureEach(geojson, callback) {
    if (geojson.type === "Feature") {
        callback(geojson, 0);
    } else if (geojson.type === "FeatureCollection") {
        for(var i = 0; i < geojson.features.length; i++){
            if (callback(geojson.features[i], i) === false) break;
        }
    }
}
function featureReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    featureEach(geojson, function(currentFeature, featureIndex) {
        if (featureIndex === 0 && initialValue === void 0) previousValue = currentFeature;
        else previousValue = callback(previousValue, currentFeature, featureIndex);
    });
    return previousValue;
}
function coordAll(geojson) {
    var coords = [];
    coordEach(geojson, function(coord) {
        coords.push(coord);
    });
    return coords;
}
function geomEach(geojson, callback) {
    var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
    for(i = 0; i < stop; i++){
        geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;
        featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};
        featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;
        featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;
        isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
        for(g = 0; g < stopG; g++){
            geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
            if (geometry === null) {
                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;
                continue;
            }
            switch(geometry.type){
                case "Point":
                case "LineString":
                case "MultiPoint":
                case "Polygon":
                case "MultiLineString":
                case "MultiPolygon":
                    {
                        if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;
                        break;
                    }
                case "GeometryCollection":
                    {
                        for(j = 0; j < geometry.geometries.length; j++){
                            if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;
                        }
                        break;
                    }
                default:
                    throw new Error("Unknown Geometry Type");
            }
        }
        featureIndex++;
    }
}
function geomReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    geomEach(geojson, function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
        if (featureIndex === 0 && initialValue === void 0) previousValue = currentGeometry;
        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);
    });
    return previousValue;
}
function flattenEach(geojson, callback) {
    geomEach(geojson, function(geometry, featureIndex, properties, bbox, id) {
        var type = geometry === null ? null : geometry.type;
        switch(type){
            case null:
            case "Point":
            case "LineString":
            case "Polygon":
                if (callback((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["feature"])(geometry, properties, {
                    bbox,
                    id
                }), featureIndex, 0) === false) return false;
                return;
        }
        var geomType;
        switch(type){
            case "MultiPoint":
                geomType = "Point";
                break;
            case "MultiLineString":
                geomType = "LineString";
                break;
            case "MultiPolygon":
                geomType = "Polygon";
                break;
        }
        for(var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++){
            var coordinate = geometry.coordinates[multiFeatureIndex];
            var geom = {
                type: geomType,
                coordinates: coordinate
            };
            if (callback((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["feature"])(geom, properties), featureIndex, multiFeatureIndex) === false) return false;
        }
    });
}
function flattenReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    flattenEach(geojson, function(currentFeature, featureIndex, multiFeatureIndex) {
        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === void 0) previousValue = currentFeature;
        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);
    });
    return previousValue;
}
function segmentEach(geojson, callback) {
    flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {
        var segmentIndex = 0;
        if (!feature2.geometry) return;
        var type = feature2.geometry.type;
        if (type === "Point" || type === "MultiPoint") return;
        var previousCoords;
        var previousFeatureIndex = 0;
        var previousMultiIndex = 0;
        var prevGeomIndex = 0;
        if (coordEach(feature2, function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {
            if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {
                previousCoords = currentCoord;
                previousFeatureIndex = featureIndex;
                previousMultiIndex = multiPartIndexCoord;
                prevGeomIndex = geometryIndex;
                segmentIndex = 0;
                return;
            }
            var currentSegment = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineString"])([
                previousCoords,
                currentCoord
            ], feature2.properties);
            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;
            segmentIndex++;
            previousCoords = currentCoord;
        }) === false) return false;
    });
}
function segmentReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    var started = false;
    segmentEach(geojson, function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
        if (started === false && initialValue === void 0) previousValue = currentSegment;
        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);
        started = true;
    });
    return previousValue;
}
function lineEach(geojson, callback) {
    if (!geojson) throw new Error("geojson is required");
    flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {
        if (feature2.geometry === null) return;
        var type = feature2.geometry.type;
        var coords = feature2.geometry.coordinates;
        switch(type){
            case "LineString":
                if (callback(feature2, featureIndex, multiFeatureIndex, 0, 0) === false) return false;
                break;
            case "Polygon":
                for(var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++){
                    if (callback((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineString"])(coords[geometryIndex], feature2.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                }
                break;
        }
    });
}
function lineReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    lineEach(geojson, function(currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
        if (featureIndex === 0 && initialValue === void 0) previousValue = currentLine;
        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);
    });
    return previousValue;
}
function findSegment(geojson, options) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    var featureIndex = options.featureIndex || 0;
    var multiFeatureIndex = options.multiFeatureIndex || 0;
    var geometryIndex = options.geometryIndex || 0;
    var segmentIndex = options.segmentIndex || 0;
    var properties = options.properties;
    var geometry;
    switch(geojson.type){
        case "FeatureCollection":
            if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;
            properties = properties || geojson.features[featureIndex].properties;
            geometry = geojson.features[featureIndex].geometry;
            break;
        case "Feature":
            properties = properties || geojson.properties;
            geometry = geojson.geometry;
            break;
        case "Point":
        case "MultiPoint":
            return null;
        case "LineString":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon":
            geometry = geojson;
            break;
        default:
            throw new Error("geojson is invalid");
    }
    if (geometry === null) return null;
    var coords = geometry.coordinates;
    switch(geometry.type){
        case "Point":
        case "MultiPoint":
            return null;
        case "LineString":
            if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineString"])([
                coords[segmentIndex],
                coords[segmentIndex + 1]
            ], properties, options);
        case "Polygon":
            if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
            if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineString"])([
                coords[geometryIndex][segmentIndex],
                coords[geometryIndex][segmentIndex + 1]
            ], properties, options);
        case "MultiLineString":
            if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
            if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineString"])([
                coords[multiFeatureIndex][segmentIndex],
                coords[multiFeatureIndex][segmentIndex + 1]
            ], properties, options);
        case "MultiPolygon":
            if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
            if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
            if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineString"])([
                coords[multiFeatureIndex][geometryIndex][segmentIndex],
                coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]
            ], properties, options);
    }
    throw new Error("geojson is invalid");
}
function findPoint(geojson, options) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    var featureIndex = options.featureIndex || 0;
    var multiFeatureIndex = options.multiFeatureIndex || 0;
    var geometryIndex = options.geometryIndex || 0;
    var coordIndex = options.coordIndex || 0;
    var properties = options.properties;
    var geometry;
    switch(geojson.type){
        case "FeatureCollection":
            if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;
            properties = properties || geojson.features[featureIndex].properties;
            geometry = geojson.features[featureIndex].geometry;
            break;
        case "Feature":
            properties = properties || geojson.properties;
            geometry = geojson.geometry;
            break;
        case "Point":
        case "MultiPoint":
            return null;
        case "LineString":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon":
            geometry = geojson;
            break;
        default:
            throw new Error("geojson is invalid");
    }
    if (geometry === null) return null;
    var coords = geometry.coordinates;
    switch(geometry.type){
        case "Point":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])(coords, properties, options);
        case "MultiPoint":
            if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])(coords[multiFeatureIndex], properties, options);
        case "LineString":
            if (coordIndex < 0) coordIndex = coords.length + coordIndex;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])(coords[coordIndex], properties, options);
        case "Polygon":
            if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
            if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])(coords[geometryIndex][coordIndex], properties, options);
        case "MultiLineString":
            if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
            if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])(coords[multiFeatureIndex][coordIndex], properties, options);
        case "MultiPolygon":
            if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
            if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
            if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);
    }
    throw new Error("geojson is invalid");
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/area/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "area": (()=>area),
    "default": (()=>turf_area_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
function area(geojson) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["geomReduce"])(geojson, (value, geom)=>{
        return value + calculateArea(geom);
    }, 0);
}
function calculateArea(geom) {
    let total = 0;
    let i;
    switch(geom.type){
        case "Polygon":
            return polygonArea(geom.coordinates);
        case "MultiPolygon":
            for(i = 0; i < geom.coordinates.length; i++){
                total += polygonArea(geom.coordinates[i]);
            }
            return total;
        case "Point":
        case "MultiPoint":
        case "LineString":
        case "MultiLineString":
            return 0;
    }
    return 0;
}
function polygonArea(coords) {
    let total = 0;
    if (coords && coords.length > 0) {
        total += Math.abs(ringArea(coords[0]));
        for(let i = 1; i < coords.length; i++){
            total -= Math.abs(ringArea(coords[i]));
        }
    }
    return total;
}
var FACTOR = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["earthRadius"] * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["earthRadius"] / 2;
var PI_OVER_180 = Math.PI / 180;
function ringArea(coords) {
    const coordsLength = coords.length - 1;
    if (coordsLength <= 2) return 0;
    let total = 0;
    let i = 0;
    while(i < coordsLength){
        const lower = coords[i];
        const middle = coords[i + 1 === coordsLength ? 0 : i + 1];
        const upper = coords[i + 2 >= coordsLength ? (i + 2) % coordsLength : i + 2];
        const lowerX = lower[0] * PI_OVER_180;
        const middleY = middle[1] * PI_OVER_180;
        const upperX = upper[0] * PI_OVER_180;
        total += (upperX - lowerX) * Math.sin(middleY);
        i++;
    }
    return total * FACTOR;
}
var turf_area_default = area;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/bbox/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "bbox": (()=>bbox),
    "default": (()=>turf_bbox_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
;
function bbox(geojson, options = {}) {
    if (geojson.bbox != null && true !== options.recompute) {
        return geojson.bbox;
    }
    const result = [
        Infinity,
        Infinity,
        -Infinity,
        -Infinity
    ];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["coordEach"])(geojson, (coord)=>{
        if (result[0] > coord[0]) {
            result[0] = coord[0];
        }
        if (result[1] > coord[1]) {
            result[1] = coord[1];
        }
        if (result[2] < coord[0]) {
            result[2] = coord[0];
        }
        if (result[3] < coord[1]) {
            result[3] = coord[1];
        }
    });
    return result;
}
var turf_bbox_default = bbox;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/bbox-clip/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "bboxClip": (()=>bboxClip),
    "default": (()=>turf_bbox_clip_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
// lib/lineclip.ts
function lineclip(points, bbox, result) {
    var len = points.length, codeA = bitCode(points[0], bbox), part = [], i, codeB, lastCode;
    let a;
    let b;
    if (!result) result = [];
    for(i = 1; i < len; i++){
        a = points[i - 1];
        b = points[i];
        codeB = lastCode = bitCode(b, bbox);
        while(true){
            if (!(codeA | codeB)) {
                part.push(a);
                if (codeB !== lastCode) {
                    part.push(b);
                    if (i < len - 1) {
                        result.push(part);
                        part = [];
                    }
                } else if (i === len - 1) {
                    part.push(b);
                }
                break;
            } else if (codeA & codeB) {
                break;
            } else if (codeA) {
                a = intersect(a, b, codeA, bbox);
                codeA = bitCode(a, bbox);
            } else {
                b = intersect(a, b, codeB, bbox);
                codeB = bitCode(b, bbox);
            }
        }
        codeA = lastCode;
    }
    if (part.length) result.push(part);
    return result;
}
function polygonclip(points, bbox) {
    var result, edge, prev, prevInside, i, p, inside;
    for(edge = 1; edge <= 8; edge *= 2){
        result = [];
        prev = points[points.length - 1];
        prevInside = !(bitCode(prev, bbox) & edge);
        for(i = 0; i < points.length; i++){
            p = points[i];
            inside = !(bitCode(p, bbox) & edge);
            if (inside !== prevInside) result.push(intersect(prev, p, edge, bbox));
            if (inside) result.push(p);
            prev = p;
            prevInside = inside;
        }
        points = result;
        if (!points.length) break;
    }
    return result;
}
function intersect(a, b, edge, bbox) {
    return edge & 8 ? [
        a[0] + (b[0] - a[0]) * (bbox[3] - a[1]) / (b[1] - a[1]),
        bbox[3]
    ] : edge & 4 ? [
        a[0] + (b[0] - a[0]) * (bbox[1] - a[1]) / (b[1] - a[1]),
        bbox[1]
    ] : edge & 2 ? [
        bbox[2],
        a[1] + (b[1] - a[1]) * (bbox[2] - a[0]) / (b[0] - a[0])
    ] : edge & 1 ? [
        bbox[0],
        a[1] + (b[1] - a[1]) * (bbox[0] - a[0]) / (b[0] - a[0])
    ] : null;
}
function bitCode(p, bbox) {
    var code = 0;
    if (p[0] < bbox[0]) code |= 1;
    else if (p[0] > bbox[2]) code |= 2;
    if (p[1] < bbox[1]) code |= 4;
    else if (p[1] > bbox[3]) code |= 8;
    return code;
}
// index.ts
function bboxClip(feature, bbox) {
    const geom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getGeom"])(feature);
    const type = geom.type;
    const properties = feature.type === "Feature" ? feature.properties : {};
    let coords = geom.coordinates;
    switch(type){
        case "LineString":
        case "MultiLineString":
            {
                const lines = [];
                if (type === "LineString") {
                    coords = [
                        coords
                    ];
                }
                coords.forEach((line)=>{
                    lineclip(line, bbox, lines);
                });
                if (lines.length === 1) {
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineString"])(lines[0], properties);
                }
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["multiLineString"])(lines, properties);
            }
        case "Polygon":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])(clipPolygon(coords, bbox), properties);
        case "MultiPolygon":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["multiPolygon"])(coords.map((poly)=>{
                return clipPolygon(poly, bbox);
            }), properties);
        default:
            throw new Error("geometry " + type + " not supported");
    }
}
function clipPolygon(rings, bbox) {
    const outRings = [];
    for (const ring of rings){
        const clipped = polygonclip(ring, bbox);
        if (clipped.length > 0) {
            if (clipped[0][0] !== clipped[clipped.length - 1][0] || clipped[0][1] !== clipped[clipped.length - 1][1]) {
                clipped.push(clipped[0]);
            }
            if (clipped.length >= 4) {
                outRings.push(clipped);
            }
        }
    }
    return outRings;
}
var turf_bbox_clip_default = bboxClip;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/bbox-polygon/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "bboxPolygon": (()=>bboxPolygon),
    "default": (()=>turf_bbox_polygon_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
function bboxPolygon(bbox, options = {}) {
    const west = Number(bbox[0]);
    const south = Number(bbox[1]);
    const east = Number(bbox[2]);
    const north = Number(bbox[3]);
    if (bbox.length === 6) {
        throw new Error("@turf/bbox-polygon does not support BBox with 6 positions");
    }
    const lowLeft = [
        west,
        south
    ];
    const topLeft = [
        west,
        north
    ];
    const topRight = [
        east,
        north
    ];
    const lowRight = [
        east,
        south
    ];
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])([
        [
            lowLeft,
            lowRight,
            topRight,
            topLeft,
            lowLeft
        ]
    ], options.properties, {
        bbox,
        id: options.id
    });
}
var turf_bbox_polygon_default = bboxPolygon;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/bezier-spline/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "bezierSpline": (()=>bezierSpline),
    "default": (()=>turf_bezier_spline_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
// lib/spline.ts
var Spline = class {
    constructor(options){
        this.points = options.points || [];
        this.duration = options.duration || 1e4;
        this.sharpness = options.sharpness || 0.85;
        this.centers = [];
        this.controls = [];
        this.stepLength = options.stepLength || 60;
        this.length = this.points.length;
        this.delay = 0;
        for(let i = 0; i < this.length; i++){
            this.points[i].z = this.points[i].z || 0;
        }
        for(let i = 0; i < this.length - 1; i++){
            const p1 = this.points[i];
            const p2 = this.points[i + 1];
            this.centers.push({
                x: (p1.x + p2.x) / 2,
                y: (p1.y + p2.y) / 2,
                z: (p1.z + p2.z) / 2
            });
        }
        this.controls.push([
            this.points[0],
            this.points[0]
        ]);
        for(let i = 0; i < this.centers.length - 1; i++){
            const dx = this.points[i + 1].x - (this.centers[i].x + this.centers[i + 1].x) / 2;
            const dy = this.points[i + 1].y - (this.centers[i].y + this.centers[i + 1].y) / 2;
            const dz = this.points[i + 1].z - (this.centers[i].y + this.centers[i + 1].z) / 2;
            this.controls.push([
                {
                    x: (1 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i].x + dx),
                    y: (1 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i].y + dy),
                    z: (1 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i].z + dz)
                },
                {
                    x: (1 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i + 1].x + dx),
                    y: (1 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i + 1].y + dy),
                    z: (1 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i + 1].z + dz)
                }
            ]);
        }
        this.controls.push([
            this.points[this.length - 1],
            this.points[this.length - 1]
        ]);
        this.steps = this.cacheSteps(this.stepLength);
        return this;
    }
    /**
   * Caches an array of equidistant (more or less) points on the curve.
   */ cacheSteps(mindist) {
        const steps = [];
        let laststep = this.pos(0);
        steps.push(0);
        for(let t = 0; t < this.duration; t += 10){
            const step = this.pos(t);
            const dist = Math.sqrt((step.x - laststep.x) * (step.x - laststep.x) + (step.y - laststep.y) * (step.y - laststep.y) + (step.z - laststep.z) * (step.z - laststep.z));
            if (dist > mindist) {
                steps.push(t);
                laststep = step;
            }
        }
        return steps;
    }
    /**
   * returns angle and speed in the given point in the curve
   */ vector(t) {
        const p1 = this.pos(t + 10);
        const p2 = this.pos(t - 10);
        return {
            angle: 180 * Math.atan2(p1.y - p2.y, p1.x - p2.x) / 3.14,
            speed: Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y) + (p2.z - p1.z) * (p2.z - p1.z))
        };
    }
    /**
   * Gets the position of the point, given time.
   *
   * WARNING: The speed is not constant. The time it takes between control points is constant.
   *
   * For constant speed, use Spline.steps[i];
   */ pos(time) {
        let t = time - this.delay;
        if (t < 0) {
            t = 0;
        }
        if (t > this.duration) {
            t = this.duration - 1;
        }
        const t2 = t / this.duration;
        if (t2 >= 1) {
            return this.points[this.length - 1];
        }
        const n = Math.floor((this.points.length - 1) * t2);
        const t1 = (this.length - 1) * t2 - n;
        return bezier(t1, this.points[n], this.controls[n][1], this.controls[n + 1][0], this.points[n + 1]);
    }
};
function bezier(t, p1, c1, c2, p2) {
    const b = B(t);
    const pos = {
        x: p2.x * b[0] + c2.x * b[1] + c1.x * b[2] + p1.x * b[3],
        y: p2.y * b[0] + c2.y * b[1] + c1.y * b[2] + p1.y * b[3],
        z: p2.z * b[0] + c2.z * b[1] + c1.z * b[2] + p1.z * b[3]
    };
    return pos;
}
function B(t) {
    const t2 = t * t;
    const t3 = t2 * t;
    return [
        t3,
        3 * t2 * (1 - t),
        3 * t * (1 - t) * (1 - t),
        (1 - t) * (1 - t) * (1 - t)
    ];
}
// index.ts
function bezierSpline(line, options = {}) {
    const resolution = options.resolution || 1e4;
    const sharpness = options.sharpness || 0.85;
    const coords = [];
    const points = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getGeom"])(line).coordinates.map((pt)=>{
        return {
            x: pt[0],
            y: pt[1]
        };
    });
    const spline = new Spline({
        duration: resolution,
        points,
        sharpness
    });
    const pushCoord = (time)=>{
        var pos = spline.pos(time);
        if (Math.floor(time / 100) % 2 === 0) {
            coords.push([
                pos.x,
                pos.y
            ]);
        }
    };
    for(var i = 0; i < spline.duration; i += 10){
        pushCoord(i);
    }
    pushCoord(spline.duration);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineString"])(coords, options.properties);
}
var turf_bezier_spline_default = bezierSpline;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/boolean-clockwise/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "booleanClockwise": (()=>booleanClockwise),
    "default": (()=>turf_boolean_clockwise_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
;
function booleanClockwise(line) {
    const ring = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(line);
    let sum = 0;
    let i = 1;
    let prev;
    let cur;
    while(i < ring.length){
        prev = cur || ring[0];
        cur = ring[i];
        sum += (cur[0] - prev[0]) * (cur[1] + prev[1]);
        i++;
    }
    return sum > 0;
}
var turf_boolean_clockwise_default = booleanClockwise;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/boolean-concave/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "booleanConcave": (()=>booleanConcave),
    "default": (()=>turf_boolean_concave_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
;
function booleanConcave(polygon) {
    const coords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getGeom"])(polygon).coordinates;
    if (coords[0].length <= 4) {
        return false;
    }
    let sign = false;
    const n = coords[0].length - 1;
    for(let i = 0; i < n; i++){
        const dx1 = coords[0][(i + 2) % n][0] - coords[0][(i + 1) % n][0];
        const dy1 = coords[0][(i + 2) % n][1] - coords[0][(i + 1) % n][1];
        const dx2 = coords[0][i][0] - coords[0][(i + 1) % n][0];
        const dy2 = coords[0][i][1] - coords[0][(i + 1) % n][1];
        const zcrossproduct = dx1 * dy2 - dy1 * dx2;
        if (i === 0) {
            sign = zcrossproduct > 0;
        } else if (sign !== zcrossproduct > 0) {
            return true;
        }
    }
    return false;
}
var turf_boolean_concave_default = booleanConcave;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/boolean-point-on-line/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "booleanPointOnLine": (()=>booleanPointOnLine),
    "default": (()=>turf_boolean_point_on_line_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
;
function booleanPointOnLine(pt, line, options = {}) {
    const ptCoords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(pt);
    const lineCoords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(line);
    for(let i = 0; i < lineCoords.length - 1; i++){
        let ignoreBoundary = false;
        if (options.ignoreEndVertices) {
            if (i === 0) {
                ignoreBoundary = "start";
            }
            if (i === lineCoords.length - 2) {
                ignoreBoundary = "end";
            }
            if (i === 0 && i + 1 === lineCoords.length - 1) {
                ignoreBoundary = "both";
            }
        }
        if (isPointOnLineSegment(lineCoords[i], lineCoords[i + 1], ptCoords, ignoreBoundary, typeof options.epsilon === "undefined" ? null : options.epsilon)) {
            return true;
        }
    }
    return false;
}
function isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary, epsilon) {
    const x = pt[0];
    const y = pt[1];
    const x1 = lineSegmentStart[0];
    const y1 = lineSegmentStart[1];
    const x2 = lineSegmentEnd[0];
    const y2 = lineSegmentEnd[1];
    const dxc = pt[0] - x1;
    const dyc = pt[1] - y1;
    const dxl = x2 - x1;
    const dyl = y2 - y1;
    const cross = dxc * dyl - dyc * dxl;
    if (epsilon !== null) {
        if (Math.abs(cross) > epsilon) {
            return false;
        }
    } else if (cross !== 0) {
        return false;
    }
    if (Math.abs(dxl) === Math.abs(dyl) && Math.abs(dxl) === 0) {
        if (excludeBoundary) {
            return false;
        }
        if (pt[0] === lineSegmentStart[0] && pt[1] === lineSegmentStart[1]) {
            return true;
        } else {
            return false;
        }
    }
    if (!excludeBoundary) {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1;
        }
        return dyl > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1;
    } else if (excludeBoundary === "start") {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1;
        }
        return dyl > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1;
    } else if (excludeBoundary === "end") {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1;
        }
        return dyl > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1;
    } else if (excludeBoundary === "both") {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? x1 < x && x < x2 : x2 < x && x < x1;
        }
        return dyl > 0 ? y1 < y && y < y2 : y2 < y && y < y1;
    }
    return false;
}
var turf_boolean_point_on_line_default = booleanPointOnLine;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "booleanPointInPolygon": (()=>booleanPointInPolygon),
    "default": (()=>turf_boolean_point_in_polygon_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$point$2d$in$2d$polygon$2d$hao$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/point-in-polygon-hao/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
function booleanPointInPolygon(point, polygon, options = {}) {
    if (!point) {
        throw new Error("point is required");
    }
    if (!polygon) {
        throw new Error("polygon is required");
    }
    const pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(point);
    const geom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getGeom"])(polygon);
    const type = geom.type;
    const bbox = polygon.bbox;
    let polys = geom.coordinates;
    if (bbox && inBBox(pt, bbox) === false) {
        return false;
    }
    if (type === "Polygon") {
        polys = [
            polys
        ];
    }
    let result = false;
    for(var i = 0; i < polys.length; ++i){
        const polyResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$point$2d$in$2d$polygon$2d$hao$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(pt, polys[i]);
        if (polyResult === 0) return options.ignoreBoundary ? false : true;
        else if (polyResult) result = true;
    }
    return result;
}
function inBBox(pt, bbox) {
    return bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1];
}
var turf_boolean_point_in_polygon_default = booleanPointInPolygon;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/boolean-contains/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "booleanContains": (()=>booleanContains),
    "compareCoords": (()=>compareCoords),
    "default": (()=>turf_boolean_contains_default),
    "doBBoxOverlap": (()=>doBBoxOverlap),
    "getMidpoint": (()=>getMidpoint),
    "isLineInPoly": (()=>isLineInPoly),
    "isLineOnLine": (()=>isLineOnLine),
    "isMultiPointInMultiPoint": (()=>isMultiPointInMultiPoint),
    "isMultiPointInPoly": (()=>isMultiPointInPoly),
    "isMultiPointOnLine": (()=>isMultiPointOnLine),
    "isPointInMultiPoint": (()=>isPointInMultiPoint),
    "isPolyInPoly": (()=>isPolyInPoly),
    "isPolygonInMultiPolygon": (()=>isPolygonInMultiPolygon)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-on-line/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
function booleanContains(feature1, feature2) {
    const geom1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getGeom"])(feature1);
    const geom2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getGeom"])(feature2);
    const type1 = geom1.type;
    const type2 = geom2.type;
    const coords1 = geom1.coordinates;
    const coords2 = geom2.coordinates;
    switch(type1){
        case "Point":
            switch(type2){
                case "Point":
                    return compareCoords(coords1, coords2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "MultiPoint":
            switch(type2){
                case "Point":
                    return isPointInMultiPoint(geom1, geom2);
                case "MultiPoint":
                    return isMultiPointInMultiPoint(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "LineString":
            switch(type2){
                case "Point":
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(geom2, geom1, {
                        ignoreEndVertices: true
                    });
                case "LineString":
                    return isLineOnLine(geom1, geom2);
                case "MultiPoint":
                    return isMultiPointOnLine(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "Polygon":
            switch(type2){
                case "Point":
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(geom2, geom1, {
                        ignoreBoundary: true
                    });
                case "LineString":
                    return isLineInPoly(geom1, geom2);
                case "Polygon":
                    return isPolyInPoly(geom1, geom2);
                case "MultiPoint":
                    return isMultiPointInPoly(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "MultiPolygon":
            switch(type2){
                case "Polygon":
                    return isPolygonInMultiPolygon(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        default:
            throw new Error("feature1 " + type1 + " geometry not supported");
    }
}
function isPolygonInMultiPolygon(multiPolygon, polygon) {
    return multiPolygon.coordinates.some((coords)=>isPolyInPoly({
            type: "Polygon",
            coordinates: coords
        }, polygon));
}
function isPointInMultiPoint(multiPoint, pt) {
    let i;
    let output = false;
    for(i = 0; i < multiPoint.coordinates.length; i++){
        if (compareCoords(multiPoint.coordinates[i], pt.coordinates)) {
            output = true;
            break;
        }
    }
    return output;
}
function isMultiPointInMultiPoint(multiPoint1, multiPoint2) {
    for (const coord2 of multiPoint2.coordinates){
        let matchFound = false;
        for (const coord1 of multiPoint1.coordinates){
            if (compareCoords(coord2, coord1)) {
                matchFound = true;
                break;
            }
        }
        if (!matchFound) {
            return false;
        }
    }
    return true;
}
function isMultiPointOnLine(lineString, multiPoint) {
    let haveFoundInteriorPoint = false;
    for (const coord of multiPoint.coordinates){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(coord, lineString, {
            ignoreEndVertices: true
        })) {
            haveFoundInteriorPoint = true;
        }
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(coord, lineString)) {
            return false;
        }
    }
    if (haveFoundInteriorPoint) {
        return true;
    }
    return false;
}
function isMultiPointInPoly(polygon, multiPoint) {
    for (const coord of multiPoint.coordinates){
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(coord, polygon, {
            ignoreBoundary: true
        })) {
            return false;
        }
    }
    return true;
}
function isLineOnLine(lineString1, lineString2) {
    let haveFoundInteriorPoint = false;
    for (const coords of lineString2.coordinates){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
            type: "Point",
            coordinates: coords
        }, lineString1, {
            ignoreEndVertices: true
        })) {
            haveFoundInteriorPoint = true;
        }
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
            type: "Point",
            coordinates: coords
        }, lineString1, {
            ignoreEndVertices: false
        })) {
            return false;
        }
    }
    return haveFoundInteriorPoint;
}
function isLineInPoly(polygon, linestring) {
    let output = false;
    let i = 0;
    const polyBbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bbox"])(polygon);
    const lineBbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bbox"])(linestring);
    if (!doBBoxOverlap(polyBbox, lineBbox)) {
        return false;
    }
    for(i; i < linestring.coordinates.length - 1; i++){
        const midPoint = getMidpoint(linestring.coordinates[i], linestring.coordinates[i + 1]);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
            type: "Point",
            coordinates: midPoint
        }, polygon, {
            ignoreBoundary: true
        })) {
            output = true;
            break;
        }
    }
    return output;
}
function isPolyInPoly(feature1, feature2) {
    if (feature1.type === "Feature" && feature1.geometry === null) {
        return false;
    }
    if (feature2.type === "Feature" && feature2.geometry === null) {
        return false;
    }
    const poly1Bbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bbox"])(feature1);
    const poly2Bbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bbox"])(feature2);
    if (!doBBoxOverlap(poly1Bbox, poly2Bbox)) {
        return false;
    }
    const coords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getGeom"])(feature2).coordinates;
    for (const ring of coords){
        for (const coord of ring){
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(coord, feature1)) {
                return false;
            }
        }
    }
    return true;
}
function doBBoxOverlap(bbox1, bbox2) {
    if (bbox1[0] > bbox2[0]) {
        return false;
    }
    if (bbox1[2] < bbox2[2]) {
        return false;
    }
    if (bbox1[1] > bbox2[1]) {
        return false;
    }
    if (bbox1[3] < bbox2[3]) {
        return false;
    }
    return true;
}
function compareCoords(pair1, pair2) {
    return pair1[0] === pair2[0] && pair1[1] === pair2[1];
}
function getMidpoint(pair1, pair2) {
    return [
        (pair1[0] + pair2[0]) / 2,
        (pair1[1] + pair2[1]) / 2
    ];
}
var turf_boolean_contains_default = booleanContains;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/line-intersect/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_line_intersect_default),
    "lineIntersect": (()=>lineIntersect)
});
// lib/sweepline-intersections-export.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sweepline$2d$intersections$2f$dist$2f$sweeplineIntersections$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/sweepline-intersections/dist/sweeplineIntersections.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
var sweeplineIntersections = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sweepline$2d$intersections$2f$dist$2f$sweeplineIntersections$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"];
// index.ts
function lineIntersect(line1, line2, options = {}) {
    const { removeDuplicates = true, ignoreSelfIntersections = true } = options;
    let features = [];
    if (line1.type === "FeatureCollection") features = features.concat(line1.features);
    else if (line1.type === "Feature") features.push(line1);
    else if (line1.type === "LineString" || line1.type === "Polygon" || line1.type === "MultiLineString" || line1.type === "MultiPolygon") {
        features.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["feature"])(line1));
    }
    if (line2.type === "FeatureCollection") features = features.concat(line2.features);
    else if (line2.type === "Feature") features.push(line2);
    else if (line2.type === "LineString" || line2.type === "Polygon" || line2.type === "MultiLineString" || line2.type === "MultiPolygon") {
        features.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["feature"])(line2));
    }
    const intersections = sweeplineIntersections((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(features), ignoreSelfIntersections);
    let results = [];
    if (removeDuplicates) {
        const unique = {};
        intersections.forEach((intersection)=>{
            const key = intersection.join(",");
            if (!unique[key]) {
                unique[key] = true;
                results.push(intersection);
            }
        });
    } else {
        results = intersections;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(results.map((r)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])(r)));
}
var turf_line_intersect_default = lineIntersect;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/polygon-to-line/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "coordsToLine": (()=>coordsToLine),
    "default": (()=>turf_polygon_to_line_default),
    "multiPolygonToLine": (()=>multiPolygonToLine),
    "polygonToLine": (()=>polygonToLine),
    "singlePolygonToLine": (()=>singlePolygonToLine)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
function polygonToLine(poly, options = {}) {
    const geom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getGeom"])(poly);
    if (!options.properties && poly.type === "Feature") {
        options.properties = poly.properties;
    }
    switch(geom.type){
        case "Polygon":
            return singlePolygonToLine(geom, options);
        case "MultiPolygon":
            return multiPolygonToLine(geom, options);
        default:
            throw new Error("invalid poly");
    }
}
function singlePolygonToLine(poly, options = {}) {
    const geom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getGeom"])(poly);
    const coords = geom.coordinates;
    const properties = options.properties ? options.properties : poly.type === "Feature" ? poly.properties : {};
    return coordsToLine(coords, properties);
}
function multiPolygonToLine(multiPoly, options = {}) {
    const geom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getGeom"])(multiPoly);
    const coords = geom.coordinates;
    const properties = options.properties ? options.properties : multiPoly.type === "Feature" ? multiPoly.properties : {};
    const lines = [];
    coords.forEach((coord)=>{
        lines.push(coordsToLine(coord, properties));
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(lines);
}
function coordsToLine(coords, properties) {
    if (coords.length > 1) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["multiLineString"])(coords, properties);
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineString"])(coords[0], properties);
}
var turf_polygon_to_line_default = polygonToLine;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/boolean-crosses/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "booleanCrosses": (()=>booleanCrosses),
    "default": (()=>turf_boolean_crosses_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-intersect/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygon$2d$to$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/polygon-to-line/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
;
function booleanCrosses(feature1, feature2) {
    var geom1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getGeom"])(feature1);
    var geom2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getGeom"])(feature2);
    var type1 = geom1.type;
    var type2 = geom2.type;
    switch(type1){
        case "MultiPoint":
            switch(type2){
                case "LineString":
                    return doMultiPointAndLineStringCross(geom1, geom2);
                case "Polygon":
                    return doesMultiPointCrossPoly(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "LineString":
            switch(type2){
                case "MultiPoint":
                    return doMultiPointAndLineStringCross(geom2, geom1);
                case "LineString":
                    return doLineStringsCross(geom1, geom2);
                case "Polygon":
                    return doLineStringAndPolygonCross(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "Polygon":
            switch(type2){
                case "MultiPoint":
                    return doesMultiPointCrossPoly(geom2, geom1);
                case "LineString":
                    return doLineStringAndPolygonCross(geom2, geom1);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        default:
            throw new Error("feature1 " + type1 + " geometry not supported");
    }
}
function doMultiPointAndLineStringCross(multiPoint, lineString) {
    var foundIntPoint = false;
    var foundExtPoint = false;
    var pointLength = multiPoint.coordinates.length;
    var i = 0;
    while(i < pointLength && !foundIntPoint && !foundExtPoint){
        for(var i2 = 0; i2 < lineString.coordinates.length - 1; i2++){
            var incEndVertices = true;
            if (i2 === 0 || i2 === lineString.coordinates.length - 2) {
                incEndVertices = false;
            }
            if (isPointOnLineSegment(lineString.coordinates[i2], lineString.coordinates[i2 + 1], multiPoint.coordinates[i], incEndVertices)) {
                foundIntPoint = true;
            } else {
                foundExtPoint = true;
            }
        }
        i++;
    }
    return foundIntPoint && foundExtPoint;
}
function doLineStringsCross(lineString1, lineString2) {
    var doLinesIntersect = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineIntersect"])(lineString1, lineString2);
    if (doLinesIntersect.features.length > 0) {
        for(var i = 0; i < lineString1.coordinates.length - 1; i++){
            for(var i2 = 0; i2 < lineString2.coordinates.length - 1; i2++){
                var incEndVertices = true;
                if (i2 === 0 || i2 === lineString2.coordinates.length - 2) {
                    incEndVertices = false;
                }
                if (isPointOnLineSegment(lineString1.coordinates[i], lineString1.coordinates[i + 1], lineString2.coordinates[i2], incEndVertices)) {
                    return true;
                }
            }
        }
    }
    return false;
}
function doLineStringAndPolygonCross(lineString, polygon) {
    const line = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygon$2d$to$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygonToLine"])(polygon);
    const doLinesIntersect = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineIntersect"])(lineString, line);
    if (doLinesIntersect.features.length > 0) {
        return true;
    }
    return false;
}
function doesMultiPointCrossPoly(multiPoint, polygon) {
    var foundIntPoint = false;
    var foundExtPoint = false;
    var pointLength = multiPoint.coordinates.length;
    for(let i = 0; i < pointLength && (!foundIntPoint || !foundExtPoint); i++){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])(multiPoint.coordinates[i]), polygon)) {
            foundIntPoint = true;
        } else {
            foundExtPoint = true;
        }
    }
    return foundExtPoint && foundIntPoint;
}
function isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, incEnd) {
    var dxc = pt[0] - lineSegmentStart[0];
    var dyc = pt[1] - lineSegmentStart[1];
    var dxl = lineSegmentEnd[0] - lineSegmentStart[0];
    var dyl = lineSegmentEnd[1] - lineSegmentStart[1];
    var cross = dxc * dyl - dyc * dxl;
    if (cross !== 0) {
        return false;
    }
    if (incEnd) {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0] : lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];
        }
        return dyl > 0 ? lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1] : lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];
    } else {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? lineSegmentStart[0] < pt[0] && pt[0] < lineSegmentEnd[0] : lineSegmentEnd[0] < pt[0] && pt[0] < lineSegmentStart[0];
        }
        return dyl > 0 ? lineSegmentStart[1] < pt[1] && pt[1] < lineSegmentEnd[1] : lineSegmentEnd[1] < pt[1] && pt[1] < lineSegmentStart[1];
    }
}
var turf_boolean_crosses_default = booleanCrosses;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/boolean-disjoint/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "booleanDisjoint": (()=>booleanDisjoint),
    "default": (()=>turf_boolean_disjoint_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-intersect/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygon$2d$to$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/polygon-to-line/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
function booleanDisjoint(feature1, feature2, { ignoreSelfIntersections = true } = {
    ignoreSelfIntersections: true
}) {
    let bool = true;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flattenEach"])(feature1, (flatten1)=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flattenEach"])(feature2, (flatten2)=>{
            if (bool === false) {
                return false;
            }
            bool = disjoint(flatten1.geometry, flatten2.geometry, ignoreSelfIntersections);
        });
    });
    return bool;
}
function disjoint(geom1, geom2, ignoreSelfIntersections) {
    switch(geom1.type){
        case "Point":
            switch(geom2.type){
                case "Point":
                    return !compareCoords(geom1.coordinates, geom2.coordinates);
                case "LineString":
                    return !isPointOnLine(geom2, geom1);
                case "Polygon":
                    return !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(geom1, geom2);
            }
            break;
        case "LineString":
            switch(geom2.type){
                case "Point":
                    return !isPointOnLine(geom1, geom2);
                case "LineString":
                    return !isLineOnLine(geom1, geom2, ignoreSelfIntersections);
                case "Polygon":
                    return !isLineInPoly(geom2, geom1, ignoreSelfIntersections);
            }
            break;
        case "Polygon":
            switch(geom2.type){
                case "Point":
                    return !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(geom2, geom1);
                case "LineString":
                    return !isLineInPoly(geom1, geom2, ignoreSelfIntersections);
                case "Polygon":
                    return !isPolyInPoly(geom2, geom1, ignoreSelfIntersections);
            }
    }
    return false;
}
function isPointOnLine(lineString, pt) {
    for(let i = 0; i < lineString.coordinates.length - 1; i++){
        if (isPointOnLineSegment(lineString.coordinates[i], lineString.coordinates[i + 1], pt.coordinates)) {
            return true;
        }
    }
    return false;
}
function isLineOnLine(lineString1, lineString2, ignoreSelfIntersections) {
    const doLinesIntersect = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineIntersect"])(lineString1, lineString2, {
        ignoreSelfIntersections
    });
    if (doLinesIntersect.features.length > 0) {
        return true;
    }
    return false;
}
function isLineInPoly(polygon, lineString, ignoreSelfIntersections) {
    for (const coord of lineString.coordinates){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(coord, polygon)) {
            return true;
        }
    }
    const doLinesIntersect = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineIntersect"])(lineString, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygon$2d$to$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygonToLine"])(polygon), {
        ignoreSelfIntersections
    });
    if (doLinesIntersect.features.length > 0) {
        return true;
    }
    return false;
}
function isPolyInPoly(feature1, feature2, ignoreSelfIntersections) {
    for (const coord1 of feature1.coordinates[0]){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(coord1, feature2)) {
            return true;
        }
    }
    for (const coord2 of feature2.coordinates[0]){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(coord2, feature1)) {
            return true;
        }
    }
    const doLinesIntersect = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineIntersect"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygon$2d$to$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygonToLine"])(feature1), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygon$2d$to$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygonToLine"])(feature2), {
        ignoreSelfIntersections
    });
    if (doLinesIntersect.features.length > 0) {
        return true;
    }
    return false;
}
function isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt) {
    const dxc = pt[0] - lineSegmentStart[0];
    const dyc = pt[1] - lineSegmentStart[1];
    const dxl = lineSegmentEnd[0] - lineSegmentStart[0];
    const dyl = lineSegmentEnd[1] - lineSegmentStart[1];
    const cross = dxc * dyl - dyc * dxl;
    if (cross !== 0) {
        return false;
    }
    if (Math.abs(dxl) >= Math.abs(dyl)) {
        if (dxl > 0) {
            return lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0];
        } else {
            return lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];
        }
    } else if (dyl > 0) {
        return lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1];
    } else {
        return lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];
    }
}
function compareCoords(pair1, pair2) {
    return pair1[0] === pair2[0] && pair1[1] === pair2[1];
}
var turf_boolean_disjoint_default = booleanDisjoint;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/clean-coords/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "cleanCoords": (()=>cleanCoords),
    "default": (()=>turf_clean_coords_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
function cleanCoords(geojson, options = {}) {
    var mutate = typeof options === "object" ? options.mutate : options;
    if (!geojson) throw new Error("geojson is required");
    var type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getType"])(geojson);
    var newCoords = [];
    switch(type){
        case "LineString":
            newCoords = cleanLine(geojson, type);
            break;
        case "MultiLineString":
        case "Polygon":
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(geojson).forEach(function(line) {
                newCoords.push(cleanLine(line, type));
            });
            break;
        case "MultiPolygon":
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(geojson).forEach(function(polygons) {
                var polyPoints = [];
                polygons.forEach(function(ring) {
                    polyPoints.push(cleanLine(ring, type));
                });
                newCoords.push(polyPoints);
            });
            break;
        case "Point":
            return geojson;
        case "MultiPoint":
            var existing = {};
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(geojson).forEach(function(coord) {
                var key = coord.join("-");
                if (!Object.prototype.hasOwnProperty.call(existing, key)) {
                    newCoords.push(coord);
                    existing[key] = true;
                }
            });
            break;
        default:
            throw new Error(type + " geometry not supported");
    }
    if (geojson.coordinates) {
        if (mutate === true) {
            geojson.coordinates = newCoords;
            return geojson;
        }
        return {
            type,
            coordinates: newCoords
        };
    } else {
        if (mutate === true) {
            geojson.geometry.coordinates = newCoords;
            return geojson;
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["feature"])({
            type,
            coordinates: newCoords
        }, geojson.properties, {
            bbox: geojson.bbox,
            id: geojson.id
        });
    }
}
function cleanLine(line, type) {
    var points = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(line);
    if (points.length === 2 && !equals(points[0], points[1])) return points;
    var newPoints = [];
    var secondToLast = points.length - 1;
    var newPointsLength = newPoints.length;
    newPoints.push(points[0]);
    for(var i = 1; i < secondToLast; i++){
        var prevAddedPoint = newPoints[newPoints.length - 1];
        if (points[i][0] === prevAddedPoint[0] && points[i][1] === prevAddedPoint[1]) continue;
        else {
            newPoints.push(points[i]);
            newPointsLength = newPoints.length;
            if (newPointsLength > 2) {
                if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2])) newPoints.splice(newPoints.length - 2, 1);
            }
        }
    }
    newPoints.push(points[points.length - 1]);
    newPointsLength = newPoints.length;
    if ((type === "Polygon" || type === "MultiPolygon") && equals(points[0], points[points.length - 1]) && newPointsLength < 4) {
        throw new Error("invalid polygon");
    }
    if (type === "LineString" && newPointsLength < 3) {
        return newPoints;
    }
    if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2])) newPoints.splice(newPoints.length - 2, 1);
    return newPoints;
}
function equals(pt1, pt2) {
    return pt1[0] === pt2[0] && pt1[1] === pt2[1];
}
function isPointOnLineSegment(start, end, point) {
    var x = point[0], y = point[1];
    var startX = start[0], startY = start[1];
    var endX = end[0], endY = end[1];
    var dxc = x - startX;
    var dyc = y - startY;
    var dxl = endX - startX;
    var dyl = endY - startY;
    var cross = dxc * dyl - dyc * dxl;
    if (cross !== 0) return false;
    else if (Math.abs(dxl) >= Math.abs(dyl)) return dxl > 0 ? startX <= x && x <= endX : endX <= x && x <= startX;
    else return dyl > 0 ? startY <= y && y <= endY : endY <= y && y <= startY;
}
var turf_clean_coords_default = cleanCoords;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/boolean-equal/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "booleanEqual": (()=>booleanEqual),
    "default": (()=>turf_boolean_equal_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$geojson$2d$equality$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/geojson-equality-ts/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clean$2d$coords$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clean-coords/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
function booleanEqual(feature1, feature2, options = {}) {
    let precision = options.precision;
    precision = precision === void 0 || precision === null || isNaN(precision) ? 6 : precision;
    if (typeof precision !== "number" || !(precision >= 0)) {
        throw new Error("precision must be a positive number");
    }
    const type1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getGeom"])(feature1).type;
    const type2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getGeom"])(feature2).type;
    if (type1 !== type2) return false;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$geojson$2d$equality$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["geojsonEquality"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clean$2d$coords$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cleanCoords"])(feature1), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clean$2d$coords$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cleanCoords"])(feature2), {
        precision
    });
}
var turf_boolean_equal_default = booleanEqual;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/boolean-intersects/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "booleanIntersects": (()=>booleanIntersects),
    "default": (()=>turf_boolean_intersects_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$disjoint$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-disjoint/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
function booleanIntersects(feature1, feature2, { ignoreSelfIntersections = true } = {}) {
    let bool = false;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flattenEach"])(feature1, (flatten1)=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flattenEach"])(feature2, (flatten2)=>{
            if (bool === true) {
                return true;
            }
            bool = !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$disjoint$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanDisjoint"])(flatten1.geometry, flatten2.geometry, {
                ignoreSelfIntersections
            });
        });
    });
    return bool;
}
var turf_boolean_intersects_default = booleanIntersects;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/geojson-rbush/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.js
__turbopack_esm__({
    "default": (()=>turf_geojson_rbush_default),
    "geojsonRbush": (()=>geojsonRbush)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rbush/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
function geojsonRbush(maxEntries) {
    var tree = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](maxEntries);
    tree.insert = function(feature) {
        if (feature.type !== "Feature") throw new Error("invalid feature");
        feature.bbox = feature.bbox ? feature.bbox : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bbox"])(feature);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].prototype.insert.call(this, feature);
    };
    tree.load = function(features) {
        var load = [];
        if (Array.isArray(features)) {
            features.forEach(function(feature) {
                if (feature.type !== "Feature") throw new Error("invalid features");
                feature.bbox = feature.bbox ? feature.bbox : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bbox"])(feature);
                load.push(feature);
            });
        } else {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"])(features, function(feature) {
                if (feature.type !== "Feature") throw new Error("invalid features");
                feature.bbox = feature.bbox ? feature.bbox : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bbox"])(feature);
                load.push(feature);
            });
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].prototype.load.call(this, load);
    };
    tree.remove = function(feature, equals) {
        if (feature.type !== "Feature") throw new Error("invalid feature");
        feature.bbox = feature.bbox ? feature.bbox : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bbox"])(feature);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].prototype.remove.call(this, feature, equals);
    };
    tree.clear = function() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].prototype.clear.call(this);
    };
    tree.search = function(geojson) {
        var features = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].prototype.search.call(this, this.toBBox(geojson));
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(features);
    };
    tree.collides = function(geojson) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].prototype.collides.call(this, this.toBBox(geojson));
    };
    tree.all = function() {
        var features = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].prototype.all.call(this);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(features);
    };
    tree.toJSON = function() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].prototype.toJSON.call(this);
    };
    tree.fromJSON = function(json) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].prototype.fromJSON.call(this, json);
    };
    tree.toBBox = function(geojson) {
        var bbox;
        if (geojson.bbox) bbox = geojson.bbox;
        else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;
        else if (Array.isArray(geojson) && geojson.length === 6) bbox = [
            geojson[0],
            geojson[1],
            geojson[3],
            geojson[4]
        ];
        else if (geojson.type === "Feature") bbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bbox"])(geojson);
        else if (geojson.type === "FeatureCollection") bbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bbox"])(geojson);
        else throw new Error("invalid geojson");
        return {
            minX: bbox[0],
            minY: bbox[1],
            maxX: bbox[2],
            maxY: bbox[3]
        };
    };
    return tree;
}
var turf_geojson_rbush_default = geojsonRbush;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/line-segment/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_line_segment_default),
    "lineSegment": (()=>lineSegment)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
function lineSegment(geojson) {
    if (!geojson) {
        throw new Error("geojson is required");
    }
    const results = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flattenEach"])(geojson, (feature)=>{
        lineSegmentFeature(feature, results);
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(results);
}
function lineSegmentFeature(geojson, results) {
    let coords = [];
    const geometry = geojson.geometry;
    if (geometry !== null) {
        switch(geometry.type){
            case "Polygon":
                coords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(geometry);
                break;
            case "LineString":
                coords = [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(geometry)
                ];
        }
        coords.forEach((coord)=>{
            const segments = createSegments(coord, geojson.properties);
            segments.forEach((segment)=>{
                segment.id = results.length;
                results.push(segment);
            });
        });
    }
}
function createSegments(coords, properties) {
    const segments = [];
    coords.reduce((previousCoords, currentCoords)=>{
        const segment = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineString"])([
            previousCoords,
            currentCoords
        ], properties);
        segment.bbox = bbox(previousCoords, currentCoords);
        segments.push(segment);
        return currentCoords;
    });
    return segments;
}
function bbox(coords1, coords2) {
    const x1 = coords1[0];
    const y1 = coords1[1];
    const x2 = coords2[0];
    const y2 = coords2[1];
    const west = x1 < x2 ? x1 : x2;
    const south = y1 < y2 ? y1 : y2;
    const east = x1 > x2 ? x1 : x2;
    const north = y1 > y2 ? y1 : y2;
    return [
        west,
        south,
        east,
        north
    ];
}
var turf_line_segment_default = lineSegment;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/nearest-point-on-line/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>turf_nearest_point_on_line_default),
    "nearestPointOnLine": (()=>nearestPointOnLine)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
// index.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-ssr] (ecmascript)");
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));
;
;
;
;
function nearestPointOnLine(lines, pt, options = {}) {
    if (!lines || !pt) {
        throw new Error("lines and pt are required arguments");
    }
    const ptPos = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(pt);
    let closestPt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])([
        Infinity,
        Infinity
    ], {
        dist: Infinity,
        index: -1,
        multiFeatureIndex: -1,
        location: -1
    });
    let length = 0;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flattenEach"])(lines, function(line, _featureIndex, multiFeatureIndex) {
        const coords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(line);
        for(let i = 0; i < coords.length - 1; i++){
            const start = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])(coords[i]);
            start.properties.dist = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distance"])(pt, start, options);
            const startPos = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(start);
            const stop = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])(coords[i + 1]);
            stop.properties.dist = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distance"])(pt, stop, options);
            const stopPos = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(stop);
            const sectionLength = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distance"])(start, stop, options);
            let intersectPos;
            let wasEnd;
            if (startPos[0] === ptPos[0] && startPos[1] === ptPos[1]) {
                [intersectPos, , wasEnd] = [
                    startPos,
                    void 0,
                    false
                ];
            } else if (stopPos[0] === ptPos[0] && stopPos[1] === ptPos[1]) {
                [intersectPos, , wasEnd] = [
                    stopPos,
                    void 0,
                    true
                ];
            } else {
                [intersectPos, , wasEnd] = nearestPointOnSegment(start.geometry.coordinates, stop.geometry.coordinates, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(pt));
            }
            let intersectPt;
            if (intersectPos) {
                intersectPt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])(intersectPos, {
                    dist: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distance"])(pt, intersectPos, options),
                    multiFeatureIndex,
                    location: length + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distance"])(start, intersectPos, options)
                });
            }
            if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {
                closestPt = __spreadProps(__spreadValues({}, intersectPt), {
                    properties: __spreadProps(__spreadValues({}, intersectPt.properties), {
                        // Legacy behaviour where index progresses to next segment # if we
                        // went with the end point this iteration.
                        index: wasEnd ? i + 1 : i
                    })
                });
            }
            length += sectionLength;
        }
    });
    return closestPt;
}
function dot(v1, v2) {
    const [v1x, v1y, v1z] = v1;
    const [v2x, v2y, v2z] = v2;
    return v1x * v2x + v1y * v2y + v1z * v2z;
}
function cross(v1, v2) {
    const [v1x, v1y, v1z] = v1;
    const [v2x, v2y, v2z] = v2;
    return [
        v1y * v2z - v1z * v2y,
        v1z * v2x - v1x * v2z,
        v1x * v2y - v1y * v2x
    ];
}
function magnitude(v) {
    return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2) + Math.pow(v[2], 2));
}
function angle(v1, v2) {
    const theta = dot(v1, v2) / (magnitude(v1) * magnitude(v2));
    return Math.acos(Math.min(Math.max(theta, -1), 1));
}
function lngLatToVector(a) {
    const lat = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["degreesToRadians"])(a[1]);
    const lng = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["degreesToRadians"])(a[0]);
    return [
        Math.cos(lat) * Math.cos(lng),
        Math.cos(lat) * Math.sin(lng),
        Math.sin(lat)
    ];
}
function vectorToLngLat(v) {
    const [x, y, z] = v;
    const lat = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["radiansToDegrees"])(Math.asin(z));
    const lng = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["radiansToDegrees"])(Math.atan2(y, x));
    return [
        lng,
        lat
    ];
}
function nearestPointOnSegment(posA, posB, posC) {
    const A = lngLatToVector(posA);
    const B = lngLatToVector(posB);
    const C = lngLatToVector(posC);
    const [Cx, Cy, Cz] = C;
    const [D, E, F] = cross(A, B);
    const a = E * Cz - F * Cy;
    const b = F * Cx - D * Cz;
    const c = D * Cy - E * Cx;
    const f = c * E - b * F;
    const g = a * F - c * D;
    const h = b * D - a * E;
    const t = 1 / Math.sqrt(Math.pow(f, 2) + Math.pow(g, 2) + Math.pow(h, 2));
    const I1 = [
        f * t,
        g * t,
        h * t
    ];
    const I2 = [
        -1 * f * t,
        -1 * g * t,
        -1 * h * t
    ];
    const angleAB = angle(A, B);
    const angleAI1 = angle(A, I1);
    const angleBI1 = angle(B, I1);
    const angleAI2 = angle(A, I2);
    const angleBI2 = angle(B, I2);
    let I;
    if (angleAI1 < angleAI2 && angleAI1 < angleBI2 || angleBI1 < angleAI2 && angleBI1 < angleBI2) {
        I = I1;
    } else {
        I = I2;
    }
    if (angle(A, I) > angleAB || angle(B, I) > angleAB) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distance"])(vectorToLngLat(I), vectorToLngLat(A)) <= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distance"])(vectorToLngLat(I), vectorToLngLat(B))) {
            return [
                vectorToLngLat(A),
                true,
                false
            ];
        } else {
            return [
                vectorToLngLat(B),
                false,
                true
            ];
        }
    }
    return [
        vectorToLngLat(I),
        false,
        false
    ];
}
var turf_nearest_point_on_line_default = nearestPointOnLine;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/line-overlap/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_line_overlap_default),
    "lineOverlap": (()=>lineOverlap)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$deep$2d$equal$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/fast-deep-equal/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$geojson$2d$rbush$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/geojson-rbush/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$segment$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-segment/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/nearest-point-on-line/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-on-line/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
function lineOverlap(line1, line2, options = {}) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    var tolerance = options.tolerance || 0;
    var features = [];
    var tree = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$geojson$2d$rbush$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["geojsonRbush"])();
    const line = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$segment$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineSegment"])(line1);
    tree.load(line);
    var overlapSegment;
    let additionalSegments = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["segmentEach"])(line2, function(segment) {
        var doesOverlaps = false;
        if (!segment) {
            return;
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"])(tree.search(segment), function(match) {
            if (doesOverlaps === false) {
                var coordsSegment = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(segment).sort();
                var coordsMatch = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(match).sort();
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$deep$2d$equal$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(coordsSegment, coordsMatch)) {
                    doesOverlaps = true;
                    if (overlapSegment) {
                        overlapSegment = concatSegment(overlapSegment, segment) || overlapSegment;
                    } else overlapSegment = segment;
                } else if (tolerance === 0 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(coordsSegment[0], match) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(coordsSegment[1], match) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearestPointOnLine"])(match, coordsSegment[0]).properties.dist <= tolerance && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearestPointOnLine"])(match, coordsSegment[1]).properties.dist <= tolerance) {
                    doesOverlaps = true;
                    if (overlapSegment) {
                        overlapSegment = concatSegment(overlapSegment, segment) || overlapSegment;
                    } else overlapSegment = segment;
                } else if (tolerance === 0 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(coordsMatch[0], segment) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(coordsMatch[1], segment) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearestPointOnLine"])(segment, coordsMatch[0]).properties.dist <= tolerance && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearestPointOnLine"])(segment, coordsMatch[1]).properties.dist <= tolerance) {
                    if (overlapSegment) {
                        const combinedSegment = concatSegment(overlapSegment, match);
                        if (combinedSegment) {
                            overlapSegment = combinedSegment;
                        } else {
                            additionalSegments.push(match);
                        }
                    } else overlapSegment = match;
                }
            }
        });
        if (doesOverlaps === false && overlapSegment) {
            features.push(overlapSegment);
            if (additionalSegments.length) {
                features = features.concat(additionalSegments);
                additionalSegments = [];
            }
            overlapSegment = void 0;
        }
    });
    if (overlapSegment) features.push(overlapSegment);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(features);
}
function concatSegment(line, segment) {
    var coords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(segment);
    var lineCoords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(line);
    var start = lineCoords[0];
    var end = lineCoords[lineCoords.length - 1];
    var geom = line.geometry.coordinates;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$deep$2d$equal$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(coords[0], start)) geom.unshift(coords[1]);
    else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$deep$2d$equal$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(coords[0], end)) geom.push(coords[1]);
    else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$deep$2d$equal$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(coords[1], start)) geom.unshift(coords[0]);
    else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$deep$2d$equal$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(coords[1], end)) geom.push(coords[0]);
    else return;
    return line;
}
var turf_line_overlap_default = lineOverlap;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/boolean-overlap/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "booleanOverlap": (()=>booleanOverlap),
    "default": (()=>turf_boolean_overlap_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$geojson$2d$equality$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/geojson-equality-ts/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$overlap$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-overlap/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-intersect/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
;
function booleanOverlap(feature1, feature2) {
    const geom1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getGeom"])(feature1);
    const geom2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getGeom"])(feature2);
    const type1 = geom1.type;
    const type2 = geom2.type;
    if (type1 === "MultiPoint" && type2 !== "MultiPoint" || (type1 === "LineString" || type1 === "MultiLineString") && type2 !== "LineString" && type2 !== "MultiLineString" || (type1 === "Polygon" || type1 === "MultiPolygon") && type2 !== "Polygon" && type2 !== "MultiPolygon") {
        throw new Error("features must be of the same type");
    }
    if (type1 === "Point") throw new Error("Point geometry not supported");
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$geojson$2d$equality$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["geojsonEquality"])(feature1, feature2, {
        precision: 6
    })) return false;
    let overlap = 0;
    switch(type1){
        case "MultiPoint":
            for(var i = 0; i < geom1.coordinates.length; i++){
                for(var j = 0; j < geom2.coordinates.length; j++){
                    var coord1 = geom1.coordinates[i];
                    var coord2 = geom2.coordinates[j];
                    if (coord1[0] === coord2[0] && coord1[1] === coord2[1]) {
                        return true;
                    }
                }
            }
            return false;
        case "LineString":
        case "MultiLineString":
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["segmentEach"])(feature1, (segment1)=>{
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["segmentEach"])(feature2, (segment2)=>{
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$overlap$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineOverlap"])(segment1, segment2).features.length) overlap++;
                });
            });
            break;
        case "Polygon":
        case "MultiPolygon":
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["segmentEach"])(feature1, (segment1)=>{
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["segmentEach"])(feature2, (segment2)=>{
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineIntersect"])(segment1, segment2).features.length) overlap++;
                });
            });
            break;
    }
    return overlap > 0;
}
var turf_boolean_overlap_default = booleanOverlap;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/boolean-parallel/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "booleanParallel": (()=>booleanParallel),
    "default": (()=>turf_boolean_parallel_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$segment$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-segment/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clean$2d$coords$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clean-coords/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rhumb-bearing/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
function booleanParallel(line1, line2) {
    if (!line1) throw new Error("line1 is required");
    if (!line2) throw new Error("line2 is required");
    var type1 = getType(line1, "line1");
    if (type1 !== "LineString") throw new Error("line1 must be a LineString");
    var type2 = getType(line2, "line2");
    if (type2 !== "LineString") throw new Error("line2 must be a LineString");
    var segments1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$segment$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineSegment"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clean$2d$coords$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cleanCoords"])(line1)).features;
    var segments2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$segment$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineSegment"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clean$2d$coords$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cleanCoords"])(line2)).features;
    for(var i = 0; i < segments1.length; i++){
        var segment1 = segments1[i].geometry.coordinates;
        if (!segments2[i]) break;
        var segment2 = segments2[i].geometry.coordinates;
        if (!isParallel(segment1, segment2)) return false;
    }
    return true;
}
function isParallel(segment1, segment2) {
    var slope1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bearingToAzimuth"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rhumbBearing"])(segment1[0], segment1[1]));
    var slope2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bearingToAzimuth"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rhumbBearing"])(segment2[0], segment2[1]));
    return slope1 === slope2 || (slope2 - slope1) % 180 === 0;
}
function getType(geojson, name) {
    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;
    if (geojson.type) return geojson.type;
    throw new Error("Invalid GeoJSON object for " + name);
}
var turf_boolean_parallel_default = booleanParallel;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/boolean-touches/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "booleanTouches": (()=>booleanTouches),
    "default": (()=>turf_boolean_touches_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-on-line/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
function booleanTouches(feature1, feature2) {
    var geom1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getGeom"])(feature1);
    var geom2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getGeom"])(feature2);
    var type1 = geom1.type;
    var type2 = geom2.type;
    switch(type1){
        case "Point":
            switch(type2){
                case "LineString":
                    return isPointOnLineEnd(geom1, geom2);
                case "MultiLineString":
                    var foundTouchingPoint = false;
                    for(var ii = 0; ii < geom2.coordinates.length; ii++){
                        if (isPointOnLineEnd(geom1, {
                            type: "LineString",
                            coordinates: geom2.coordinates[ii]
                        })) foundTouchingPoint = true;
                    }
                    return foundTouchingPoint;
                case "Polygon":
                    for(var i = 0; i < geom2.coordinates.length; i++){
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(geom1, {
                            type: "LineString",
                            coordinates: geom2.coordinates[i]
                        })) return true;
                    }
                    return false;
                case "MultiPolygon":
                    for(var i = 0; i < geom2.coordinates.length; i++){
                        for(var ii = 0; ii < geom2.coordinates[i].length; ii++){
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(geom1, {
                                type: "LineString",
                                coordinates: geom2.coordinates[i][ii]
                            })) return true;
                        }
                    }
                    return false;
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "MultiPoint":
            switch(type2){
                case "LineString":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom1.coordinates.length; i++){
                        if (!foundTouchingPoint) {
                            if (isPointOnLineEnd({
                                type: "Point",
                                coordinates: geom1.coordinates[i]
                            }, geom2)) foundTouchingPoint = true;
                        }
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                            type: "Point",
                            coordinates: geom1.coordinates[i]
                        }, geom2, {
                            ignoreEndVertices: true
                        })) return false;
                    }
                    return foundTouchingPoint;
                case "MultiLineString":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom1.coordinates.length; i++){
                        for(var ii = 0; ii < geom2.coordinates.length; ii++){
                            if (!foundTouchingPoint) {
                                if (isPointOnLineEnd({
                                    type: "Point",
                                    coordinates: geom1.coordinates[i]
                                }, {
                                    type: "LineString",
                                    coordinates: geom2.coordinates[ii]
                                })) foundTouchingPoint = true;
                            }
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                type: "Point",
                                coordinates: geom1.coordinates[i]
                            }, {
                                type: "LineString",
                                coordinates: geom2.coordinates[ii]
                            }, {
                                ignoreEndVertices: true
                            })) return false;
                        }
                    }
                    return foundTouchingPoint;
                case "Polygon":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom1.coordinates.length; i++){
                        if (!foundTouchingPoint) {
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                type: "Point",
                                coordinates: geom1.coordinates[i]
                            }, {
                                type: "LineString",
                                coordinates: geom2.coordinates[0]
                            })) foundTouchingPoint = true;
                        }
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
                            type: "Point",
                            coordinates: geom1.coordinates[i]
                        }, geom2, {
                            ignoreBoundary: true
                        })) return false;
                    }
                    return foundTouchingPoint;
                case "MultiPolygon":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom1.coordinates.length; i++){
                        for(var ii = 0; ii < geom2.coordinates.length; ii++){
                            if (!foundTouchingPoint) {
                                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                    type: "Point",
                                    coordinates: geom1.coordinates[i]
                                }, {
                                    type: "LineString",
                                    coordinates: geom2.coordinates[ii][0]
                                })) foundTouchingPoint = true;
                            }
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
                                type: "Point",
                                coordinates: geom1.coordinates[i]
                            }, {
                                type: "Polygon",
                                coordinates: geom2.coordinates[ii]
                            }, {
                                ignoreBoundary: true
                            })) return false;
                        }
                    }
                    return foundTouchingPoint;
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "LineString":
            switch(type2){
                case "Point":
                    return isPointOnLineEnd(geom2, geom1);
                case "MultiPoint":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom2.coordinates.length; i++){
                        if (!foundTouchingPoint) {
                            if (isPointOnLineEnd({
                                type: "Point",
                                coordinates: geom2.coordinates[i]
                            }, geom1)) foundTouchingPoint = true;
                        }
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                            type: "Point",
                            coordinates: geom2.coordinates[i]
                        }, geom1, {
                            ignoreEndVertices: true
                        })) return false;
                    }
                    return foundTouchingPoint;
                case "LineString":
                    var endMatch = false;
                    if (isPointOnLineEnd({
                        type: "Point",
                        coordinates: geom1.coordinates[0]
                    }, geom2)) endMatch = true;
                    if (isPointOnLineEnd({
                        type: "Point",
                        coordinates: geom1.coordinates[geom1.coordinates.length - 1]
                    }, geom2)) endMatch = true;
                    if (endMatch === false) return false;
                    for(var i = 0; i < geom1.coordinates.length; i++){
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                            type: "Point",
                            coordinates: geom1.coordinates[i]
                        }, geom2, {
                            ignoreEndVertices: true
                        })) return false;
                    }
                    return endMatch;
                case "MultiLineString":
                    var endMatch = false;
                    for(var i = 0; i < geom2.coordinates.length; i++){
                        if (isPointOnLineEnd({
                            type: "Point",
                            coordinates: geom1.coordinates[0]
                        }, {
                            type: "LineString",
                            coordinates: geom2.coordinates[i]
                        })) endMatch = true;
                        if (isPointOnLineEnd({
                            type: "Point",
                            coordinates: geom1.coordinates[geom1.coordinates.length - 1]
                        }, {
                            type: "LineString",
                            coordinates: geom2.coordinates[i]
                        })) endMatch = true;
                        for(var ii = 0; ii < geom1.coordinates[i].length; ii++){
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                type: "Point",
                                coordinates: geom1.coordinates[ii]
                            }, {
                                type: "LineString",
                                coordinates: geom2.coordinates[i]
                            }, {
                                ignoreEndVertices: true
                            })) return false;
                        }
                    }
                    return endMatch;
                case "Polygon":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom1.coordinates.length; i++){
                        if (!foundTouchingPoint) {
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                type: "Point",
                                coordinates: geom1.coordinates[i]
                            }, {
                                type: "LineString",
                                coordinates: geom2.coordinates[0]
                            })) foundTouchingPoint = true;
                        }
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
                            type: "Point",
                            coordinates: geom1.coordinates[i]
                        }, geom2, {
                            ignoreBoundary: true
                        })) return false;
                    }
                    return foundTouchingPoint;
                case "MultiPolygon":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom1.coordinates.length; i++){
                        for(var ii = 0; ii < geom2.coordinates.length; ii++){
                            if (!foundTouchingPoint) {
                                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                    type: "Point",
                                    coordinates: geom1.coordinates[i]
                                }, {
                                    type: "LineString",
                                    coordinates: geom2.coordinates[ii][0]
                                })) foundTouchingPoint = true;
                            }
                        }
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
                            type: "Point",
                            coordinates: geom1.coordinates[i]
                        }, geom2, {
                            ignoreBoundary: true
                        })) return false;
                    }
                    return foundTouchingPoint;
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "MultiLineString":
            switch(type2){
                case "Point":
                    for(var i = 0; i < geom1.coordinates.length; i++){
                        if (isPointOnLineEnd(geom2, {
                            type: "LineString",
                            coordinates: geom1.coordinates[i]
                        })) return true;
                    }
                    return false;
                case "MultiPoint":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom1.coordinates.length; i++){
                        for(var ii = 0; ii < geom2.coordinates.length; ii++){
                            if (!foundTouchingPoint) {
                                if (isPointOnLineEnd({
                                    type: "Point",
                                    coordinates: geom2.coordinates[ii]
                                }, {
                                    type: "LineString",
                                    coordinates: geom1.coordinates[ii]
                                })) foundTouchingPoint = true;
                            }
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                type: "Point",
                                coordinates: geom2.coordinates[ii]
                            }, {
                                type: "LineString",
                                coordinates: geom1.coordinates[ii]
                            }, {
                                ignoreEndVertices: true
                            })) return false;
                        }
                    }
                    return foundTouchingPoint;
                case "LineString":
                    var endMatch = false;
                    for(var i = 0; i < geom1.coordinates.length; i++){
                        if (isPointOnLineEnd({
                            type: "Point",
                            coordinates: geom1.coordinates[i][0]
                        }, geom2)) endMatch = true;
                        if (isPointOnLineEnd({
                            type: "Point",
                            coordinates: geom1.coordinates[i][geom1.coordinates[i].length - 1]
                        }, geom2)) endMatch = true;
                        for(var ii = 0; ii < geom2.coordinates.length; ii++){
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                type: "Point",
                                coordinates: geom2.coordinates[ii]
                            }, {
                                type: "LineString",
                                coordinates: geom1.coordinates[i]
                            }, {
                                ignoreEndVertices: true
                            })) return false;
                        }
                    }
                    return endMatch;
                case "MultiLineString":
                    var endMatch = false;
                    for(var i = 0; i < geom1.coordinates.length; i++){
                        for(var ii = 0; ii < geom2.coordinates.length; ii++){
                            if (isPointOnLineEnd({
                                type: "Point",
                                coordinates: geom1.coordinates[i][0]
                            }, {
                                type: "LineString",
                                coordinates: geom2.coordinates[ii]
                            })) endMatch = true;
                            if (isPointOnLineEnd({
                                type: "Point",
                                coordinates: geom1.coordinates[i][geom1.coordinates[i].length - 1]
                            }, {
                                type: "LineString",
                                coordinates: geom2.coordinates[ii]
                            })) endMatch = true;
                            for(var iii = 0; iii < geom1.coordinates[i].length; iii++){
                                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                    type: "Point",
                                    coordinates: geom1.coordinates[i][iii]
                                }, {
                                    type: "LineString",
                                    coordinates: geom2.coordinates[ii]
                                }, {
                                    ignoreEndVertices: true
                                })) return false;
                            }
                        }
                    }
                    return endMatch;
                case "Polygon":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom1.coordinates.length; i++){
                        for(var ii = 0; ii < geom1.coordinates.length; ii++){
                            if (!foundTouchingPoint) {
                                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                    type: "Point",
                                    coordinates: geom1.coordinates[i][ii]
                                }, {
                                    type: "LineString",
                                    coordinates: geom2.coordinates[0]
                                })) foundTouchingPoint = true;
                            }
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
                                type: "Point",
                                coordinates: geom1.coordinates[i][ii]
                            }, geom2, {
                                ignoreBoundary: true
                            })) return false;
                        }
                    }
                    return foundTouchingPoint;
                case "MultiPolygon":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom2.coordinates[0].length; i++){
                        for(var ii = 0; ii < geom1.coordinates.length; ii++){
                            for(var iii = 0; iii < geom1.coordinates[ii].length; iii++){
                                if (!foundTouchingPoint) {
                                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                        type: "Point",
                                        coordinates: geom1.coordinates[ii][iii]
                                    }, {
                                        type: "LineString",
                                        coordinates: geom2.coordinates[0][i]
                                    })) foundTouchingPoint = true;
                                }
                                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
                                    type: "Point",
                                    coordinates: geom1.coordinates[ii][iii]
                                }, {
                                    type: "Polygon",
                                    coordinates: [
                                        geom2.coordinates[0][i]
                                    ]
                                }, {
                                    ignoreBoundary: true
                                })) return false;
                            }
                        }
                    }
                    return foundTouchingPoint;
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "Polygon":
            switch(type2){
                case "Point":
                    for(var i = 0; i < geom1.coordinates.length; i++){
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(geom2, {
                            type: "LineString",
                            coordinates: geom1.coordinates[i]
                        })) return true;
                    }
                    return false;
                case "MultiPoint":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom2.coordinates.length; i++){
                        if (!foundTouchingPoint) {
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                type: "Point",
                                coordinates: geom2.coordinates[i]
                            }, {
                                type: "LineString",
                                coordinates: geom1.coordinates[0]
                            })) foundTouchingPoint = true;
                        }
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
                            type: "Point",
                            coordinates: geom2.coordinates[i]
                        }, geom1, {
                            ignoreBoundary: true
                        })) return false;
                    }
                    return foundTouchingPoint;
                case "LineString":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom2.coordinates.length; i++){
                        if (!foundTouchingPoint) {
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                type: "Point",
                                coordinates: geom2.coordinates[i]
                            }, {
                                type: "LineString",
                                coordinates: geom1.coordinates[0]
                            })) foundTouchingPoint = true;
                        }
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
                            type: "Point",
                            coordinates: geom2.coordinates[i]
                        }, geom1, {
                            ignoreBoundary: true
                        })) return false;
                    }
                    return foundTouchingPoint;
                case "MultiLineString":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom2.coordinates.length; i++){
                        for(var ii = 0; ii < geom2.coordinates[i].length; ii++){
                            if (!foundTouchingPoint) {
                                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                    type: "Point",
                                    coordinates: geom2.coordinates[i][ii]
                                }, {
                                    type: "LineString",
                                    coordinates: geom1.coordinates[0]
                                })) foundTouchingPoint = true;
                            }
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
                                type: "Point",
                                coordinates: geom2.coordinates[i][ii]
                            }, geom1, {
                                ignoreBoundary: true
                            })) return false;
                        }
                    }
                    return foundTouchingPoint;
                case "Polygon":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom1.coordinates[0].length; i++){
                        if (!foundTouchingPoint) {
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                type: "Point",
                                coordinates: geom1.coordinates[0][i]
                            }, {
                                type: "LineString",
                                coordinates: geom2.coordinates[0]
                            })) foundTouchingPoint = true;
                        }
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
                            type: "Point",
                            coordinates: geom1.coordinates[0][i]
                        }, geom2, {
                            ignoreBoundary: true
                        })) return false;
                    }
                    return foundTouchingPoint;
                case "MultiPolygon":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom2.coordinates[0].length; i++){
                        for(var ii = 0; ii < geom1.coordinates[0].length; ii++){
                            if (!foundTouchingPoint) {
                                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                    type: "Point",
                                    coordinates: geom1.coordinates[0][ii]
                                }, {
                                    type: "LineString",
                                    coordinates: geom2.coordinates[0][i]
                                })) foundTouchingPoint = true;
                            }
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
                                type: "Point",
                                coordinates: geom1.coordinates[0][ii]
                            }, {
                                type: "Polygon",
                                coordinates: geom2.coordinates[0][i]
                            }, {
                                ignoreBoundary: true
                            })) return false;
                        }
                    }
                    return foundTouchingPoint;
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "MultiPolygon":
            switch(type2){
                case "Point":
                    for(var i = 0; i < geom1.coordinates[0].length; i++){
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(geom2, {
                            type: "LineString",
                            coordinates: geom1.coordinates[0][i]
                        })) return true;
                    }
                    return false;
                case "MultiPoint":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom1.coordinates[0].length; i++){
                        for(var ii = 0; ii < geom2.coordinates.length; ii++){
                            if (!foundTouchingPoint) {
                                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                    type: "Point",
                                    coordinates: geom2.coordinates[ii]
                                }, {
                                    type: "LineString",
                                    coordinates: geom1.coordinates[0][i]
                                })) foundTouchingPoint = true;
                            }
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
                                type: "Point",
                                coordinates: geom2.coordinates[ii]
                            }, {
                                type: "Polygon",
                                coordinates: geom1.coordinates[0][i]
                            }, {
                                ignoreBoundary: true
                            })) return false;
                        }
                    }
                    return foundTouchingPoint;
                case "LineString":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom1.coordinates[0].length; i++){
                        for(var ii = 0; ii < geom2.coordinates.length; ii++){
                            if (!foundTouchingPoint) {
                                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                    type: "Point",
                                    coordinates: geom2.coordinates[ii]
                                }, {
                                    type: "LineString",
                                    coordinates: geom1.coordinates[0][i]
                                })) foundTouchingPoint = true;
                            }
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
                                type: "Point",
                                coordinates: geom2.coordinates[ii]
                            }, {
                                type: "Polygon",
                                coordinates: geom1.coordinates[0][i]
                            }, {
                                ignoreBoundary: true
                            })) return false;
                        }
                    }
                    return foundTouchingPoint;
                case "MultiLineString":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom1.coordinates.length; i++){
                        for(var ii = 0; ii < geom2.coordinates.length; ii++){
                            for(var iii = 0; iii < geom2.coordinates[ii].length; iii++){
                                if (!foundTouchingPoint) {
                                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                        type: "Point",
                                        coordinates: geom2.coordinates[ii][iii]
                                    }, {
                                        type: "LineString",
                                        coordinates: geom1.coordinates[i][0]
                                    })) foundTouchingPoint = true;
                                }
                                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
                                    type: "Point",
                                    coordinates: geom2.coordinates[ii][iii]
                                }, {
                                    type: "Polygon",
                                    coordinates: [
                                        geom1.coordinates[i][0]
                                    ]
                                }, {
                                    ignoreBoundary: true
                                })) return false;
                            }
                        }
                    }
                    return foundTouchingPoint;
                case "Polygon":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom1.coordinates[0].length; i++){
                        for(var ii = 0; ii < geom1.coordinates[0][i].length; ii++){
                            if (!foundTouchingPoint) {
                                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                    type: "Point",
                                    coordinates: geom1.coordinates[0][i][ii]
                                }, {
                                    type: "LineString",
                                    coordinates: geom2.coordinates[0]
                                })) foundTouchingPoint = true;
                            }
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
                                type: "Point",
                                coordinates: geom1.coordinates[0][i][ii]
                            }, geom2, {
                                ignoreBoundary: true
                            })) return false;
                        }
                    }
                    return foundTouchingPoint;
                case "MultiPolygon":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom1.coordinates[0].length; i++){
                        for(var ii = 0; ii < geom2.coordinates[0].length; ii++){
                            for(var iii = 0; iii < geom1.coordinates[0].length; iii++){
                                if (!foundTouchingPoint) {
                                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                        type: "Point",
                                        coordinates: geom1.coordinates[0][i][iii]
                                    }, {
                                        type: "LineString",
                                        coordinates: geom2.coordinates[0][ii]
                                    })) foundTouchingPoint = true;
                                }
                                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
                                    type: "Point",
                                    coordinates: geom1.coordinates[0][i][iii]
                                }, {
                                    type: "Polygon",
                                    coordinates: geom2.coordinates[0][ii]
                                }, {
                                    ignoreBoundary: true
                                })) return false;
                            }
                        }
                    }
                    return foundTouchingPoint;
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        default:
            throw new Error("feature1 " + type1 + " geometry not supported");
    }
}
function isPointOnLineEnd(point, line) {
    if (compareCoords(line.coordinates[0], point.coordinates)) return true;
    if (compareCoords(line.coordinates[line.coordinates.length - 1], point.coordinates)) return true;
    return false;
}
function compareCoords(pair1, pair2) {
    return pair1[0] === pair2[0] && pair1[1] === pair2[1];
}
var turf_boolean_touches_default = booleanTouches;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/boolean-valid/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "booleanValid": (()=>booleanValid),
    "default": (()=>turf_boolean_valid_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-intersect/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-on-line/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$disjoint$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-disjoint/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$crosses$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-crosses/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
function booleanValid(feature) {
    if (!feature.type) return false;
    const geom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getGeom"])(feature);
    const type = geom.type;
    const coords = geom.coordinates;
    switch(type){
        case "Point":
            return coords.length > 1;
        case "MultiPoint":
            for(var i = 0; i < coords.length; i++){
                if (coords[i].length < 2) return false;
            }
            return true;
        case "LineString":
            if (coords.length < 2) return false;
            for(var i = 0; i < coords.length; i++){
                if (coords[i].length < 2) return false;
            }
            return true;
        case "MultiLineString":
            if (coords.length < 2) return false;
            for(var i = 0; i < coords.length; i++){
                if (coords[i].length < 2) return false;
            }
            return true;
        case "Polygon":
            for(var i = 0; i < geom.coordinates.length; i++){
                if (coords[i].length < 4) return false;
                if (!checkRingsClose(coords[i])) return false;
                if (checkRingsForSpikesPunctures(coords[i])) return false;
                if (i > 0) {
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineIntersect"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])([
                        coords[0]
                    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])([
                        coords[i]
                    ])).features.length > 1) return false;
                }
            }
            return true;
        case "MultiPolygon":
            for(var i = 0; i < geom.coordinates.length; i++){
                var poly = geom.coordinates[i];
                for(var ii = 0; ii < poly.length; ii++){
                    if (poly[ii].length < 4) return false;
                    if (!checkRingsClose(poly[ii])) return false;
                    if (checkRingsForSpikesPunctures(poly[ii])) return false;
                    if (ii === 0) {
                        if (!checkPolygonAgainstOthers(poly, geom.coordinates, i)) return false;
                    }
                    if (ii > 0) {
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineIntersect"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])([
                            poly[0]
                        ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])([
                            poly[ii]
                        ])).features.length > 1) return false;
                    }
                }
            }
            return true;
        default:
            return false;
    }
}
function checkRingsClose(geom) {
    return geom[0][0] === geom[geom.length - 1][0] && geom[0][1] === geom[geom.length - 1][1];
}
function checkRingsForSpikesPunctures(geom) {
    for(var i = 0; i < geom.length - 1; i++){
        var point = geom[i];
        for(var ii = i + 1; ii < geom.length - 2; ii++){
            var seg = [
                geom[ii],
                geom[ii + 1]
            ];
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(point, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineString"])(seg))) return true;
        }
    }
    return false;
}
function checkPolygonAgainstOthers(poly, geom, index) {
    var polyToCheck = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])(poly);
    for(var i = index + 1; i < geom.length; i++){
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$disjoint$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanDisjoint"])(polyToCheck, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])(geom[i]))) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$crosses$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanCrosses"])(polyToCheck, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineString"])(geom[i][0]))) return false;
        }
    }
    return true;
}
var turf_boolean_valid_default = booleanValid;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/boolean-within/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "booleanWithin": (()=>booleanWithin),
    "default": (()=>turf_boolean_within_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-on-line/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
function booleanWithin(feature1, feature2) {
    var geom1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getGeom"])(feature1);
    var geom2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getGeom"])(feature2);
    var type1 = geom1.type;
    var type2 = geom2.type;
    switch(type1){
        case "Point":
            switch(type2){
                case "MultiPoint":
                    return isPointInMultiPoint(geom1, geom2);
                case "LineString":
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(geom1, geom2, {
                        ignoreEndVertices: true
                    });
                case "Polygon":
                case "MultiPolygon":
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(geom1, geom2, {
                        ignoreBoundary: true
                    });
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "MultiPoint":
            switch(type2){
                case "MultiPoint":
                    return isMultiPointInMultiPoint(geom1, geom2);
                case "LineString":
                    return isMultiPointOnLine(geom1, geom2);
                case "Polygon":
                case "MultiPolygon":
                    return isMultiPointInPoly(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "LineString":
            switch(type2){
                case "LineString":
                    return isLineOnLine(geom1, geom2);
                case "Polygon":
                case "MultiPolygon":
                    return isLineInPoly(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "Polygon":
            switch(type2){
                case "Polygon":
                case "MultiPolygon":
                    return isPolyInPoly(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        default:
            throw new Error("feature1 " + type1 + " geometry not supported");
    }
}
function isPointInMultiPoint(point, multiPoint) {
    var i;
    var output = false;
    for(i = 0; i < multiPoint.coordinates.length; i++){
        if (compareCoords(multiPoint.coordinates[i], point.coordinates)) {
            output = true;
            break;
        }
    }
    return output;
}
function isMultiPointInMultiPoint(multiPoint1, multiPoint2) {
    for(var i = 0; i < multiPoint1.coordinates.length; i++){
        var anyMatch = false;
        for(var i2 = 0; i2 < multiPoint2.coordinates.length; i2++){
            if (compareCoords(multiPoint1.coordinates[i], multiPoint2.coordinates[i2])) {
                anyMatch = true;
            }
        }
        if (!anyMatch) {
            return false;
        }
    }
    return true;
}
function isMultiPointOnLine(multiPoint, lineString) {
    var foundInsidePoint = false;
    for(var i = 0; i < multiPoint.coordinates.length; i++){
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(multiPoint.coordinates[i], lineString)) {
            return false;
        }
        if (!foundInsidePoint) {
            foundInsidePoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(multiPoint.coordinates[i], lineString, {
                ignoreEndVertices: true
            });
        }
    }
    return foundInsidePoint;
}
function isMultiPointInPoly(multiPoint, polygon) {
    var output = true;
    var oneInside = false;
    var isInside = false;
    for(var i = 0; i < multiPoint.coordinates.length; i++){
        isInside = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(multiPoint.coordinates[i], polygon);
        if (!isInside) {
            output = false;
            break;
        }
        if ("TURBOPACK compile-time truthy", 1) {
            isInside = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(multiPoint.coordinates[i], polygon, {
                ignoreBoundary: true
            });
        }
    }
    return output && isInside;
}
function isLineOnLine(lineString1, lineString2) {
    for(var i = 0; i < lineString1.coordinates.length; i++){
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(lineString1.coordinates[i], lineString2)) {
            return false;
        }
    }
    return true;
}
function isLineInPoly(linestring, polygon) {
    var polyBbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bbox"])(polygon);
    var lineBbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bbox"])(linestring);
    if (!doBBoxOverlap(polyBbox, lineBbox)) {
        return false;
    }
    var foundInsidePoint = false;
    for(var i = 0; i < linestring.coordinates.length; i++){
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(linestring.coordinates[i], polygon)) {
            return false;
        }
        if (!foundInsidePoint) {
            foundInsidePoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(linestring.coordinates[i], polygon, {
                ignoreBoundary: true
            });
        }
        if (!foundInsidePoint && i < linestring.coordinates.length - 1) {
            var midpoint = getMidpoint(linestring.coordinates[i], linestring.coordinates[i + 1]);
            foundInsidePoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(midpoint, polygon, {
                ignoreBoundary: true
            });
        }
    }
    return foundInsidePoint;
}
function isPolyInPoly(geometry1, geometry2) {
    var poly1Bbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bbox"])(geometry1);
    var poly2Bbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bbox"])(geometry2);
    if (!doBBoxOverlap(poly2Bbox, poly1Bbox)) {
        return false;
    }
    for(var i = 0; i < geometry1.coordinates[0].length; i++){
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(geometry1.coordinates[0][i], geometry2)) {
            return false;
        }
    }
    return true;
}
function doBBoxOverlap(bbox1, bbox2) {
    if (bbox1[0] > bbox2[0]) return false;
    if (bbox1[2] < bbox2[2]) return false;
    if (bbox1[1] > bbox2[1]) return false;
    if (bbox1[3] < bbox2[3]) return false;
    return true;
}
function compareCoords(pair1, pair2) {
    return pair1[0] === pair2[0] && pair1[1] === pair2[1];
}
function getMidpoint(pair1, pair2) {
    return [
        (pair1[0] + pair2[0]) / 2,
        (pair1[1] + pair2[1]) / 2
    ];
}
var turf_boolean_within_default = booleanWithin;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/center/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "center": (()=>center),
    "default": (()=>turf_center_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
function center(geojson, options = {}) {
    const ext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bbox"])(geojson);
    const x = (ext[0] + ext[2]) / 2;
    const y = (ext[1] + ext[3]) / 2;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])([
        x,
        y
    ], options.properties, options);
}
var turf_center_default = center;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/buffer/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.js
__turbopack_esm__({
    "buffer": (()=>buffer),
    "default": (()=>turf_buffer_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$jsts$2f$dist$2f$jsts$2e$min$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/jsts/dist/jsts.min.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$geo$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/d3-geo/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/center/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$geo$2f$src$2f$projection$2f$azimuthalEquidistant$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__geoAzimuthalEquidistant$3e$__ = __turbopack_import__("[project]/node_modules/d3-geo/src/projection/azimuthalEquidistant.js [app-ssr] (ecmascript) <export default as geoAzimuthalEquidistant>");
;
;
;
;
;
var { BufferOp, GeoJSONReader, GeoJSONWriter } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$jsts$2f$dist$2f$jsts$2e$min$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"];
function buffer(geojson, radius, options) {
    options = options || {};
    var units = options.units || "kilometers";
    var steps = options.steps || 8;
    if (!geojson) throw new Error("geojson is required");
    if (typeof options !== "object") throw new Error("options must be an object");
    if (typeof steps !== "number") throw new Error("steps must be an number");
    if (radius === void 0) throw new Error("radius is required");
    if (steps <= 0) throw new Error("steps must be greater than 0");
    var results = [];
    switch(geojson.type){
        case "GeometryCollection":
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["geomEach"])(geojson, function(geometry) {
                var buffered = bufferFeature(geometry, radius, units, steps);
                if (buffered) results.push(buffered);
            });
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(results);
        case "FeatureCollection":
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"])(geojson, function(feature2) {
                var multiBuffered = bufferFeature(feature2, radius, units, steps);
                if (multiBuffered) {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"])(multiBuffered, function(buffered) {
                        if (buffered) results.push(buffered);
                    });
                }
            });
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(results);
    }
    return bufferFeature(geojson, radius, units, steps);
}
function bufferFeature(geojson, radius, units, steps) {
    var properties = geojson.properties || {};
    var geometry = geojson.type === "Feature" ? geojson.geometry : geojson;
    if (geometry.type === "GeometryCollection") {
        var results = [];
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["geomEach"])(geojson, function(geometry2) {
            var buffered2 = bufferFeature(geometry2, radius, units, steps);
            if (buffered2) results.push(buffered2);
        });
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(results);
    }
    var projection = defineProjection(geometry);
    var projected = {
        type: geometry.type,
        coordinates: projectCoords(geometry.coordinates, projection)
    };
    var reader = new GeoJSONReader();
    var geom = reader.read(projected);
    var distance = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["radiansToLength"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lengthToRadians"])(radius, units), "meters");
    var buffered = BufferOp.bufferOp(geom, distance, steps);
    var writer = new GeoJSONWriter();
    buffered = writer.write(buffered);
    if (coordsIsNaN(buffered.coordinates)) return void 0;
    var result = {
        type: buffered.type,
        coordinates: unprojectCoords(buffered.coordinates, projection)
    };
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["feature"])(result, properties);
}
function coordsIsNaN(coords) {
    if (Array.isArray(coords[0])) return coordsIsNaN(coords[0]);
    return isNaN(coords[0]);
}
function projectCoords(coords, proj) {
    if (typeof coords[0] !== "object") return proj(coords);
    return coords.map(function(coord) {
        return projectCoords(coord, proj);
    });
}
function unprojectCoords(coords, proj) {
    if (typeof coords[0] !== "object") return proj.invert(coords);
    return coords.map(function(coord) {
        return unprojectCoords(coord, proj);
    });
}
function defineProjection(geojson) {
    var coords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["center"])(geojson).geometry.coordinates;
    var rotation = [
        -coords[0],
        -coords[1]
    ];
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$geo$2f$src$2f$projection$2f$azimuthalEquidistant$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__geoAzimuthalEquidistant$3e$__["geoAzimuthalEquidistant"])().rotate(rotation).scale(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["earthRadius"]);
}
var turf_buffer_default = buffer;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/center-mean/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "centerMean": (()=>centerMean),
    "default": (()=>turf_center_mean_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
function centerMean(geojson, options = {}) {
    let sumXs = 0;
    let sumYs = 0;
    let sumNs = 0;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["geomEach"])(geojson, function(geom, featureIndex, properties) {
        let weight = options.weight ? properties == null ? void 0 : properties[options.weight] : void 0;
        weight = weight === void 0 || weight === null ? 1 : weight;
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(weight)) throw new Error("weight value must be a number for feature index " + featureIndex);
        weight = Number(weight);
        if (weight > 0) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["coordEach"])(geom, function(coord) {
                sumXs += coord[0] * weight;
                sumYs += coord[1] * weight;
                sumNs += weight;
            });
        }
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])([
        sumXs / sumNs,
        sumYs / sumNs
    ], options.properties, options);
}
var turf_center_mean_default = centerMean;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/centroid/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "centroid": (()=>centroid),
    "default": (()=>turf_centroid_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
function centroid(geojson, options = {}) {
    let xSum = 0;
    let ySum = 0;
    let len = 0;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["coordEach"])(geojson, function(coord) {
        xSum += coord[0];
        ySum += coord[1];
        len++;
    }, true);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])([
        xSum / len,
        ySum / len
    ], options.properties);
}
var turf_centroid_default = centroid;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/center-median/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "centerMedian": (()=>centerMedian),
    "default": (()=>turf_center_median_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2d$mean$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/center-mean/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/centroid/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
;
function centerMedian(features, options = {}) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    var counter = options.counter || 10;
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(counter)) throw new Error("counter must be a number");
    var weightTerm = options.weight;
    var meanCenter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2d$mean$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["centerMean"])(features, {
        weight: options.weight
    });
    var centroids = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])([]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"])(features, function(feature) {
        var _a;
        centroids.features.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["centroid"])(feature, {
            properties: {
                weight: (_a = feature.properties) == null ? void 0 : _a[weightTerm]
            }
        }));
    });
    const properties = {
        tolerance: options.tolerance,
        medianCandidates: []
    };
    return findMedian(meanCenter.geometry.coordinates, [
        0,
        0
    ], centroids, properties, counter);
}
function findMedian(candidateMedian, previousCandidate, centroids, properties, counter) {
    var tolerance = properties.tolerance || 1e-3;
    var candidateXsum = 0;
    var candidateYsum = 0;
    var kSum = 0;
    var centroidCount = 0;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"])(centroids, function(theCentroid) {
        var _a;
        var weightValue = (_a = theCentroid.properties) == null ? void 0 : _a.weight;
        var weight = weightValue === void 0 || weightValue === null ? 1 : weightValue;
        weight = Number(weight);
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(weight)) throw new Error("weight value must be a number");
        if (weight > 0) {
            centroidCount += 1;
            var distanceFromCandidate = weight * (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distance"])(theCentroid, candidateMedian);
            if (distanceFromCandidate === 0) distanceFromCandidate = 1;
            var k = weight / distanceFromCandidate;
            candidateXsum += theCentroid.geometry.coordinates[0] * k;
            candidateYsum += theCentroid.geometry.coordinates[1] * k;
            kSum += k;
        }
    });
    if (centroidCount < 1) throw new Error("no features to measure");
    var candidateX = candidateXsum / kSum;
    var candidateY = candidateYsum / kSum;
    if (centroidCount === 1 || counter === 0 || Math.abs(candidateX - previousCandidate[0]) < tolerance && Math.abs(candidateY - previousCandidate[1]) < tolerance) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])([
            candidateX,
            candidateY
        ], {
            medianCandidates: properties.medianCandidates
        });
    } else {
        properties.medianCandidates.push([
            candidateX,
            candidateY
        ]);
        return findMedian([
            candidateX,
            candidateY
        ], candidateMedian, centroids, properties, counter - 1);
    }
}
var turf_center_median_default = centerMedian;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/convex/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "convex": (()=>convex),
    "default": (()=>turf_convex_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$concaveman$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/concaveman/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
function convex(geojson, options = {}) {
    options.concavity = options.concavity || Infinity;
    const points = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["coordEach"])(geojson, (coord)=>{
        points.push([
            coord[0],
            coord[1]
        ]);
    });
    if (!points.length) {
        return null;
    }
    const convexHull = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$concaveman$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(points, options.concavity);
    if (convexHull.length > 3) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])([
            convexHull
        ]);
    }
    return null;
}
var turf_convex_default = convex;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/center-of-mass/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "centerOfMass": (()=>centerOfMass),
    "default": (()=>turf_center_of_mass_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/centroid/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$convex$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/convex/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
;
function centerOfMass(geojson, options = {}) {
    switch((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getType"])(geojson)){
        case "Point":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(geojson), options.properties);
        case "Polygon":
            var coords = [];
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["coordEach"])(geojson, function(coord) {
                coords.push(coord);
            });
            var centre = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["centroid"])(geojson, {
                properties: options.properties
            });
            var translation = centre.geometry.coordinates;
            var sx = 0;
            var sy = 0;
            var sArea = 0;
            var i, pi, pj, xi, xj, yi, yj, a;
            var neutralizedPoints = coords.map(function(point2) {
                return [
                    point2[0] - translation[0],
                    point2[1] - translation[1]
                ];
            });
            for(i = 0; i < coords.length - 1; i++){
                pi = neutralizedPoints[i];
                xi = pi[0];
                yi = pi[1];
                pj = neutralizedPoints[i + 1];
                xj = pj[0];
                yj = pj[1];
                a = xi * yj - xj * yi;
                sArea += a;
                sx += (xi + xj) * a;
                sy += (yi + yj) * a;
            }
            if (sArea === 0) {
                return centre;
            } else {
                var area = sArea * 0.5;
                var areaFactor = 1 / (6 * area);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])([
                    translation[0] + areaFactor * sx,
                    translation[1] + areaFactor * sy
                ], options.properties);
            }
        default:
            var hull = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$convex$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["convex"])(geojson);
            if (hull) return centerOfMass(hull, {
                properties: options.properties
            });
            else return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["centroid"])(geojson, {
                properties: options.properties
            });
    }
}
var turf_center_of_mass_default = centerOfMass;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/circle/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "circle": (()=>circle),
    "default": (()=>turf_circle_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/destination/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
function circle(center, radius, options = {}) {
    const steps = options.steps || 64;
    const properties = options.properties ? options.properties : !Array.isArray(center) && center.type === "Feature" && center.properties ? center.properties : {};
    const coordinates = [];
    for(let i = 0; i < steps; i++){
        coordinates.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["destination"])(center, radius, i * -360 / steps, options).geometry.coordinates);
    }
    coordinates.push(coordinates[0]);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])([
        coordinates
    ], properties);
}
var turf_circle_default = circle;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/clusters/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "applyFilter": (()=>applyFilter),
    "clusterEach": (()=>clusterEach),
    "clusterReduce": (()=>clusterReduce),
    "createBins": (()=>createBins),
    "filterProperties": (()=>filterProperties),
    "getCluster": (()=>getCluster),
    "propertiesContainsFilter": (()=>propertiesContainsFilter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
function getCluster(geojson, filter) {
    if (!geojson) throw new Error("geojson is required");
    if (geojson.type !== "FeatureCollection") throw new Error("geojson must be a FeatureCollection");
    if (filter === void 0 || filter === null) throw new Error("filter is required");
    var features = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"])(geojson, function(feature) {
        if (applyFilter(feature.properties, filter)) features.push(feature);
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(features);
}
function clusterEach(geojson, property, callback) {
    if (!geojson) throw new Error("geojson is required");
    if (geojson.type !== "FeatureCollection") throw new Error("geojson must be a FeatureCollection");
    if (property === void 0 || property === null) throw new Error("property is required");
    var bins = createBins(geojson, property);
    var values = Object.keys(bins);
    for(var index = 0; index < values.length; index++){
        var value = values[index];
        var bin = bins[value];
        var features = [];
        for(var i = 0; i < bin.length; i++){
            features.push(geojson.features[bin[i]]);
        }
        callback((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(features), value, index);
    }
}
function clusterReduce(geojson, property, callback, initialValue) {
    var previousValue = initialValue;
    clusterEach(geojson, property, function(cluster, clusterValue, currentIndex) {
        if (currentIndex === 0 && initialValue === void 0) previousValue = cluster;
        else previousValue = callback(previousValue, cluster, clusterValue, currentIndex);
    });
    return previousValue;
}
function createBins(geojson, property) {
    var bins = {};
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"])(geojson, function(feature, i) {
        var properties = feature.properties || {};
        if (Object.prototype.hasOwnProperty.call(properties, String(property))) {
            var value = properties[property];
            if (Object.prototype.hasOwnProperty.call(bins, value)) bins[value].push(i);
            else bins[value] = [
                i
            ];
        }
    });
    return bins;
}
function applyFilter(properties, filter) {
    if (properties === void 0) return false;
    var filterType = typeof filter;
    if (filterType === "number" || filterType === "string") return Object.prototype.hasOwnProperty.call(properties, filter);
    else if (Array.isArray(filter)) {
        for(var i = 0; i < filter.length; i++){
            if (!applyFilter(properties, filter[i])) return false;
        }
        return true;
    } else {
        return propertiesContainsFilter(properties, filter);
    }
}
function propertiesContainsFilter(properties, filter) {
    var keys = Object.keys(filter);
    for(var i = 0; i < keys.length; i++){
        var key = keys[i];
        if (properties[key] !== filter[key]) return false;
    }
    return true;
}
function filterProperties(properties, keys) {
    if (!keys) return {};
    if (!keys.length) return {};
    var newProperties = {};
    for(var i = 0; i < keys.length; i++){
        var key = keys[i];
        if (Object.prototype.hasOwnProperty.call(properties, key)) newProperties[key] = properties[key];
    }
    return newProperties;
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/clone/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "clone": (()=>clone),
    "cloneProperties": (()=>cloneProperties),
    "default": (()=>turf_clone_default)
});
function clone(geojson) {
    if (!geojson) {
        throw new Error("geojson is required");
    }
    switch(geojson.type){
        case "Feature":
            return cloneFeature(geojson);
        case "FeatureCollection":
            return cloneFeatureCollection(geojson);
        case "Point":
        case "LineString":
        case "Polygon":
        case "MultiPoint":
        case "MultiLineString":
        case "MultiPolygon":
        case "GeometryCollection":
            return cloneGeometry(geojson);
        default:
            throw new Error("unknown GeoJSON type");
    }
}
function cloneFeature(geojson) {
    const cloned = {
        type: "Feature"
    };
    Object.keys(geojson).forEach((key)=>{
        switch(key){
            case "type":
            case "properties":
            case "geometry":
                return;
            default:
                cloned[key] = geojson[key];
        }
    });
    cloned.properties = cloneProperties(geojson.properties);
    if (geojson.geometry == null) {
        cloned.geometry = null;
    } else {
        cloned.geometry = cloneGeometry(geojson.geometry);
    }
    return cloned;
}
function cloneProperties(properties) {
    const cloned = {};
    if (!properties) {
        return cloned;
    }
    Object.keys(properties).forEach((key)=>{
        const value = properties[key];
        if (typeof value === "object") {
            if (value === null) {
                cloned[key] = null;
            } else if (Array.isArray(value)) {
                cloned[key] = value.map((item)=>{
                    return item;
                });
            } else {
                cloned[key] = cloneProperties(value);
            }
        } else {
            cloned[key] = value;
        }
    });
    return cloned;
}
function cloneFeatureCollection(geojson) {
    const cloned = {
        type: "FeatureCollection"
    };
    Object.keys(geojson).forEach((key)=>{
        switch(key){
            case "type":
            case "features":
                return;
            default:
                cloned[key] = geojson[key];
        }
    });
    cloned.features = geojson.features.map((feature)=>{
        return cloneFeature(feature);
    });
    return cloned;
}
function cloneGeometry(geometry) {
    const geom = {
        type: geometry.type
    };
    if (geometry.bbox) {
        geom.bbox = geometry.bbox;
    }
    if (geometry.type === "GeometryCollection") {
        geom.geometries = geometry.geometries.map((g)=>{
            return cloneGeometry(g);
        });
        return geom;
    }
    geom.coordinates = deepSlice(geometry.coordinates);
    return geom;
}
function deepSlice(coords) {
    const cloned = coords;
    if (typeof cloned[0] !== "object") {
        return cloned.slice();
    }
    return cloned.map((coord)=>{
        return deepSlice(coord);
    });
}
var turf_clone_default = clone;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/clusters-dbscan/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "clustersDbscan": (()=>clustersDbscan),
    "default": (()=>turf_clusters_dbscan_default)
});
// lib/rbush-export.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rbush/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
var rbush = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"];
// index.ts
function clustersDbscan(points, maxDistance, options = {}) {
    if (options.mutate !== true) points = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(points);
    const minPoints = options.minPoints || 3;
    const latDistanceInDegrees = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lengthToDegrees"])(maxDistance, options.units);
    var tree = new rbush(points.features.length);
    var visited = points.features.map((_)=>false);
    var assigned = points.features.map((_)=>false);
    var isnoise = points.features.map((_)=>false);
    var clusterIds = points.features.map((_)=>-1);
    tree.load(points.features.map((point, index)=>{
        var [x, y] = point.geometry.coordinates;
        return {
            minX: x,
            minY: y,
            maxX: x,
            maxY: y,
            index
        };
    }));
    const regionQuery = (index)=>{
        const point = points.features[index];
        const [x, y] = point.geometry.coordinates;
        const minY = Math.max(y - latDistanceInDegrees, -90);
        const maxY = Math.min(y + latDistanceInDegrees, 90);
        const lonDistanceInDegrees = function() {
            if (minY < 0 && maxY > 0) {
                return latDistanceInDegrees;
            }
            if (Math.abs(minY) < Math.abs(maxY)) {
                return latDistanceInDegrees / Math.cos((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["degreesToRadians"])(maxY));
            } else {
                return latDistanceInDegrees / Math.cos((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["degreesToRadians"])(minY));
            }
        }();
        const minX = Math.max(x - lonDistanceInDegrees, -360);
        const maxX = Math.min(x + lonDistanceInDegrees, 360);
        const bbox = {
            minX,
            minY,
            maxX,
            maxY
        };
        return tree.search(bbox).filter((neighbor)=>{
            const neighborIndex = neighbor.index;
            const neighborPoint = points.features[neighborIndex];
            const distanceInKm = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distance"])(point, neighborPoint, {
                units: "kilometers"
            });
            return distanceInKm <= maxDistance;
        });
    };
    const expandCluster = (clusteredId, neighbors)=>{
        for(var i = 0; i < neighbors.length; i++){
            var neighbor = neighbors[i];
            const neighborIndex = neighbor.index;
            if (!visited[neighborIndex]) {
                visited[neighborIndex] = true;
                const nextNeighbors = regionQuery(neighborIndex);
                if (nextNeighbors.length >= minPoints) {
                    neighbors.push(...nextNeighbors);
                }
            }
            if (!assigned[neighborIndex]) {
                assigned[neighborIndex] = true;
                clusterIds[neighborIndex] = clusteredId;
            }
        }
    };
    var nextClusteredId = 0;
    points.features.forEach((_, index)=>{
        if (visited[index]) return;
        const neighbors = regionQuery(index);
        if (neighbors.length >= minPoints) {
            const clusteredId = nextClusteredId;
            nextClusteredId++;
            visited[index] = true;
            expandCluster(clusteredId, neighbors);
        } else {
            isnoise[index] = true;
        }
    });
    points.features.forEach((_, index)=>{
        var clusterPoint = points.features[index];
        if (!clusterPoint.properties) {
            clusterPoint.properties = {};
        }
        if (clusterIds[index] >= 0) {
            clusterPoint.properties.dbscan = isnoise[index] ? "edge" : "core";
            clusterPoint.properties.cluster = clusterIds[index];
        } else {
            clusterPoint.properties.dbscan = "noise";
        }
    });
    return points;
}
var turf_clusters_dbscan_default = clustersDbscan;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/clusters-kmeans/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "clustersKmeans": (()=>clustersKmeans),
    "default": (()=>turf_clusters_kmeans_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$skmeans$2f$dist$2f$node$2f$main$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/skmeans/dist/node/main.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
function clustersKmeans(points, options = {}) {
    var count = points.features.length;
    options.numberOfClusters = options.numberOfClusters || Math.round(Math.sqrt(count / 2));
    if (options.numberOfClusters > count) options.numberOfClusters = count;
    if (options.mutate !== true) points = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(points);
    var data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["coordAll"])(points);
    var initialCentroids = data.slice(0, options.numberOfClusters);
    var skmeansResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$skmeans$2f$dist$2f$node$2f$main$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(data, options.numberOfClusters, initialCentroids);
    var centroids = {};
    skmeansResult.centroids.forEach(function(coord, idx) {
        centroids[idx] = coord;
    });
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"])(points, function(point, index) {
        var clusterId = skmeansResult.idxs[index];
        point.properties.cluster = clusterId;
        point.properties.centroid = centroids[clusterId];
    });
    return points;
}
var turf_clusters_kmeans_default = clustersKmeans;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/collect/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "collect": (()=>collect),
    "default": (()=>turf_collect_default)
});
// lib/rbush-export.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rbush/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
var rbush = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"];
// index.ts
function collect(polygons, points, inProperty, outProperty) {
    var rtree = new rbush(6);
    var treeItems = points.features.map(function(item) {
        var _a;
        return {
            minX: item.geometry.coordinates[0],
            minY: item.geometry.coordinates[1],
            maxX: item.geometry.coordinates[0],
            maxY: item.geometry.coordinates[1],
            property: (_a = item.properties) == null ? void 0 : _a[inProperty]
        };
    });
    rtree.load(treeItems);
    polygons.features.forEach(function(poly) {
        if (!poly.properties) {
            poly.properties = {};
        }
        var bbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bbox"])(poly);
        var potentialPoints = rtree.search({
            minX: bbox[0],
            minY: bbox[1],
            maxX: bbox[2],
            maxY: bbox[3]
        });
        var values = [];
        potentialPoints.forEach(function(pt) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])([
                pt.minX,
                pt.minY
            ], poly)) {
                values.push(pt.property);
            }
        });
        poly.properties[outProperty] = values;
    });
    return polygons;
}
var turf_collect_default = collect;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/combine/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "combine": (()=>combine),
    "default": (()=>turf_combine_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
function combine(fc) {
    var groups = {
        MultiPoint: {
            coordinates: [],
            properties: []
        },
        MultiLineString: {
            coordinates: [],
            properties: []
        },
        MultiPolygon: {
            coordinates: [],
            properties: []
        }
    };
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"])(fc, (feature2)=>{
        var _a;
        switch((_a = feature2.geometry) == null ? void 0 : _a.type){
            case "Point":
                groups.MultiPoint.coordinates.push(feature2.geometry.coordinates);
                groups.MultiPoint.properties.push(feature2.properties);
                break;
            case "MultiPoint":
                groups.MultiPoint.coordinates.push(...feature2.geometry.coordinates);
                groups.MultiPoint.properties.push(feature2.properties);
                break;
            case "LineString":
                groups.MultiLineString.coordinates.push(feature2.geometry.coordinates);
                groups.MultiLineString.properties.push(feature2.properties);
                break;
            case "MultiLineString":
                groups.MultiLineString.coordinates.push(...feature2.geometry.coordinates);
                groups.MultiLineString.properties.push(feature2.properties);
                break;
            case "Polygon":
                groups.MultiPolygon.coordinates.push(feature2.geometry.coordinates);
                groups.MultiPolygon.properties.push(feature2.properties);
                break;
            case "MultiPolygon":
                groups.MultiPolygon.coordinates.push(...feature2.geometry.coordinates);
                groups.MultiPolygon.properties.push(feature2.properties);
                break;
            default:
                break;
        }
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(Object.keys(groups).filter(function(key) {
        return groups[key].coordinates.length;
    }).sort().map(function(key) {
        var geometry = {
            type: key,
            coordinates: groups[key].coordinates
        };
        var properties = {
            collectedProperties: groups[key].properties
        };
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["feature"])(geometry, properties);
    }));
}
var turf_combine_default = combine;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/tin/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_tin_default),
    "tin": (()=>tin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
function tin(points, z) {
    let isPointZ = false;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(triangulate(points.features.map((p)=>{
        const point = {
            x: p.geometry.coordinates[0],
            y: p.geometry.coordinates[1]
        };
        if (z) {
            point.z = p.properties[z];
        } else if (p.geometry.coordinates.length === 3) {
            isPointZ = true;
            point.z = p.geometry.coordinates[2];
        }
        return point;
    })).map((triangle)=>{
        const a = [
            triangle.a.x,
            triangle.a.y
        ];
        const b = [
            triangle.b.x,
            triangle.b.y
        ];
        const c = [
            triangle.c.x,
            triangle.c.y
        ];
        let properties = {};
        if (isPointZ) {
            a.push(triangle.a.z);
            b.push(triangle.b.z);
            c.push(triangle.c.z);
        } else {
            properties = {
                a: triangle.a.z,
                b: triangle.b.z,
                c: triangle.c.z
            };
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])([
            [
                a,
                b,
                c,
                a
            ]
        ], properties);
    }));
}
var Triangle = class {
    constructor(a, b, c){
        this.a = a;
        this.b = b;
        this.c = c;
        const A = b.x - a.x;
        const B = b.y - a.y;
        const C = c.x - a.x;
        const D = c.y - a.y;
        const E = A * (a.x + b.x) + B * (a.y + b.y);
        const F = C * (a.x + c.x) + D * (a.y + c.y);
        const G = 2 * (A * (c.y - b.y) - B * (c.x - b.x));
        let dx;
        let dy;
        this.x = (D * E - B * F) / G;
        this.y = (A * F - C * E) / G;
        dx = this.x - a.x;
        dy = this.y - a.y;
        this.r = dx * dx + dy * dy;
    }
};
function byX(a, b) {
    return b.x - a.x;
}
function dedup(edges) {
    let j = edges.length;
    let a;
    let b;
    let i;
    let m;
    let n;
    outer: while(j){
        b = edges[--j];
        a = edges[--j];
        i = j;
        while(i){
            n = edges[--i];
            m = edges[--i];
            if (a === m && b === n || a === n && b === m) {
                edges.splice(j, 2);
                edges.splice(i, 2);
                j -= 2;
                continue outer;
            }
        }
    }
}
function triangulate(vertices) {
    if (vertices.length < 3) {
        return [];
    }
    vertices.sort(byX);
    let i = vertices.length - 1;
    const xmin = vertices[i].x;
    const xmax = vertices[0].x;
    let ymin = vertices[i].y;
    let ymax = ymin;
    const epsilon = 1e-12;
    let a;
    let b;
    let c;
    let A;
    let B;
    let G;
    while(i--){
        if (vertices[i].y < ymin) {
            ymin = vertices[i].y;
        }
        if (vertices[i].y > ymax) {
            ymax = vertices[i].y;
        }
    }
    let dx = xmax - xmin;
    let dy = ymax - ymin;
    const dmax = dx > dy ? dx : dy;
    const xmid = (xmax + xmin) * 0.5;
    const ymid = (ymax + ymin) * 0.5;
    const open = [
        new Triangle({
            __sentinel: true,
            x: xmid - 20 * dmax,
            y: ymid - dmax
        }, {
            __sentinel: true,
            x: xmid,
            y: ymid + 20 * dmax
        }, {
            __sentinel: true,
            x: xmid + 20 * dmax,
            y: ymid - dmax
        })
    ];
    const closed = [];
    const edges = [];
    let j;
    i = vertices.length;
    while(i--){
        edges.length = 0;
        j = open.length;
        while(j--){
            dx = vertices[i].x - open[j].x;
            if (dx > 0 && dx * dx > open[j].r) {
                closed.push(open[j]);
                open.splice(j, 1);
                continue;
            }
            dy = vertices[i].y - open[j].y;
            if (dx * dx + dy * dy > open[j].r) {
                continue;
            }
            edges.push(open[j].a, open[j].b, open[j].b, open[j].c, open[j].c, open[j].a);
            open.splice(j, 1);
        }
        dedup(edges);
        j = edges.length;
        while(j){
            b = edges[--j];
            a = edges[--j];
            c = vertices[i];
            A = b.x - a.x;
            B = b.y - a.y;
            G = 2 * (A * (c.y - b.y) - B * (c.x - b.x));
            if (Math.abs(G) > epsilon) {
                open.push(new Triangle(a, b, c));
            }
        }
    }
    Array.prototype.push.apply(closed, open);
    i = closed.length;
    while(i--){
        if (closed[i].a.__sentinel || closed[i].b.__sentinel || closed[i].c.__sentinel) {
            closed.splice(i, 1);
        }
    }
    return closed;
}
var turf_tin_default = tin;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/concave/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "concave": (()=>concave),
    "default": (()=>turf_concave_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/topojson-client/src/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/topojson-server/src/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
// lib/turf-line-dissolve.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$topology$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__topology$3e$__ = __turbopack_import__("[project]/node_modules/topojson-server/src/topology.js [app-ssr] (ecmascript) <export default as topology>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$merge$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__merge$3e$__ = __turbopack_import__("[project]/node_modules/topojson-client/src/merge.js [app-ssr] (ecmascript) <export default as merge>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$tin$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/tin/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
function lineDissolve(geojson, options = {}) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(options)) {
        throw new Error("options is invalid");
    }
    const mutate = options.mutate;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getType"])(geojson) !== "FeatureCollection") {
        throw new Error("geojson must be a FeatureCollection");
    }
    if (!geojson.features.length) {
        throw new Error("geojson is empty");
    }
    if (mutate === false || mutate === void 0) {
        geojson = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(geojson);
    }
    const result = [];
    const lastLine = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineReduce"])(geojson, (previousLine, currentLine)=>{
        const merged = mergeLineStrings(previousLine, currentLine);
        if (merged) {
            return merged;
        } else {
            result.push(previousLine);
            return currentLine;
        }
    });
    if (lastLine) {
        result.push(lastLine);
    }
    if (!result.length) {
        return null;
    } else if (result.length === 1) {
        return result[0];
    } else {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["multiLineString"])(result.map((line)=>{
            return line.coordinates;
        }));
    }
}
function coordId(coord) {
    return coord[0].toString() + "," + coord[1].toString();
}
function mergeLineStrings(a, b) {
    const coords1 = a.geometry.coordinates;
    const coords2 = b.geometry.coordinates;
    const s1 = coordId(coords1[0]);
    const e1 = coordId(coords1[coords1.length - 1]);
    const s2 = coordId(coords2[0]);
    const e2 = coordId(coords2[coords2.length - 1]);
    let coords;
    if (s1 === e2) {
        coords = coords2.concat(coords1.slice(1));
    } else if (s2 === e1) {
        coords = coords1.concat(coords2.slice(1));
    } else if (s1 === s2) {
        coords = coords1.slice(1).reverse().concat(coords2);
    } else if (e1 === e2) {
        coords = coords1.concat(coords2.reverse().slice(1));
    } else {
        return null;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineString"])(coords);
}
;
;
;
;
;
;
function polygonDissolve(geojson, options = {}) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getType"])(geojson) !== "FeatureCollection") {
        throw new Error("geojson must be a FeatureCollection");
    }
    if (!geojson.features.length) {
        throw new Error("geojson is empty");
    }
    if (options.mutate === false || options.mutate === void 0) {
        geojson = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(geojson);
    }
    const geoms = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flattenEach"])(geojson, (feature2)=>{
        geoms.push(feature2.geometry);
    });
    const topo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$topology$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__topology$3e$__["topology"])({
        geoms: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["geometryCollection"])(geoms).geometry
    });
    const merged = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$merge$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__merge$3e$__["merge"])(topo, topo.objects.geoms.geometries);
    return merged;
}
// lib/turf-dissolve.ts
function dissolve(geojson, options = {}) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(options)) {
        throw new Error("options is invalid");
    }
    const mutate = options.mutate;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getType"])(geojson) !== "FeatureCollection") {
        throw new Error("geojson must be a FeatureCollection");
    }
    if (!geojson.features.length) {
        throw new Error("geojson is empty");
    }
    if (mutate === false || mutate === void 0) {
        geojson = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(geojson);
    }
    const type = getHomogenousType(geojson);
    if (!type) {
        throw new Error("geojson must be homogenous");
    }
    const data = geojson;
    switch(type){
        case "LineString":
            return lineDissolve(data, options);
        case "Polygon":
            return polygonDissolve(data, options);
        default:
            throw new Error(type + " is not supported");
    }
}
function getHomogenousType(geojson) {
    const types = {};
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flattenEach"])(geojson, (feature2)=>{
        types[feature2.geometry.type] = true;
    });
    const keys = Object.keys(types);
    if (keys.length === 1) {
        return keys[0];
    }
    return null;
}
// index.ts
function concave(points, options = {}) {
    const maxEdge = options.maxEdge || Infinity;
    const cleaned = removeDuplicates(points);
    const tinPolys = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$tin$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["tin"])(cleaned);
    tinPolys.features = tinPolys.features.filter((triangle)=>{
        const pt1 = triangle.geometry.coordinates[0][0];
        const pt2 = triangle.geometry.coordinates[0][1];
        const pt3 = triangle.geometry.coordinates[0][2];
        const dist1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distance"])(pt1, pt2, options);
        const dist2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distance"])(pt2, pt3, options);
        const dist3 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distance"])(pt1, pt3, options);
        return dist1 <= maxEdge && dist2 <= maxEdge && dist3 <= maxEdge;
    });
    if (tinPolys.features.length < 1) {
        return null;
    }
    const dissolved = dissolve(tinPolys);
    if (dissolved.coordinates.length === 1) {
        dissolved.coordinates = dissolved.coordinates[0];
        dissolved.type = "Polygon";
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["feature"])(dissolved);
}
function removeDuplicates(points) {
    const cleaned = [];
    const existing = {};
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"])(points, (pt)=>{
        if (!pt.geometry) {
            return;
        }
        const key = pt.geometry.coordinates.join("-");
        if (!Object.prototype.hasOwnProperty.call(existing, key)) {
            cleaned.push(pt);
            existing[key] = true;
        }
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(cleaned);
}
var turf_concave_default = concave;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/difference/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_difference_default),
    "difference": (()=>difference2)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/polyclip-ts/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
function difference2(features) {
    const geoms = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["geomEach"])(features, (geom)=>{
        geoms.push(geom.coordinates);
    });
    if (geoms.length < 2) {
        throw new Error("Must have at least two features");
    }
    const properties = features.features[0].properties || {};
    const differenced = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.difference(geoms[0], ...geoms.slice(1));
    if (differenced.length === 0) return null;
    if (differenced.length === 1) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])(differenced[0], properties);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["multiPolygon"])(differenced, properties);
}
var turf_difference_default = difference2;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/flatten/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_flatten_default),
    "flatten": (()=>flatten)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
function flatten(geojson) {
    if (!geojson) throw new Error("geojson is required");
    var results = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flattenEach"])(geojson, function(feature) {
        results.push(feature);
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(results);
}
var turf_flatten_default = flatten;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/dissolve/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_dissolve_default),
    "dissolve": (()=>dissolve)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/polyclip-ts/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$flatten$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/flatten/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
;
function dissolve(fc, options = {}) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    const { propertyName } = options;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["collectionOf"])(fc, "Polygon", "dissolve");
    const outFeatures = [];
    if (!propertyName) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$flatten$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["multiPolygon"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.union.apply(null, // List of polygons expressed as Position[][][] a.k.a. Geom[]
        fc.features.map(function(f) {
            return f.geometry.coordinates;
        }))));
    } else {
        const uniquePropertyVals = {};
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"])(fc, function(feature) {
            if (feature.properties) {
                if (!Object.prototype.hasOwnProperty.call(uniquePropertyVals, feature.properties[propertyName])) {
                    uniquePropertyVals[feature.properties[propertyName]] = [];
                }
                uniquePropertyVals[feature.properties[propertyName]].push(feature);
            }
        });
        const vals = Object.keys(uniquePropertyVals);
        for(let i = 0; i < vals.length; i++){
            const mp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["multiPolygon"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.union.apply(null, // List of polygons expressed as Position[][][] a.k.a. Geom[]
            uniquePropertyVals[vals[i]].map(function(f) {
                return f.geometry.coordinates;
            })));
            if (mp && mp.properties) {
                mp.properties[propertyName] = vals[i];
                outFeatures.push(mp);
            }
        }
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$flatten$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(outFeatures));
}
var turf_dissolve_default = dissolve;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/distance-weight/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_distance_weight_default),
    "distanceWeight": (()=>distanceWeight),
    "pNormDistance": (()=>pNormDistance)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/centroid/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
function pNormDistance(feature1, feature2, p = 2) {
    const coordinate1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(feature1);
    const coordinate2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(feature2);
    const xDiff = coordinate1[0] - coordinate2[0];
    const yDiff = coordinate1[1] - coordinate2[1];
    if (p === 1) {
        return Math.abs(xDiff) + Math.abs(yDiff);
    }
    return Math.pow(Math.pow(xDiff, p) + Math.pow(yDiff, p), 1 / p);
}
function distanceWeight(fc, options) {
    var _a, _b;
    options = options || {};
    const threshold = options.threshold || 1e4;
    const p = options.p || 2;
    const binary = (_a = options.binary) != null ? _a : false;
    const alpha = options.alpha || -1;
    const rowTransform = (_b = options.standardization) != null ? _b : false;
    const features = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"])(fc, (feature)=>{
        features.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["centroid"])(feature));
    });
    const weights = [];
    for(let i = 0; i < features.length; i++){
        weights[i] = [];
    }
    for(let i = 0; i < features.length; i++){
        for(let j = i; j < features.length; j++){
            if (i === j) {
                weights[i][j] = 0;
            }
            const dis = pNormDistance(features[i], features[j], p);
            weights[i][j] = dis;
            weights[j][i] = dis;
        }
    }
    for(let i = 0; i < features.length; i++){
        for(let j = 0; j < features.length; j++){
            const dis = weights[i][j];
            if (dis === 0) {
                continue;
            }
            if (binary) {
                if (dis <= threshold) {
                    weights[i][j] = 1;
                } else {
                    weights[i][j] = 0;
                }
            } else {
                if (dis <= threshold) {
                    weights[i][j] = Math.pow(dis, alpha);
                } else {
                    weights[i][j] = 0;
                }
            }
        }
    }
    if (rowTransform) {
        for(let i = 0; i < features.length; i++){
            const rowSum = weights[i].reduce((sum, currentVal)=>{
                return sum + currentVal;
            }, 0);
            for(let j = 0; j < features.length; j++){
                weights[i][j] = weights[i][j] / rowSum;
            }
        }
    }
    return weights;
}
var turf_distance_weight_default = distanceWeight;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/rhumb-destination/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_rhumb_destination_default),
    "rhumbDestination": (()=>rhumbDestination)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
function rhumbDestination(origin, distance, bearing, options = {}) {
    const wasNegativeDistance = distance < 0;
    let distanceInMeters = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["convertLength"])(Math.abs(distance), options.units, "meters");
    if (wasNegativeDistance) distanceInMeters = -Math.abs(distanceInMeters);
    const coords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(origin);
    const destination = calculateRhumbDestination(coords, distanceInMeters, bearing);
    destination[0] += destination[0] - coords[0] > 180 ? -360 : coords[0] - destination[0] > 180 ? 360 : 0;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])(destination, options.properties);
}
function calculateRhumbDestination(origin, distance, bearing, radius) {
    radius = radius === void 0 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["earthRadius"] : Number(radius);
    const delta = distance / radius;
    const lambda1 = origin[0] * Math.PI / 180;
    const phi1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["degreesToRadians"])(origin[1]);
    const theta = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["degreesToRadians"])(bearing);
    const DeltaPhi = delta * Math.cos(theta);
    let phi2 = phi1 + DeltaPhi;
    if (Math.abs(phi2) > Math.PI / 2) {
        phi2 = phi2 > 0 ? Math.PI - phi2 : -Math.PI - phi2;
    }
    const DeltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
    const q = Math.abs(DeltaPsi) > 1e-11 ? DeltaPhi / DeltaPsi : Math.cos(phi1);
    const DeltaLambda = delta * Math.sin(theta) / q;
    const lambda2 = lambda1 + DeltaLambda;
    return [
        (lambda2 * 180 / Math.PI + 540) % 360 - 180,
        phi2 * 180 / Math.PI
    ];
}
var turf_rhumb_destination_default = rhumbDestination;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/rhumb-distance/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_rhumb_distance_default),
    "rhumbDistance": (()=>rhumbDistance)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
function rhumbDistance(from, to, options = {}) {
    const origin = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(from);
    const destination = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(to);
    destination[0] += destination[0] - origin[0] > 180 ? -360 : origin[0] - destination[0] > 180 ? 360 : 0;
    const distanceInMeters = calculateRhumbDistance(origin, destination);
    const distance = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["convertLength"])(distanceInMeters, "meters", options.units);
    return distance;
}
function calculateRhumbDistance(origin, destination, radius) {
    radius = radius === void 0 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["earthRadius"] : Number(radius);
    const R = radius;
    const phi1 = origin[1] * Math.PI / 180;
    const phi2 = destination[1] * Math.PI / 180;
    const DeltaPhi = phi2 - phi1;
    let DeltaLambda = Math.abs(destination[0] - origin[0]) * Math.PI / 180;
    if (DeltaLambda > Math.PI) {
        DeltaLambda -= 2 * Math.PI;
    }
    const DeltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
    const q = Math.abs(DeltaPsi) > 1e-11 ? DeltaPhi / DeltaPsi : Math.cos(phi1);
    const delta = Math.sqrt(DeltaPhi * DeltaPhi + q * q * DeltaLambda * DeltaLambda);
    const dist = delta * R;
    return dist;
}
var turf_rhumb_distance_default = rhumbDistance;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/transform-rotate/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_transform_rotate_default),
    "transformRotate": (()=>transformRotate)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/centroid/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rhumb-bearing/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rhumb-distance/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rhumb-destination/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
function transformRotate(geojson, angle, options) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    const pivot = options.pivot;
    const mutate = options.mutate;
    if (!geojson) throw new Error("geojson is required");
    if (angle === void 0 || angle === null || isNaN(angle)) throw new Error("angle is required");
    if (angle === 0) return geojson;
    const pivotCoord = pivot != null ? pivot : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["centroid"])(geojson);
    if (mutate === false || mutate === void 0) geojson = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(geojson);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["coordEach"])(geojson, function(pointCoords) {
        const initialAngle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rhumbBearing"])(pivotCoord, pointCoords);
        const finalAngle = initialAngle + angle;
        const distance = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rhumbDistance"])(pivotCoord, pointCoords);
        const newCoords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rhumbDestination"])(pivotCoord, distance, finalAngle));
        pointCoords[0] = newCoords[0];
        pointCoords[1] = newCoords[1];
    });
    return geojson;
}
var turf_transform_rotate_default = transformRotate;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/ellipse/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_ellipse_default),
    "ellipse": (()=>ellipse)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rhumb-destination/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$transform$2d$rotate$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/transform-rotate/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
function ellipse(center, xSemiAxis, ySemiAxis, options) {
    options = options || {};
    const steps = options.steps || 64;
    const units = options.units || "kilometers";
    const angle = options.angle || 0;
    const pivot = options.pivot || center;
    const properties = options.properties || {};
    if (!center) throw new Error("center is required");
    if (!xSemiAxis) throw new Error("xSemiAxis is required");
    if (!ySemiAxis) throw new Error("ySemiAxis is required");
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options must be an object");
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(steps)) throw new Error("steps must be a number");
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(angle)) throw new Error("angle must be a number");
    const centerCoords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(center);
    if (units !== "degrees") {
        const xDest = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rhumbDestination"])(center, xSemiAxis, 90, {
            units
        });
        const yDest = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rhumbDestination"])(center, ySemiAxis, 0, {
            units
        });
        xSemiAxis = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(xDest)[0] - centerCoords[0];
        ySemiAxis = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(yDest)[1] - centerCoords[1];
    }
    const coordinates = [];
    for(let i = 0; i < steps; i += 1){
        const stepAngle = i * -360 / steps;
        let x = xSemiAxis * ySemiAxis / Math.sqrt(Math.pow(ySemiAxis, 2) + Math.pow(xSemiAxis, 2) * Math.pow(getTanDeg(stepAngle), 2));
        let y = xSemiAxis * ySemiAxis / Math.sqrt(Math.pow(xSemiAxis, 2) + Math.pow(ySemiAxis, 2) / Math.pow(getTanDeg(stepAngle), 2));
        if (stepAngle < -90 && stepAngle >= -270) x = -x;
        if (stepAngle < -180 && stepAngle >= -360) y = -y;
        if (units === "degrees") {
            const angleRad = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["degreesToRadians"])(angle);
            const newx = x * Math.cos(angleRad) + y * Math.sin(angleRad);
            const newy = y * Math.cos(angleRad) - x * Math.sin(angleRad);
            x = newx;
            y = newy;
        }
        coordinates.push([
            x + centerCoords[0],
            y + centerCoords[1]
        ]);
    }
    coordinates.push(coordinates[0]);
    if (units === "degrees") {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])([
            coordinates
        ], properties);
    } else {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$transform$2d$rotate$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["transformRotate"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])([
            coordinates
        ], properties), angle, {
            pivot
        });
    }
}
function getTanDeg(deg) {
    const rad = deg * Math.PI / 180;
    return Math.tan(rad);
}
var turf_ellipse_default = ellipse;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/envelope/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_envelope_default),
    "envelope": (()=>envelope)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox-polygon/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
function envelope(geojson) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bboxPolygon"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bbox"])(geojson));
}
var turf_envelope_default = envelope;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/explode/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_explode_default),
    "explode": (()=>explode)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
function explode(geojson) {
    const points = [];
    if (geojson.type === "FeatureCollection") {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"])(geojson, function(feature) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["coordEach"])(feature, function(coord) {
                points.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])(coord, feature.properties));
            });
        });
    } else if (geojson.type === "Feature") {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["coordEach"])(geojson, function(coord) {
            points.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])(coord, geojson.properties));
        });
    } else {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["coordEach"])(geojson, function(coord) {
            points.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])(coord));
        });
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(points);
}
var turf_explode_default = explode;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/flip/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_flip_default),
    "flip": (()=>flip)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
function flip(geojson, options) {
    var _a;
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    const mutate = (_a = options.mutate) != null ? _a : false;
    if (!geojson) throw new Error("geojson is required");
    if (mutate === false || mutate === void 0) geojson = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(geojson);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["coordEach"])(geojson, function(coord) {
        var x = coord[0];
        var y = coord[1];
        coord[0] = y;
        coord[1] = x;
    });
    return geojson;
}
var turf_flip_default = flip;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/great-circle/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.js
__turbopack_esm__({
    "default": (()=>turf_great_circle_default),
    "greatCircle": (()=>greatCircle)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
// lib/arc.js
var D2R = Math.PI / 180;
var R2D = 180 / Math.PI;
var Coord = function(lon, lat) {
    this.lon = lon;
    this.lat = lat;
    this.x = D2R * lon;
    this.y = D2R * lat;
};
Coord.prototype.view = function() {
    return String(this.lon).slice(0, 4) + "," + String(this.lat).slice(0, 4);
};
Coord.prototype.antipode = function() {
    var anti_lat = -1 * this.lat;
    var anti_lon = this.lon < 0 ? 180 + this.lon : (180 - this.lon) * -1;
    return new Coord(anti_lon, anti_lat);
};
var LineString = function() {
    this.coords = [];
    this.length = 0;
};
LineString.prototype.move_to = function(coord) {
    this.length++;
    this.coords.push(coord);
};
var Arc = function(properties) {
    this.properties = properties || {};
    this.geometries = [];
};
Arc.prototype.json = function() {
    if (this.geometries.length <= 0) {
        return {
            geometry: {
                type: "LineString",
                coordinates: null
            },
            type: "Feature",
            properties: this.properties
        };
    } else if (this.geometries.length === 1) {
        return {
            geometry: {
                type: "LineString",
                coordinates: this.geometries[0].coords
            },
            type: "Feature",
            properties: this.properties
        };
    } else {
        var multiline = [];
        for(var i = 0; i < this.geometries.length; i++){
            multiline.push(this.geometries[i].coords);
        }
        return {
            geometry: {
                type: "MultiLineString",
                coordinates: multiline
            },
            type: "Feature",
            properties: this.properties
        };
    }
};
Arc.prototype.wkt = function() {
    var wkt_string = "";
    var wkt = "LINESTRING(";
    var collect = function(c) {
        wkt += c[0] + " " + c[1] + ",";
    };
    for(var i = 0; i < this.geometries.length; i++){
        if (this.geometries[i].coords.length === 0) {
            return "LINESTRING(empty)";
        } else {
            var coords = this.geometries[i].coords;
            coords.forEach(collect);
            wkt_string += wkt.substring(0, wkt.length - 1) + ")";
        }
    }
    return wkt_string;
};
var GreatCircle = function(start, end, properties) {
    if (!start || start.x === void 0 || start.y === void 0) {
        throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties");
    }
    if (!end || end.x === void 0 || end.y === void 0) {
        throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties");
    }
    this.start = new Coord(start.x, start.y);
    this.end = new Coord(end.x, end.y);
    this.properties = properties || {};
    var w = this.start.x - this.end.x;
    var h = this.start.y - this.end.y;
    var z = Math.pow(Math.sin(h / 2), 2) + Math.cos(this.start.y) * Math.cos(this.end.y) * Math.pow(Math.sin(w / 2), 2);
    this.g = 2 * Math.asin(Math.sqrt(z));
    if (this.g === Math.PI) {
        throw new Error("it appears " + start.view() + " and " + end.view() + " are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite");
    } else if (isNaN(this.g)) {
        throw new Error("could not calculate great circle between " + start + " and " + end);
    }
};
GreatCircle.prototype.interpolate = function(f) {
    var A = Math.sin((1 - f) * this.g) / Math.sin(this.g);
    var B = Math.sin(f * this.g) / Math.sin(this.g);
    var x = A * Math.cos(this.start.y) * Math.cos(this.start.x) + B * Math.cos(this.end.y) * Math.cos(this.end.x);
    var y = A * Math.cos(this.start.y) * Math.sin(this.start.x) + B * Math.cos(this.end.y) * Math.sin(this.end.x);
    var z = A * Math.sin(this.start.y) + B * Math.sin(this.end.y);
    var lat = R2D * Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));
    var lon = R2D * Math.atan2(y, x);
    return [
        lon,
        lat
    ];
};
GreatCircle.prototype.Arc = function(npoints, options) {
    var first_pass = [];
    if (!npoints || npoints <= 2) {
        first_pass.push([
            this.start.lon,
            this.start.lat
        ]);
        first_pass.push([
            this.end.lon,
            this.end.lat
        ]);
    } else {
        var delta = 1 / (npoints - 1);
        for(var i = 0; i < npoints; ++i){
            var step = delta * i;
            var pair = this.interpolate(step);
            first_pass.push(pair);
        }
    }
    var bHasBigDiff = false;
    var dfMaxSmallDiffLong = 0;
    var dfDateLineOffset = options && options.offset ? options.offset : 10;
    var dfLeftBorderX = 180 - dfDateLineOffset;
    var dfRightBorderX = -180 + dfDateLineOffset;
    var dfDiffSpace = 360 - dfDateLineOffset;
    for(var j = 1; j < first_pass.length; ++j){
        var dfPrevX = first_pass[j - 1][0];
        var dfX = first_pass[j][0];
        var dfDiffLong = Math.abs(dfX - dfPrevX);
        if (dfDiffLong > dfDiffSpace && (dfX > dfLeftBorderX && dfPrevX < dfRightBorderX || dfPrevX > dfLeftBorderX && dfX < dfRightBorderX)) {
            bHasBigDiff = true;
        } else if (dfDiffLong > dfMaxSmallDiffLong) {
            dfMaxSmallDiffLong = dfDiffLong;
        }
    }
    var poMulti = [];
    if (bHasBigDiff && dfMaxSmallDiffLong < dfDateLineOffset) {
        var poNewLS = [];
        poMulti.push(poNewLS);
        for(var k = 0; k < first_pass.length; ++k){
            var dfX0 = parseFloat(first_pass[k][0]);
            if (k > 0 && Math.abs(dfX0 - first_pass[k - 1][0]) > dfDiffSpace) {
                var dfX1 = parseFloat(first_pass[k - 1][0]);
                var dfY1 = parseFloat(first_pass[k - 1][1]);
                var dfX2 = parseFloat(first_pass[k][0]);
                var dfY2 = parseFloat(first_pass[k][1]);
                if (dfX1 > -180 && dfX1 < dfRightBorderX && dfX2 === 180 && k + 1 < first_pass.length && first_pass[k - 1][0] > -180 && first_pass[k - 1][0] < dfRightBorderX) {
                    poNewLS.push([
                        -180,
                        first_pass[k][1]
                    ]);
                    k++;
                    poNewLS.push([
                        first_pass[k][0],
                        first_pass[k][1]
                    ]);
                    continue;
                } else if (dfX1 > dfLeftBorderX && dfX1 < 180 && dfX2 === -180 && k + 1 < first_pass.length && first_pass[k - 1][0] > dfLeftBorderX && first_pass[k - 1][0] < 180) {
                    poNewLS.push([
                        180,
                        first_pass[k][1]
                    ]);
                    k++;
                    poNewLS.push([
                        first_pass[k][0],
                        first_pass[k][1]
                    ]);
                    continue;
                }
                if (dfX1 < dfRightBorderX && dfX2 > dfLeftBorderX) {
                    var tmpX = dfX1;
                    dfX1 = dfX2;
                    dfX2 = tmpX;
                    var tmpY = dfY1;
                    dfY1 = dfY2;
                    dfY2 = tmpY;
                }
                if (dfX1 > dfLeftBorderX && dfX2 < dfRightBorderX) {
                    dfX2 += 360;
                }
                if (dfX1 <= 180 && dfX2 >= 180 && dfX1 < dfX2) {
                    var dfRatio = (180 - dfX1) / (dfX2 - dfX1);
                    var dfY = dfRatio * dfY2 + (1 - dfRatio) * dfY1;
                    poNewLS.push([
                        first_pass[k - 1][0] > dfLeftBorderX ? 180 : -180,
                        dfY
                    ]);
                    poNewLS = [];
                    poNewLS.push([
                        first_pass[k - 1][0] > dfLeftBorderX ? -180 : 180,
                        dfY
                    ]);
                    poMulti.push(poNewLS);
                } else {
                    poNewLS = [];
                    poMulti.push(poNewLS);
                }
                poNewLS.push([
                    dfX0,
                    first_pass[k][1]
                ]);
            } else {
                poNewLS.push([
                    first_pass[k][0],
                    first_pass[k][1]
                ]);
            }
        }
    } else {
        var poNewLS0 = [];
        poMulti.push(poNewLS0);
        for(var l = 0; l < first_pass.length; ++l){
            poNewLS0.push([
                first_pass[l][0],
                first_pass[l][1]
            ]);
        }
    }
    var arc = new Arc(this.properties);
    for(var m = 0; m < poMulti.length; ++m){
        var line = new LineString();
        arc.geometries.push(line);
        var points = poMulti[m];
        for(var j0 = 0; j0 < points.length; ++j0){
            line.move_to(points[j0]);
        }
    }
    return arc;
};
// index.js
function greatCircle(start, end, options) {
    options = options || {};
    if (typeof options !== "object") throw new Error("options is invalid");
    var properties = options.properties;
    var npoints = options.npoints;
    var offset = options.offset;
    start = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(start);
    end = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(end);
    properties = properties || {};
    npoints = npoints || 100;
    if (start[0] === end[0] && start[1] === end[1]) {
        const arr = Array(npoints);
        arr.fill([
            start[0],
            start[1]
        ]);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineString"])(arr, properties);
    }
    offset = offset || 10;
    var generator = new GreatCircle({
        x: start[0],
        y: start[1]
    }, {
        x: end[0],
        y: end[1]
    }, properties);
    var line = generator.Arc(npoints, {
        offset
    });
    return line.json();
}
var turf_great_circle_default = greatCircle;
;
 /*!
 * Copyright (c) 2019, Dane Springmeyer
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in
 *       the documentation and/or other materials provided with the
 *       distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */  //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/intersect/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_intersect_default),
    "intersect": (()=>intersect)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/polyclip-ts/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
function intersect(features, options = {}) {
    const geoms = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["geomEach"])(features, (geom)=>{
        geoms.push(geom.coordinates);
    });
    if (geoms.length < 2) {
        throw new Error("Must specify at least 2 geometries");
    }
    const intersection2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.intersection(geoms[0], ...geoms.slice(1));
    if (intersection2.length === 0) return null;
    if (intersection2.length === 1) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])(intersection2[0], options.properties);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["multiPolygon"])(intersection2, options.properties);
}
var turf_intersect_default = intersect;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/hex-grid/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_hex_grid_default),
    "hexGrid": (()=>hexGrid)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/intersect/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
function hexGrid(bbox, cellSide, options = {}) {
    const clonedProperties = JSON.stringify(options.properties || {});
    const [west, south, east, north] = bbox;
    const centerY = (south + north) / 2;
    const centerX = (west + east) / 2;
    const xFraction = cellSide * 2 / (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distance"])([
        west,
        centerY
    ], [
        east,
        centerY
    ], options);
    const cellWidth = xFraction * (east - west);
    const yFraction = cellSide * 2 / (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distance"])([
        centerX,
        south
    ], [
        centerX,
        north
    ], options);
    const cellHeight = yFraction * (north - south);
    const radius = cellWidth / 2;
    const hex_width = radius * 2;
    const hex_height = Math.sqrt(3) / 2 * cellHeight;
    const box_width = east - west;
    const box_height = north - south;
    const x_interval = 3 / 4 * hex_width;
    const y_interval = hex_height;
    const x_span = (box_width - hex_width) / (hex_width - radius / 2);
    const x_count = Math.floor(x_span);
    const x_adjust = (x_count * x_interval - radius / 2 - box_width) / 2 - radius / 2 + x_interval / 2;
    const y_count = Math.floor((box_height - hex_height) / hex_height);
    let y_adjust = (box_height - y_count * hex_height) / 2;
    const hasOffsetY = y_count * hex_height - box_height > hex_height / 2;
    if (hasOffsetY) {
        y_adjust -= hex_height / 4;
    }
    const cosines = [];
    const sines = [];
    for(let i = 0; i < 6; i++){
        const angle = 2 * Math.PI / 6 * i;
        cosines.push(Math.cos(angle));
        sines.push(Math.sin(angle));
    }
    const results = [];
    for(let x = 0; x <= x_count; x++){
        for(let y = 0; y <= y_count; y++){
            const isOdd = x % 2 === 1;
            if (y === 0 && isOdd) continue;
            if (y === 0 && hasOffsetY) continue;
            const center_x = x * x_interval + west - x_adjust;
            let center_y = y * y_interval + south + y_adjust;
            if (isOdd) {
                center_y -= hex_height / 2;
            }
            if (options.triangles === true) {
                hexTriangles([
                    center_x,
                    center_y
                ], cellWidth / 2, cellHeight / 2, JSON.parse(clonedProperties), cosines, sines).forEach(function(triangle) {
                    if (options.mask) {
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["intersect"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])([
                            options.mask,
                            triangle
                        ]))) results.push(triangle);
                    } else {
                        results.push(triangle);
                    }
                });
            } else {
                const hex = hexagon([
                    center_x,
                    center_y
                ], cellWidth / 2, cellHeight / 2, JSON.parse(clonedProperties), cosines, sines);
                if (options.mask) {
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["intersect"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])([
                        options.mask,
                        hex
                    ]))) results.push(hex);
                } else {
                    results.push(hex);
                }
            }
        }
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(results);
}
function hexagon(center, rx, ry, properties, cosines, sines) {
    const vertices = [];
    for(let i = 0; i < 6; i++){
        const x = center[0] + rx * cosines[i];
        const y = center[1] + ry * sines[i];
        vertices.push([
            x,
            y
        ]);
    }
    vertices.push(vertices[0].slice());
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])([
        vertices
    ], properties);
}
function hexTriangles(center, rx, ry, properties, cosines, sines) {
    const triangles = [];
    for(let i = 0; i < 6; i++){
        const vertices = [];
        vertices.push(center);
        vertices.push([
            center[0] + rx * cosines[i],
            center[1] + ry * sines[i]
        ]);
        vertices.push([
            center[0] + rx * cosines[(i + 1) % 6],
            center[1] + ry * sines[(i + 1) % 6]
        ]);
        vertices.push(center);
        triangles.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])([
            vertices
        ], properties));
    }
    return triangles;
}
var turf_hex_grid_default = hexGrid;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/point-grid/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_point_grid_default),
    "pointGrid": (()=>pointGrid)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$within$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-within/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
function pointGrid(bbox, cellSide, options = {}) {
    if (options.mask && !options.units) options.units = "kilometers";
    var results = [];
    var west = bbox[0];
    var south = bbox[1];
    var east = bbox[2];
    var north = bbox[3];
    var xFraction = cellSide / (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distance"])([
        west,
        south
    ], [
        east,
        south
    ], options);
    var cellWidth = xFraction * (east - west);
    var yFraction = cellSide / (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distance"])([
        west,
        south
    ], [
        west,
        north
    ], options);
    var cellHeight = yFraction * (north - south);
    var bboxWidth = east - west;
    var bboxHeight = north - south;
    var columns = Math.floor(bboxWidth / cellWidth);
    var rows = Math.floor(bboxHeight / cellHeight);
    var deltaX = (bboxWidth - columns * cellWidth) / 2;
    var deltaY = (bboxHeight - rows * cellHeight) / 2;
    var currentX = west + deltaX;
    while(currentX <= east){
        var currentY = south + deltaY;
        while(currentY <= north){
            var cellPt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])([
                currentX,
                currentY
            ], options.properties);
            if (options.mask) {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$within$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanWithin"])(cellPt, options.mask)) results.push(cellPt);
            } else {
                results.push(cellPt);
            }
            currentY += cellHeight;
        }
        currentX += cellWidth;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(results);
}
var turf_point_grid_default = pointGrid;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/rectangle-grid/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_rectangle_grid_default),
    "rectangleGrid": (()=>rectangleGrid)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$intersects$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-intersects/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
function rectangleGrid(bbox, cellWidth, cellHeight, options = {}) {
    const results = [];
    const west = bbox[0];
    const south = bbox[1];
    const east = bbox[2];
    const north = bbox[3];
    const bboxWidth = east - west;
    const cellWidthDeg = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["convertLength"])(cellWidth, options.units, "degrees");
    const bboxHeight = north - south;
    const cellHeightDeg = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["convertLength"])(cellHeight, options.units, "degrees");
    const columns = Math.floor(Math.abs(bboxWidth) / cellWidthDeg);
    const rows = Math.floor(Math.abs(bboxHeight) / cellHeightDeg);
    const deltaX = (bboxWidth - columns * cellWidthDeg) / 2;
    const deltaY = (bboxHeight - rows * cellHeightDeg) / 2;
    let currentX = west + deltaX;
    for(let column = 0; column < columns; column++){
        let currentY = south + deltaY;
        for(let row = 0; row < rows; row++){
            const cellPoly = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])([
                [
                    [
                        currentX,
                        currentY
                    ],
                    [
                        currentX,
                        currentY + cellHeightDeg
                    ],
                    [
                        currentX + cellWidthDeg,
                        currentY + cellHeightDeg
                    ],
                    [
                        currentX + cellWidthDeg,
                        currentY
                    ],
                    [
                        currentX,
                        currentY
                    ]
                ]
            ], options.properties);
            if (options.mask) {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$intersects$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanIntersects"])(options.mask, cellPoly)) {
                    results.push(cellPoly);
                }
            } else {
                results.push(cellPoly);
            }
            currentY += cellHeightDeg;
        }
        currentX += cellWidthDeg;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(results);
}
var turf_rectangle_grid_default = rectangleGrid;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/square-grid/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_square_grid_default),
    "squareGrid": (()=>squareGrid)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rectangle$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rectangle-grid/dist/esm/index.js [app-ssr] (ecmascript)");
;
function squareGrid(bbox, cellSide, options = {}) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rectangle$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rectangleGrid"])(bbox, cellSide, cellSide, options);
}
var turf_square_grid_default = squareGrid;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/triangle-grid/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_triangle_grid_default),
    "triangleGrid": (()=>triangleGrid)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/intersect/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
function triangleGrid(bbox, cellSide, options = {}) {
    var results = [];
    var xFraction = cellSide / (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distance"])([
        bbox[0],
        bbox[1]
    ], [
        bbox[2],
        bbox[1]
    ], options);
    var cellWidth = xFraction * (bbox[2] - bbox[0]);
    var yFraction = cellSide / (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distance"])([
        bbox[0],
        bbox[1]
    ], [
        bbox[0],
        bbox[3]
    ], options);
    var cellHeight = yFraction * (bbox[3] - bbox[1]);
    var xi = 0;
    var currentX = bbox[0];
    while(currentX <= bbox[2]){
        var yi = 0;
        var currentY = bbox[1];
        while(currentY <= bbox[3]){
            var cellTriangle1 = null;
            var cellTriangle2 = null;
            if (xi % 2 === 0 && yi % 2 === 0) {
                cellTriangle1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])([
                    [
                        [
                            currentX,
                            currentY
                        ],
                        [
                            currentX,
                            currentY + cellHeight
                        ],
                        [
                            currentX + cellWidth,
                            currentY
                        ],
                        [
                            currentX,
                            currentY
                        ]
                    ]
                ], options.properties);
                cellTriangle2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])([
                    [
                        [
                            currentX,
                            currentY + cellHeight
                        ],
                        [
                            currentX + cellWidth,
                            currentY + cellHeight
                        ],
                        [
                            currentX + cellWidth,
                            currentY
                        ],
                        [
                            currentX,
                            currentY + cellHeight
                        ]
                    ]
                ], options.properties);
            } else if (xi % 2 === 0 && yi % 2 === 1) {
                cellTriangle1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])([
                    [
                        [
                            currentX,
                            currentY
                        ],
                        [
                            currentX + cellWidth,
                            currentY + cellHeight
                        ],
                        [
                            currentX + cellWidth,
                            currentY
                        ],
                        [
                            currentX,
                            currentY
                        ]
                    ]
                ], options.properties);
                cellTriangle2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])([
                    [
                        [
                            currentX,
                            currentY
                        ],
                        [
                            currentX,
                            currentY + cellHeight
                        ],
                        [
                            currentX + cellWidth,
                            currentY + cellHeight
                        ],
                        [
                            currentX,
                            currentY
                        ]
                    ]
                ], options.properties);
            } else if (yi % 2 === 0 && xi % 2 === 1) {
                cellTriangle1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])([
                    [
                        [
                            currentX,
                            currentY
                        ],
                        [
                            currentX,
                            currentY + cellHeight
                        ],
                        [
                            currentX + cellWidth,
                            currentY + cellHeight
                        ],
                        [
                            currentX,
                            currentY
                        ]
                    ]
                ], options.properties);
                cellTriangle2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])([
                    [
                        [
                            currentX,
                            currentY
                        ],
                        [
                            currentX + cellWidth,
                            currentY + cellHeight
                        ],
                        [
                            currentX + cellWidth,
                            currentY
                        ],
                        [
                            currentX,
                            currentY
                        ]
                    ]
                ], options.properties);
            } else if (yi % 2 === 1 && xi % 2 === 1) {
                cellTriangle1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])([
                    [
                        [
                            currentX,
                            currentY
                        ],
                        [
                            currentX,
                            currentY + cellHeight
                        ],
                        [
                            currentX + cellWidth,
                            currentY
                        ],
                        [
                            currentX,
                            currentY
                        ]
                    ]
                ], options.properties);
                cellTriangle2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])([
                    [
                        [
                            currentX,
                            currentY + cellHeight
                        ],
                        [
                            currentX + cellWidth,
                            currentY + cellHeight
                        ],
                        [
                            currentX + cellWidth,
                            currentY
                        ],
                        [
                            currentX,
                            currentY + cellHeight
                        ]
                    ]
                ], options.properties);
            }
            if (options.mask) {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["intersect"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])([
                    options.mask,
                    cellTriangle1
                ]))) results.push(cellTriangle1);
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["intersect"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])([
                    options.mask,
                    cellTriangle2
                ]))) results.push(cellTriangle2);
            } else {
                results.push(cellTriangle1);
                results.push(cellTriangle2);
            }
            currentY += cellHeight;
            yi++;
        }
        xi++;
        currentX += cellWidth;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(results);
}
var turf_triangle_grid_default = triangleGrid;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/interpolate/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.js
__turbopack_esm__({
    "default": (()=>turf_interpolate_default),
    "interpolate": (()=>interpolate)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$point$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/point-grid/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$square$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/square-grid/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$hex$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/hex-grid/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$triangle$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/triangle-grid/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/centroid/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
function interpolate(points, cellSize, options) {
    options = options || {};
    if (typeof options !== "object") throw new Error("options is invalid");
    var gridType = options.gridType;
    var property = options.property;
    var weight = options.weight;
    var box = options.bbox;
    if (!points) throw new Error("points is required");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["collectionOf"])(points, "Point", "input must contain Points");
    if (!cellSize) throw new Error("cellSize is required");
    if (weight !== void 0 && typeof weight !== "number") throw new Error("weight must be a number");
    property = property || "elevation";
    gridType = gridType || "square";
    weight = weight || 1;
    box = box != null ? box : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bbox"])(points);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["validateBBox"])(box);
    var grid;
    switch(gridType){
        case "point":
        case "points":
            grid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$point$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pointGrid"])(box, cellSize, options);
            break;
        case "square":
        case "squares":
            grid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$square$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["squareGrid"])(box, cellSize, options);
            break;
        case "hex":
        case "hexes":
            grid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$hex$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hexGrid"])(box, cellSize, options);
            break;
        case "triangle":
        case "triangles":
            grid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$triangle$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["triangleGrid"])(box, cellSize, options);
            break;
        default:
            throw new Error("invalid gridType");
    }
    var results = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"])(grid, function(gridFeature) {
        var zw = 0;
        var sw = 0;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"])(points, function(point) {
            var gridPoint = gridType === "point" ? gridFeature : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["centroid"])(gridFeature);
            var d = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distance"])(gridPoint, point, options);
            var zValue;
            if (property !== void 0) zValue = point.properties[property];
            if (zValue === void 0) zValue = point.geometry.coordinates[2];
            if (zValue === void 0) throw new Error("zValue is missing");
            if (d === 0) zw = zValue;
            var w = 1 / Math.pow(d, weight);
            sw += w;
            zw += w * zValue;
        });
        var newFeature = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(gridFeature);
        newFeature.properties[property] = zw / sw;
        results.push(newFeature);
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(results);
}
var turf_interpolate_default = interpolate;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/isobands/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>turf_isobands_default),
    "isobands": (()=>isobands)
});
// index.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$marchingsquares$2f$dist$2f$marchingsquares$2d$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/marchingsquares/dist/marchingsquares-esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
// lib/grid-to-matrix.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
// index.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$area$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/area/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$explode$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/explode/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [app-ssr] (ecmascript)");
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
;
;
;
;
;
;
;
;
;
function gridToMatrix(grid, options) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    var zProperty = options.zProperty || "elevation";
    var flip = options.flip;
    var flags = options.flags;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["collectionOf"])(grid, "Point", "input must contain Points");
    var pointsMatrix = sortPointsByLatLng(grid, flip);
    var matrix = [];
    for(var r = 0; r < pointsMatrix.length; r++){
        var pointRow = pointsMatrix[r];
        var row = [];
        for(var c = 0; c < pointRow.length; c++){
            var point = pointRow[c];
            if (point.properties[zProperty]) row.push(point.properties[zProperty]);
            else row.push(0);
            if (flags === true) point.properties.matrixPosition = [
                r,
                c
            ];
        }
        matrix.push(row);
    }
    return matrix;
}
function sortPointsByLatLng(points, flip) {
    var pointsByLatitude = {};
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"])(points, function(point) {
        var lat = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(point)[1];
        if (!pointsByLatitude[lat]) pointsByLatitude[lat] = [];
        pointsByLatitude[lat].push(point);
    });
    var orderedRowsByLatitude = Object.keys(pointsByLatitude).map(function(lat) {
        var row = pointsByLatitude[lat];
        var rowOrderedByLongitude = row.sort(function(a, b) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(a)[0] - (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(b)[0];
        });
        return rowOrderedByLongitude;
    });
    var pointMatrix = orderedRowsByLatitude.sort(function(a, b) {
        if (flip) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(a[0])[1] - (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(b[0])[1];
        else return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(b[0])[1] - (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(a[0])[1];
    });
    return pointMatrix;
}
;
function isobands(pointGrid, breaks, options) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    const zProperty = options.zProperty || "elevation";
    const commonProperties = options.commonProperties || {};
    const breaksProperties = options.breaksProperties || [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["collectionOf"])(pointGrid, "Point", "Input must contain Points");
    if (!breaks) throw new Error("breaks is required");
    if (!Array.isArray(breaks)) throw new Error("breaks is not an Array");
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(commonProperties)) throw new Error("commonProperties is not an Object");
    if (!Array.isArray(breaksProperties)) throw new Error("breaksProperties is not an Array");
    const matrix = gridToMatrix(pointGrid, {
        zProperty,
        flip: true
    });
    let contours = createContourLines(matrix, breaks, zProperty);
    contours = rescaleContours(contours, matrix, pointGrid);
    const multipolygons = contours.map((contour, index)=>{
        if (breaksProperties[index] && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(breaksProperties[index])) {
            throw new Error("Each mappedProperty is required to be an Object");
        }
        const contourProperties = __spreadValues(__spreadValues({}, commonProperties), breaksProperties[index]);
        contourProperties[zProperty] = contour[zProperty];
        const multiP = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["multiPolygon"])(contour.groupedRings, contourProperties);
        return multiP;
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(multipolygons);
}
function createContourLines(matrix, breaks, property) {
    const contours = [];
    for(let i = 1; i < breaks.length; i++){
        const lowerBand = +breaks[i - 1];
        const upperBand = +breaks[i];
        const isobandsCoords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$marchingsquares$2f$dist$2f$marchingsquares$2d$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isoBands"])(matrix, lowerBand, upperBand - lowerBand);
        const nestedRings = orderByArea(isobandsCoords);
        const groupedRings = groupNestedRings(nestedRings);
        contours.push({
            groupedRings,
            [property]: lowerBand + "-" + upperBand
        });
    }
    return contours;
}
function rescaleContours(contours, matrix, points) {
    const gridBbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bbox"])(points);
    const originalWidth = gridBbox[2] - gridBbox[0];
    const originalHeigth = gridBbox[3] - gridBbox[1];
    const x0 = gridBbox[0];
    const y0 = gridBbox[1];
    const matrixWidth = matrix[0].length - 1;
    const matrixHeight = matrix.length - 1;
    const scaleX = originalWidth / matrixWidth;
    const scaleY = originalHeigth / matrixHeight;
    return contours.map(function(contour) {
        contour.groupedRings = contour.groupedRings.map(function(lineRingSet) {
            return lineRingSet.map(function(lineRing) {
                return lineRing.map((point)=>[
                        point[0] * scaleX + x0,
                        point[1] * scaleY + y0
                    ]);
            });
        });
        return contour;
    });
}
function orderByArea(ringsCoords) {
    const ringsWithArea = ringsCoords.map(function(coords) {
        return {
            ring: coords,
            area: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$area$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["area"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])([
                coords
            ]))
        };
    });
    ringsWithArea.sort(function(a, b) {
        return b.area - a.area;
    });
    return ringsWithArea.map(function(x) {
        return x.ring;
    });
}
function groupNestedRings(orderedLinearRings) {
    const lrList = orderedLinearRings.map((lr)=>{
        return {
            lrCoordinates: lr,
            grouped: false
        };
    });
    const groupedLinearRingsCoords = [];
    while(!allGrouped(lrList)){
        for(let i = 0; i < lrList.length; i++){
            if (!lrList[i].grouped) {
                const group = [];
                group.push(lrList[i].lrCoordinates);
                lrList[i].grouped = true;
                const outerMostPoly = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])([
                    lrList[i].lrCoordinates
                ]);
                for(let j = i + 1; j < lrList.length; j++){
                    if (!lrList[j].grouped) {
                        const lrPoly = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])([
                            lrList[j].lrCoordinates
                        ]);
                        if (isInside(lrPoly, outerMostPoly)) {
                            group.push(lrList[j].lrCoordinates);
                            lrList[j].grouped = true;
                        }
                    }
                }
                groupedLinearRingsCoords.push(group);
            }
        }
    }
    return groupedLinearRingsCoords;
}
function isInside(testPolygon, targetPolygon) {
    const points = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$explode$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["explode"])(testPolygon);
    for(let i = 0; i < points.features.length; i++){
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(points.features[i], targetPolygon)) {
            return false;
        }
    }
    return true;
}
function allGrouped(list) {
    for(let i = 0; i < list.length; i++){
        if (list[i].grouped === false) {
            return false;
        }
    }
    return true;
}
var turf_isobands_default = isobands;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/isolines/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>turf_isolines_default),
    "isolines": (()=>isolines)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$marchingsquares$2f$dist$2f$marchingsquares$2d$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/marchingsquares/dist/marchingsquares-esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
// lib/grid-to-matrix.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
// index.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-ssr] (ecmascript)");
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
;
;
;
;
;
;
;
;
function gridToMatrix(grid, options) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    var zProperty = options.zProperty || "elevation";
    var flip = options.flip;
    var flags = options.flags;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["collectionOf"])(grid, "Point", "input must contain Points");
    var pointsMatrix = sortPointsByLatLng(grid, flip);
    var matrix = [];
    for(var r = 0; r < pointsMatrix.length; r++){
        var pointRow = pointsMatrix[r];
        var row = [];
        for(var c = 0; c < pointRow.length; c++){
            var point = pointRow[c];
            if (point.properties[zProperty]) row.push(point.properties[zProperty]);
            else row.push(0);
            if (flags === true) point.properties.matrixPosition = [
                r,
                c
            ];
        }
        matrix.push(row);
    }
    return matrix;
}
function sortPointsByLatLng(points, flip) {
    var pointsByLatitude = {};
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"])(points, function(point) {
        var lat = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(point)[1];
        if (!pointsByLatitude[lat]) pointsByLatitude[lat] = [];
        pointsByLatitude[lat].push(point);
    });
    var orderedRowsByLatitude = Object.keys(pointsByLatitude).map(function(lat) {
        var row = pointsByLatitude[lat];
        var rowOrderedByLongitude = row.sort(function(a, b) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(a)[0] - (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(b)[0];
        });
        return rowOrderedByLongitude;
    });
    var pointMatrix = orderedRowsByLatitude.sort(function(a, b) {
        if (flip) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(a[0])[1] - (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(b[0])[1];
        else return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(b[0])[1] - (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(a[0])[1];
    });
    return pointMatrix;
}
// index.ts
function isolines(pointGrid, breaks, options) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    const zProperty = options.zProperty || "elevation";
    const commonProperties = options.commonProperties || {};
    const breaksProperties = options.breaksProperties || [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["collectionOf"])(pointGrid, "Point", "Input must contain Points");
    if (!breaks) throw new Error("breaks is required");
    if (!Array.isArray(breaks)) throw new Error("breaks must be an Array");
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(commonProperties)) throw new Error("commonProperties must be an Object");
    if (!Array.isArray(breaksProperties)) throw new Error("breaksProperties must be an Array");
    const matrix = gridToMatrix(pointGrid, {
        zProperty,
        flip: true
    });
    const createdIsoLines = createIsoLines(matrix, breaks, zProperty, commonProperties, breaksProperties);
    const scaledIsolines = rescaleIsolines(createdIsoLines, matrix, pointGrid);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(scaledIsolines);
}
function createIsoLines(matrix, breaks, zProperty, commonProperties, breaksProperties) {
    const results = [];
    for(let i = 0; i < breaks.length; i++){
        const threshold = +breaks[i];
        const properties = __spreadValues(__spreadValues({}, commonProperties), breaksProperties[i]);
        properties[zProperty] = threshold;
        const isoline = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["multiLineString"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$marchingsquares$2f$dist$2f$marchingsquares$2d$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isoContours"])(matrix, threshold, {
            linearRing: false,
            noFrame: true
        }), properties);
        results.push(isoline);
    }
    return results;
}
function rescaleIsolines(createdIsoLines, matrix, points) {
    const gridBbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bbox"])(points);
    const originalWidth = gridBbox[2] - gridBbox[0];
    const originalHeigth = gridBbox[3] - gridBbox[1];
    const x0 = gridBbox[0];
    const y0 = gridBbox[1];
    const matrixWidth = matrix[0].length - 1;
    const matrixHeight = matrix.length - 1;
    const scaleX = originalWidth / matrixWidth;
    const scaleY = originalHeigth / matrixHeight;
    const resize = (point)=>{
        point[0] = point[0] * scaleX + x0;
        point[1] = point[1] * scaleY + y0;
    };
    createdIsoLines.forEach((isoline)=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["coordEach"])(isoline, resize);
    });
    return createdIsoLines;
}
var turf_isolines_default = isolines;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/kinks/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_kinks_default),
    "kinks": (()=>kinks)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
function kinks(featureIn) {
    let coordinates;
    let feature;
    const results = {
        type: "FeatureCollection",
        features: []
    };
    if (featureIn.type === "Feature") {
        feature = featureIn.geometry;
    } else {
        feature = featureIn;
    }
    if (feature.type === "LineString") {
        coordinates = [
            feature.coordinates
        ];
    } else if (feature.type === "MultiLineString") {
        coordinates = feature.coordinates;
    } else if (feature.type === "MultiPolygon") {
        coordinates = [].concat(...feature.coordinates);
    } else if (feature.type === "Polygon") {
        coordinates = feature.coordinates;
    } else {
        throw new Error("Input must be a LineString, MultiLineString, Polygon, or MultiPolygon Feature or Geometry");
    }
    coordinates.forEach((line1)=>{
        coordinates.forEach((line2)=>{
            for(let i = 0; i < line1.length - 1; i++){
                for(let k = i; k < line2.length - 1; k++){
                    if (line1 === line2) {
                        if (Math.abs(i - k) === 1) {
                            continue;
                        }
                        if (// segments are first and last segment of lineString
                        i === 0 && k === line1.length - 2 && // lineString is closed
                        line1[i][0] === line1[line1.length - 1][0] && line1[i][1] === line1[line1.length - 1][1]) {
                            continue;
                        }
                    }
                    const intersection = lineIntersects(line1[i][0], line1[i][1], line1[i + 1][0], line1[i + 1][1], line2[k][0], line2[k][1], line2[k + 1][0], line2[k + 1][1]);
                    if (intersection) {
                        results.features.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])([
                            intersection[0],
                            intersection[1]
                        ]));
                    }
                }
            }
        });
    });
    return results;
}
function lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
    let denominator;
    let a;
    let b;
    let numerator1;
    let numerator2;
    const result = {
        x: null,
        y: null,
        onLine1: false,
        onLine2: false
    };
    denominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY);
    if (denominator === 0) {
        if (result.x !== null && result.y !== null) {
            return result;
        } else {
            return false;
        }
    }
    a = line1StartY - line2StartY;
    b = line1StartX - line2StartX;
    numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;
    numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;
    a = numerator1 / denominator;
    b = numerator2 / denominator;
    result.x = line1StartX + a * (line1EndX - line1StartX);
    result.y = line1StartY + a * (line1EndY - line1StartY);
    if (a >= 0 && a <= 1) {
        result.onLine1 = true;
    }
    if (b >= 0 && b <= 1) {
        result.onLine2 = true;
    }
    if (result.onLine1 && result.onLine2) {
        return [
            result.x,
            result.y
        ];
    } else {
        return false;
    }
}
var turf_kinks_default = kinks;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/length/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_length_default),
    "length": (()=>length)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
function length(geojson, options = {}) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["segmentReduce"])(geojson, (previousValue, segment)=>{
        const coords = segment.geometry.coordinates;
        return previousValue + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distance"])(coords[0], coords[1], options);
    }, 0);
}
var turf_length_default = length;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/line-arc/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_line_arc_default),
    "lineArc": (()=>lineArc)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/destination/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$circle$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/circle/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
function lineArc(center, radius, bearing1, bearing2, options = {}) {
    const steps = options.steps || 64;
    const angle1 = convertAngleTo360(bearing1);
    const angle2 = convertAngleTo360(bearing2);
    const properties = !Array.isArray(center) && center.type === "Feature" ? center.properties : {};
    if (angle1 === angle2) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineString"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$circle$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["circle"])(center, radius, options).geometry.coordinates[0], properties);
    }
    const arcStartDegree = angle1;
    const arcEndDegree = angle1 < angle2 ? angle2 : angle2 + 360;
    let alpha = arcStartDegree;
    const coordinates = [];
    let i = 0;
    const arcStep = (arcEndDegree - arcStartDegree) / steps;
    while(alpha <= arcEndDegree){
        coordinates.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["destination"])(center, radius, alpha, options).geometry.coordinates);
        i++;
        alpha = arcStartDegree + i * arcStep;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineString"])(coordinates, properties);
}
function convertAngleTo360(alpha) {
    let beta = alpha % 360;
    if (beta < 0) {
        beta += 360;
    }
    return beta;
}
var turf_line_arc_default = lineArc;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/line-slice-along/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.js
__turbopack_esm__({
    "default": (()=>turf_line_slice_along_default),
    "lineSliceAlong": (()=>lineSliceAlong)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bearing/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/destination/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
function lineSliceAlong(line, startDist, stopDist, options) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    var coords;
    var slice = [];
    if (line.type === "Feature") coords = line.geometry.coordinates;
    else if (line.type === "LineString") coords = line.coordinates;
    else throw new Error("input must be a LineString Feature or Geometry");
    var origCoordsLength = coords.length;
    var travelled = 0;
    var overshot, direction, interpolated;
    for(var i = 0; i < coords.length; i++){
        if (startDist >= travelled && i === coords.length - 1) break;
        else if (travelled > startDist && slice.length === 0) {
            overshot = startDist - travelled;
            if (!overshot) {
                slice.push(coords[i]);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineString"])(slice);
            }
            direction = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bearing"])(coords[i], coords[i - 1]) - 180;
            interpolated = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["destination"])(coords[i], overshot, direction, options);
            slice.push(interpolated.geometry.coordinates);
        }
        if (travelled >= stopDist) {
            overshot = stopDist - travelled;
            if (!overshot) {
                slice.push(coords[i]);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineString"])(slice);
            }
            direction = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bearing"])(coords[i], coords[i - 1]) - 180;
            interpolated = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["destination"])(coords[i], overshot, direction, options);
            slice.push(interpolated.geometry.coordinates);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineString"])(slice);
        }
        if (travelled >= startDist) {
            slice.push(coords[i]);
        }
        if (i === coords.length - 1) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineString"])(slice);
        }
        travelled += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distance"])(coords[i], coords[i + 1], options);
    }
    if (travelled < startDist && coords.length === origCoordsLength) throw new Error("Start position is beyond line");
    var last = coords[coords.length - 1];
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineString"])([
        last,
        last
    ]);
}
var turf_line_slice_along_default = lineSliceAlong;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/line-chunk/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.js
__turbopack_esm__({
    "default": (()=>turf_line_chunk_default),
    "lineChunk": (()=>lineChunk)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$length$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/length/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$slice$2d$along$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-slice-along/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
function lineChunk(geojson, segmentLength, options) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    var units = options.units;
    var reverse = options.reverse;
    if (!geojson) throw new Error("geojson is required");
    if (segmentLength <= 0) throw new Error("segmentLength must be greater than 0");
    var results = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flattenEach"])(geojson, function(feature) {
        if (reverse) feature.geometry.coordinates = feature.geometry.coordinates.reverse();
        sliceLineSegments(feature, segmentLength, units, function(segment) {
            results.push(segment);
        });
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(results);
}
function sliceLineSegments(line, segmentLength, units, callback) {
    var lineLength = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$length$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["length"])(line, {
        units
    });
    if (lineLength <= segmentLength) return callback(line);
    var numberOfSegments = lineLength / segmentLength;
    if (!Number.isInteger(numberOfSegments)) {
        numberOfSegments = Math.floor(numberOfSegments) + 1;
    }
    for(var i = 0; i < numberOfSegments; i++){
        var outline = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$slice$2d$along$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineSliceAlong"])(line, segmentLength * i, segmentLength * (i + 1), {
            units
        });
        callback(outline, i);
    }
}
var turf_line_chunk_default = lineChunk;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/line-offset/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.js
__turbopack_esm__({
    "default": (()=>turf_line_offset_default),
    "lineOffset": (()=>lineOffset)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
// lib/intersection.js
function ab(segment) {
    var start = segment[0];
    var end = segment[1];
    return [
        end[0] - start[0],
        end[1] - start[1]
    ];
}
function crossProduct(v1, v2) {
    return v1[0] * v2[1] - v2[0] * v1[1];
}
function add(v1, v2) {
    return [
        v1[0] + v2[0],
        v1[1] + v2[1]
    ];
}
function sub(v1, v2) {
    return [
        v1[0] - v2[0],
        v1[1] - v2[1]
    ];
}
function scalarMult(s, v) {
    return [
        s * v[0],
        s * v[1]
    ];
}
function intersectSegments(a, b) {
    var p = a[0];
    var r = ab(a);
    var q = b[0];
    var s = ab(b);
    var cross = crossProduct(r, s);
    var qmp = sub(q, p);
    var numerator = crossProduct(qmp, s);
    var t = numerator / cross;
    var intersection2 = add(p, scalarMult(t, r));
    return intersection2;
}
function isParallel(a, b) {
    var r = ab(a);
    var s = ab(b);
    return crossProduct(r, s) === 0;
}
function intersection(a, b) {
    if (isParallel(a, b)) return false;
    return intersectSegments(a, b);
}
// index.js
function lineOffset(geojson, distance, options) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    var units = options.units;
    if (!geojson) throw new Error("geojson is required");
    if (distance === void 0 || distance === null || isNaN(distance)) throw new Error("distance is required");
    var type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getType"])(geojson);
    var properties = geojson.properties;
    switch(type){
        case "LineString":
            return lineOffsetFeature(geojson, distance, units);
        case "MultiLineString":
            var coords = [];
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flattenEach"])(geojson, function(feature) {
                coords.push(lineOffsetFeature(feature, distance, units).geometry.coordinates);
            });
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["multiLineString"])(coords, properties);
        default:
            throw new Error("geometry " + type + " is not supported");
    }
}
function lineOffsetFeature(line, distance, units) {
    var segments = [];
    var offsetDegrees = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lengthToDegrees"])(distance, units);
    var coords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(line);
    var finalCoords = [];
    coords.forEach(function(currentCoords, index) {
        if (index !== coords.length - 1) {
            var segment = processSegment(currentCoords, coords[index + 1], offsetDegrees);
            segments.push(segment);
            if (index > 0) {
                var seg2Coords = segments[index - 1];
                var intersects = intersection(segment, seg2Coords);
                if (intersects !== false) {
                    seg2Coords[1] = intersects;
                    segment[0] = intersects;
                }
                finalCoords.push(seg2Coords[0]);
                if (index === coords.length - 2) {
                    finalCoords.push(segment[0]);
                    finalCoords.push(segment[1]);
                }
            }
            if (coords.length === 2) {
                finalCoords.push(segment[0]);
                finalCoords.push(segment[1]);
            }
        }
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineString"])(finalCoords, line.properties);
}
function processSegment(point1, point2, offset) {
    var L = Math.sqrt((point1[0] - point2[0]) * (point1[0] - point2[0]) + (point1[1] - point2[1]) * (point1[1] - point2[1]));
    var out1x = point1[0] + offset * (point2[1] - point1[1]) / L;
    var out2x = point2[0] + offset * (point2[1] - point1[1]) / L;
    var out1y = point1[1] + offset * (point1[0] - point2[0]) / L;
    var out2y = point2[1] + offset * (point1[0] - point2[0]) / L;
    return [
        [
            out1x,
            out1y
        ],
        [
            out2x,
            out2y
        ]
    ];
}
var turf_line_offset_default = lineOffset;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/line-slice/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.js
__turbopack_esm__({
    "default": (()=>turf_line_slice_default),
    "lineSlice": (()=>lineSlice)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/nearest-point-on-line/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
function lineSlice(startPt, stopPt, line) {
    var coords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(line);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getType"])(line) !== "LineString") throw new Error("line must be a LineString");
    var startVertex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearestPointOnLine"])(line, startPt);
    var stopVertex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearestPointOnLine"])(line, stopPt);
    var ends;
    if (startVertex.properties.index <= stopVertex.properties.index) {
        ends = [
            startVertex,
            stopVertex
        ];
    } else {
        ends = [
            stopVertex,
            startVertex
        ];
    }
    var clipCoords = [
        ends[0].geometry.coordinates
    ];
    for(var i = ends[0].properties.index + 1; i < ends[1].properties.index + 1; i++){
        clipCoords.push(coords[i]);
    }
    clipCoords.push(ends[1].geometry.coordinates);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineString"])(clipCoords, line.properties);
}
var turf_line_slice_default = lineSlice;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/truncate/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_truncate_default),
    "truncate": (()=>truncate)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
function truncate(geojson, options) {
    options = options != null ? options : {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    var precision = options.precision;
    var coordinates = options.coordinates;
    var mutate = options.mutate;
    precision = precision === void 0 || precision === null || isNaN(precision) ? 6 : precision;
    coordinates = coordinates === void 0 || coordinates === null || isNaN(coordinates) ? 3 : coordinates;
    if (!geojson) throw new Error("<geojson> is required");
    if (typeof precision !== "number") throw new Error("<precision> must be a number");
    if (typeof coordinates !== "number") throw new Error("<coordinates> must be a number");
    if (mutate === false || mutate === void 0) geojson = JSON.parse(JSON.stringify(geojson));
    var factor = Math.pow(10, precision);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["coordEach"])(geojson, function(coords) {
        truncateCoords(coords, factor, coordinates);
    });
    return geojson;
}
function truncateCoords(coords, factor, coordinates) {
    if (coords.length > coordinates) coords.splice(coordinates, coords.length);
    for(var i = 0; i < coords.length; i++){
        coords[i] = Math.round(coords[i] * factor) / factor;
    }
    return coords;
}
var turf_truncate_default = truncate;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/square/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_square_default),
    "square": (()=>square)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-ssr] (ecmascript)");
;
function square(bbox) {
    var west = bbox[0];
    var south = bbox[1];
    var east = bbox[2];
    var north = bbox[3];
    var horizontalDistance = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distance"])(bbox.slice(0, 2), [
        east,
        south
    ]);
    var verticalDistance = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distance"])(bbox.slice(0, 2), [
        west,
        north
    ]);
    if (horizontalDistance >= verticalDistance) {
        var verticalMidpoint = (south + north) / 2;
        return [
            west,
            verticalMidpoint - (east - west) / 2,
            east,
            verticalMidpoint + (east - west) / 2
        ];
    } else {
        var horizontalMidpoint = (west + east) / 2;
        return [
            horizontalMidpoint - (north - south) / 2,
            south,
            horizontalMidpoint + (north - south) / 2,
            north
        ];
    }
}
var turf_square_default = square;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/line-split/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.js
__turbopack_esm__({
    "default": (()=>turf_line_split_default),
    "lineSplit": (()=>lineSplit)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$truncate$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/truncate/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-intersect/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$geojson$2d$rbush$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/geojson-rbush/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$square$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/square/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$segment$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-segment/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/nearest-point-on-line/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
function lineSplit(line, splitter) {
    if (!line) throw new Error("line is required");
    if (!splitter) throw new Error("splitter is required");
    var lineType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getType"])(line);
    var splitterType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getType"])(splitter);
    if (lineType !== "LineString") throw new Error("line must be LineString");
    if (splitterType === "FeatureCollection") throw new Error("splitter cannot be a FeatureCollection");
    if (splitterType === "GeometryCollection") throw new Error("splitter cannot be a GeometryCollection");
    var truncatedSplitter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$truncate$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["truncate"])(splitter, {
        precision: 7
    });
    switch(splitterType){
        case "Point":
            return splitLineWithPoint(line, truncatedSplitter);
        case "MultiPoint":
            return splitLineWithPoints(line, truncatedSplitter);
        case "LineString":
        case "MultiLineString":
        case "Polygon":
        case "MultiPolygon":
            return splitLineWithPoints(line, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineIntersect"])(line, truncatedSplitter, {
                ignoreSelfIntersections: true
            }));
    }
}
function splitLineWithPoints(line, splitter) {
    var results = [];
    var tree = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$geojson$2d$rbush$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["geojsonRbush"])();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flattenEach"])(splitter, function(point) {
        results.forEach(function(feature, index) {
            feature.id = index;
        });
        if (!results.length) {
            results = splitLineWithPoint(line, point).features;
            results.forEach(function(feature) {
                if (!feature.bbox) feature.bbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$square$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["square"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bbox"])(feature));
            });
            tree.load((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(results));
        } else {
            var search = tree.search(point);
            if (search.features.length) {
                var closestLine = findClosestFeature(point, search);
                results = results.filter(function(feature) {
                    return feature.id !== closestLine.id;
                });
                tree.remove(closestLine);
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"])(splitLineWithPoint(closestLine, point), function(line2) {
                    results.push(line2);
                    tree.insert(line2);
                });
            }
        }
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(results);
}
function splitLineWithPoint(line, splitter) {
    var results = [];
    var startPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(line)[0];
    var endPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(line)[line.geometry.coordinates.length - 1];
    if (pointsEquals(startPoint, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(splitter)) || pointsEquals(endPoint, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(splitter))) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])([
        line
    ]);
    var tree = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$geojson$2d$rbush$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["geojsonRbush"])();
    var segments = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$segment$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineSegment"])(line);
    tree.load(segments);
    var search = tree.search(splitter);
    if (!search.features.length) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])([
        line
    ]);
    var closestSegment = findClosestFeature(splitter, search);
    var initialValue = [
        startPoint
    ];
    var lastCoords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureReduce"])(segments, function(previous, current, index) {
        var currentCoords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(current)[1];
        var splitterCoords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(splitter);
        if (index === closestSegment.id) {
            previous.push(splitterCoords);
            results.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineString"])(previous));
            if (pointsEquals(splitterCoords, currentCoords)) return [
                splitterCoords
            ];
            return [
                splitterCoords,
                currentCoords
            ];
        } else {
            previous.push(currentCoords);
            return previous;
        }
    }, initialValue);
    if (lastCoords.length > 1) {
        results.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineString"])(lastCoords));
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(results);
}
function findClosestFeature(point, lines) {
    if (!lines.features.length) throw new Error("lines must contain features");
    if (lines.features.length === 1) return lines.features[0];
    var closestFeature;
    var closestDistance = Infinity;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"])(lines, function(segment) {
        var pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearestPointOnLine"])(segment, point);
        var dist = pt.properties.dist;
        if (dist < closestDistance) {
            closestFeature = segment;
            closestDistance = dist;
        }
    });
    return closestFeature;
}
function pointsEquals(pt1, pt2) {
    return pt1[0] === pt2[0] && pt1[1] === pt2[1];
}
var turf_line_split_default = lineSplit;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/line-to-polygon/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_line_to_polygon_default),
    "lineToPolygon": (()=>lineToPolygon)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
function lineToPolygon(lines, options = {}) {
    var _a, _b, _c;
    var properties = options.properties;
    var autoComplete = (_a = options.autoComplete) != null ? _a : true;
    var orderCoords = (_b = options.orderCoords) != null ? _b : true;
    var mutate = (_c = options.mutate) != null ? _c : false;
    if (!mutate) {
        lines = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(lines);
    }
    switch(lines.type){
        case "FeatureCollection":
            var coords = [];
            lines.features.forEach(function(line) {
                coords.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(lineStringToPolygon(line, {}, autoComplete, orderCoords)));
            });
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["multiPolygon"])(coords, properties);
        default:
            return lineStringToPolygon(lines, properties, autoComplete, orderCoords);
    }
}
function lineStringToPolygon(line, properties, autoComplete, orderCoords) {
    properties = properties ? properties : line.type === "Feature" ? line.properties : {};
    var geom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getGeom"])(line);
    var coords = geom.coordinates;
    var type = geom.type;
    if (!coords.length) throw new Error("line must contain coordinates");
    switch(type){
        case "LineString":
            if (autoComplete) coords = autoCompleteCoords(coords);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])([
                coords
            ], properties);
        case "MultiLineString":
            var multiCoords = [];
            var largestArea = 0;
            coords.forEach(function(coord) {
                if (autoComplete) coord = autoCompleteCoords(coord);
                if (orderCoords) {
                    var area = calculateArea((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bbox"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineString"])(coord)));
                    if (area > largestArea) {
                        multiCoords.unshift(coord);
                        largestArea = area;
                    } else multiCoords.push(coord);
                } else {
                    multiCoords.push(coord);
                }
            });
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])(multiCoords, properties);
        default:
            throw new Error("geometry type " + type + " is not supported");
    }
}
function autoCompleteCoords(coords) {
    var first = coords[0];
    var x1 = first[0];
    var y1 = first[1];
    var last = coords[coords.length - 1];
    var x2 = last[0];
    var y2 = last[1];
    if (x1 !== x2 || y1 !== y2) {
        coords.push(first);
    }
    return coords;
}
function calculateArea(bbox) {
    var west = bbox[0];
    var south = bbox[1];
    var east = bbox[2];
    var north = bbox[3];
    return Math.abs(west - east) * Math.abs(south - north);
}
var turf_line_to_polygon_default = lineToPolygon;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/mask/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_mask_default),
    "mask": (()=>mask)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/polyclip-ts/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
function mask(polygon, mask2, options) {
    var _a;
    const mutate = (_a = options == null ? void 0 : options.mutate) != null ? _a : false;
    let maskTemplate = mask2;
    if (mask2 && mutate === false) {
        maskTemplate = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(mask2);
    }
    const maskPolygon = createMask(maskTemplate);
    let polygonOuters = null;
    if (polygon.type === "FeatureCollection") {
        polygonOuters = unionFc(polygon);
    } else if (polygon.type === "Feature") {
        polygonOuters = createGeomFromPolygonClippingOutput(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.union(polygon.geometry.coordinates));
    } else {
        polygonOuters = createGeomFromPolygonClippingOutput(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.union(polygon.coordinates));
    }
    polygonOuters.geometry.coordinates.forEach(function(contour) {
        maskPolygon.geometry.coordinates.push(contour[0]);
    });
    return maskPolygon;
}
function unionFc(fc) {
    const unioned = fc.features.length === 2 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.union(fc.features[0].geometry.coordinates, fc.features[1].geometry.coordinates) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.union.apply(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__, fc.features.map(function(f) {
        return f.geometry.coordinates;
    }));
    return createGeomFromPolygonClippingOutput(unioned);
}
function createGeomFromPolygonClippingOutput(unioned) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["multiPolygon"])(unioned);
}
function createMask(mask2) {
    const world = [
        [
            [
                180,
                90
            ],
            [
                -180,
                90
            ],
            [
                -180,
                -90
            ],
            [
                180,
                -90
            ],
            [
                180,
                90
            ]
        ]
    ];
    let coordinates = world;
    if (mask2) {
        if (mask2.type === "Feature") {
            coordinates = mask2.geometry.coordinates;
        } else {
            coordinates = mask2.coordinates;
        }
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])(coordinates);
}
var turf_mask_default = mask;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/midpoint/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_midpoint_default),
    "midpoint": (()=>midpoint)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bearing/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/destination/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
function midpoint(point1, point2) {
    const dist = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distance"])(point1, point2);
    const heading = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bearing"])(point1, point2);
    const midpoint2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["destination"])(point1, dist / 2, heading);
    return midpoint2;
}
var turf_midpoint_default = midpoint;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/moran-index/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_moran_index_default),
    "moranIndex": (()=>moranIndex)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2d$weight$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance-weight/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
function moranIndex(fc, options) {
    var _a, _b;
    const inputField = options.inputField;
    const threshold = options.threshold || 1e5;
    const p = options.p || 2;
    const binary = (_a = options.binary) != null ? _a : false;
    const alpha = options.alpha || -1;
    const standardization = (_b = options.standardization) != null ? _b : true;
    const weight = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2d$weight$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distanceWeight"])(fc, {
        alpha,
        binary,
        p,
        standardization,
        threshold
    });
    const y = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"])(fc, (feature)=>{
        const feaProperties = feature.properties || {};
        y.push(feaProperties[inputField]);
    });
    const yMean = mean(y);
    const yVar = variance(y);
    let weightSum = 0;
    let s0 = 0;
    let s1 = 0;
    let s2 = 0;
    const n = weight.length;
    for(let i = 0; i < n; i++){
        let subS2 = 0;
        for(let j = 0; j < n; j++){
            weightSum += weight[i][j] * (y[i] - yMean) * (y[j] - yMean);
            s0 += weight[i][j];
            s1 += Math.pow(weight[i][j] + weight[j][i], 2);
            subS2 += weight[i][j] + weight[j][i];
        }
        s2 += Math.pow(subS2, 2);
    }
    s1 = 0.5 * s1;
    const moranIndex2 = weightSum / s0 / yVar;
    const expectedMoranIndex = -1 / (n - 1);
    const vNum = n * n * s1 - n * s2 + 3 * (s0 * s0);
    const vDen = (n - 1) * (n + 1) * (s0 * s0);
    const vNorm = vNum / vDen - expectedMoranIndex * expectedMoranIndex;
    const stdNorm = Math.sqrt(vNorm);
    const zNorm = (moranIndex2 - expectedMoranIndex) / stdNorm;
    return {
        expectedMoranIndex,
        moranIndex: moranIndex2,
        stdNorm,
        zNorm
    };
}
function mean(y) {
    let sum = 0;
    for (const item of y){
        sum += item;
    }
    return sum / y.length;
}
function variance(y) {
    const yMean = mean(y);
    let sum = 0;
    for (const item of y){
        sum += Math.pow(item - yMean, 2);
    }
    return sum / y.length;
}
var turf_moran_index_default = moranIndex;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/nearest-point/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>turf_nearest_point_default),
    "nearestPoint": (()=>nearestPoint)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-ssr] (ecmascript)");
// index.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-ssr] (ecmascript)");
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));
;
;
;
function nearestPoint(targetPoint, points, options = {}) {
    if (!targetPoint) throw new Error("targetPoint is required");
    if (!points) throw new Error("points is required");
    let minDist = Infinity;
    let bestFeatureIndex = 0;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"])(points, (pt, featureIndex)=>{
        const distanceToPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distance"])(targetPoint, pt, options);
        if (distanceToPoint < minDist) {
            bestFeatureIndex = featureIndex;
            minDist = distanceToPoint;
        }
    });
    const nearestPoint2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(points.features[bestFeatureIndex]);
    return __spreadProps(__spreadValues({}, nearestPoint2), {
        properties: __spreadProps(__spreadValues({}, nearestPoint2.properties), {
            featureIndex: bestFeatureIndex,
            distanceToPoint: minDist
        })
    });
}
var turf_nearest_point_default = nearestPoint;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/point-to-line-distance/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_point_to_line_distance_default),
    "pointToLineDistance": (()=>pointToLineDistance)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rhumb-distance/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/nearest-point-on-line/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
;
function pointToLineDistance(pt, line, options = {}) {
    var _a, _b;
    const method = (_a = options.method) != null ? _a : "geodesic";
    const units = (_b = options.units) != null ? _b : "kilometers";
    if (!pt) {
        throw new Error("pt is required");
    }
    if (Array.isArray(pt)) {
        pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])(pt);
    } else if (pt.type === "Point") {
        pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["feature"])(pt);
    } else {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureOf"])(pt, "Point", "point");
    }
    if (!line) {
        throw new Error("line is required");
    }
    if (Array.isArray(line)) {
        line = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineString"])(line);
    } else if (line.type === "LineString") {
        line = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["feature"])(line);
    } else {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureOf"])(line, "LineString", "line");
    }
    let distance = Infinity;
    const p = pt.geometry.coordinates;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["segmentEach"])(line, (segment)=>{
        if (segment) {
            const a = segment.geometry.coordinates[0];
            const b = segment.geometry.coordinates[1];
            const d = distanceToSegment(p, a, b, {
                method
            });
            if (d < distance) {
                distance = d;
            }
        }
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["convertLength"])(distance, "degrees", units);
}
function distanceToSegment(p, a, b, options) {
    if (options.method === "geodesic") {
        const nearest = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearestPointOnLine"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineString"])([
            a,
            b
        ]).geometry, p, {
            units: "degrees"
        });
        return nearest.properties.dist;
    }
    const v = [
        b[0] - a[0],
        b[1] - a[1]
    ];
    const w = [
        p[0] - a[0],
        p[1] - a[1]
    ];
    const c1 = dot(w, v);
    if (c1 <= 0) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rhumbDistance"])(p, a, {
            units: "degrees"
        });
    }
    const c2 = dot(v, v);
    if (c2 <= c1) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rhumbDistance"])(p, b, {
            units: "degrees"
        });
    }
    const b2 = c1 / c2;
    const Pb = [
        a[0] + b2 * v[0],
        a[1] + b2 * v[1]
    ];
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rhumbDistance"])(p, Pb, {
        units: "degrees"
    });
}
function dot(u, v) {
    return u[0] * v[0] + u[1] * v[1];
}
var turf_point_to_line_distance_default = pointToLineDistance;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/nearest-point-to-line/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>turf_nearest_point_to_line_default),
    "nearestPointToLine": (()=>nearestPointToLine)
});
// index.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$point$2d$to$2d$line$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/point-to-line-distance/dist/esm/index.js [app-ssr] (ecmascript)");
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
;
;
;
function nearestPointToLine(points, line, options = {}) {
    const units = options.units;
    const properties = options.properties || {};
    const pts = normalize(points);
    if (!pts.features.length) {
        throw new Error("points must contain features");
    }
    if (!line) {
        throw new Error("line is required");
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getType"])(line) !== "LineString") {
        throw new Error("line must be a LineString");
    }
    let dist = Infinity;
    let pt = null;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"])(pts, (point)=>{
        const d = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$point$2d$to$2d$line$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pointToLineDistance"])(point, line, {
            units
        });
        if (d < dist) {
            dist = d;
            pt = point;
        }
    });
    if (pt) {
        pt.properties = __spreadValues(__spreadValues(__spreadValues({}, {
            dist
        }), pt.properties), properties);
    }
    return pt;
}
function normalize(points) {
    const features = [];
    const type = points.geometry ? points.geometry.type : points.type;
    switch(type){
        case "GeometryCollection":
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["geomEach"])(points, (geom)=>{
                if (geom.type === "Point") {
                    features.push({
                        type: "Feature",
                        properties: {},
                        geometry: geom
                    });
                }
            });
            return {
                type: "FeatureCollection",
                features
            };
        case "FeatureCollection":
            points.features = points.features.filter((feature)=>{
                return feature.geometry.type === "Point";
            });
            return points;
        default:
            throw new Error("points must be a Point Collection");
    }
}
var turf_nearest_point_to_line_default = nearestPointToLine;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/planepoint/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_planepoint_default),
    "planepoint": (()=>planepoint)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
;
function planepoint(point, triangle) {
    const coord = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(point);
    const geom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getGeom"])(triangle);
    const coords = geom.coordinates;
    const outer = coords[0];
    if (outer.length < 4) throw new Error("OuterRing of a Polygon must have 4 or more Positions.");
    const properties = triangle.type === "Feature" && triangle.properties || {};
    const a = properties.a;
    const b = properties.b;
    const c = properties.c;
    const x = coord[0];
    const y = coord[1];
    const x1 = outer[0][0];
    const y1 = outer[0][1];
    const z1 = a !== void 0 ? a : outer[0][2];
    const x2 = outer[1][0];
    const y2 = outer[1][1];
    const z2 = b !== void 0 ? b : outer[1][2];
    const x3 = outer[2][0];
    const y3 = outer[2][1];
    const z3 = c !== void 0 ? c : outer[2][2];
    const z = (z3 * (x - x1) * (y - y2) + z1 * (x - x2) * (y - y3) + z2 * (x - x3) * (y - y1) - z2 * (x - x1) * (y - y3) - z3 * (x - x2) * (y - y1) - z1 * (x - x3) * (y - y2)) / ((x - x1) * (y - y2) + (x - x2) * (y - y3) + (x - x3) * (y - y1) - (x - x1) * (y - y3) - (x - x2) * (y - y1) - (x - x3) * (y - y2));
    return z;
}
var turf_planepoint_default = planepoint;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/point-on-feature/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_point_on_feature_default),
    "pointOnFeature": (()=>pointOnFeature)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/center/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$explode$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/explode/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/nearest-point/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
;
function pointOnFeature(geojson) {
    const fc = normalize(geojson);
    const cent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["center"])(fc);
    let onSurface = false;
    let i = 0;
    while(!onSurface && i < fc.features.length){
        const geom = fc.features[i].geometry;
        let x, y, x1, y1, x2, y2;
        let onLine = false;
        if (geom.type === "Point") {
            if (cent.geometry.coordinates[0] === geom.coordinates[0] && cent.geometry.coordinates[1] === geom.coordinates[1]) {
                onSurface = true;
            }
        } else if (geom.type === "MultiPoint") {
            let onMultiPoint = false;
            let k = 0;
            while(!onMultiPoint && k < geom.coordinates.length){
                if (cent.geometry.coordinates[0] === geom.coordinates[k][0] && cent.geometry.coordinates[1] === geom.coordinates[k][1]) {
                    onSurface = true;
                    onMultiPoint = true;
                }
                k++;
            }
        } else if (geom.type === "LineString") {
            let k = 0;
            while(!onLine && k < geom.coordinates.length - 1){
                x = cent.geometry.coordinates[0];
                y = cent.geometry.coordinates[1];
                x1 = geom.coordinates[k][0];
                y1 = geom.coordinates[k][1];
                x2 = geom.coordinates[k + 1][0];
                y2 = geom.coordinates[k + 1][1];
                if (pointOnSegment(x, y, x1, y1, x2, y2)) {
                    onLine = true;
                    onSurface = true;
                }
                k++;
            }
        } else if (geom.type === "MultiLineString") {
            let j = 0;
            while(j < geom.coordinates.length){
                onLine = false;
                let k = 0;
                const line = geom.coordinates[j];
                while(!onLine && k < line.length - 1){
                    x = cent.geometry.coordinates[0];
                    y = cent.geometry.coordinates[1];
                    x1 = line[k][0];
                    y1 = line[k][1];
                    x2 = line[k + 1][0];
                    y2 = line[k + 1][1];
                    if (pointOnSegment(x, y, x1, y1, x2, y2)) {
                        onLine = true;
                        onSurface = true;
                    }
                    k++;
                }
                j++;
            }
        } else if (geom.type === "Polygon" || geom.type === "MultiPolygon") {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(cent, geom)) {
                onSurface = true;
            }
        }
        i++;
    }
    if (onSurface) {
        return cent;
    } else {
        const vertices = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])([]);
        for(let f = 0; f < fc.features.length; f++){
            vertices.features = vertices.features.concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$explode$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["explode"])(fc.features[f]).features);
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearestPoint"])(cent, vertices).geometry.coordinates);
    }
}
function normalize(geojson) {
    if (geojson.type !== "FeatureCollection") {
        if (geojson.type !== "Feature") {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])([
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["feature"])(geojson)
            ]);
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])([
            geojson
        ]);
    }
    return geojson;
}
function pointOnSegment(x, y, x1, y1, x2, y2) {
    const ab = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    const ap = Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));
    const pb = Math.sqrt((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y));
    return ab === ap + pb;
}
var turf_point_on_feature_default = pointOnFeature;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/point-to-polygon-distance/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_point_to_polygon_distance_default),
    "pointToPolygonDistance": (()=>pointToPolygonDistance)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygon$2d$to$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/polygon-to-line/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$point$2d$to$2d$line$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/point-to-line-distance/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
function pointToPolygonDistance(point, polygonOrMultiPolygon, options = {}) {
    var _a, _b;
    const method = (_a = options.method) != null ? _a : "geodesic";
    const units = (_b = options.units) != null ? _b : "kilometers";
    if (!point) throw new Error("point is required");
    if (!polygonOrMultiPolygon) throw new Error("polygon or multi-polygon is required");
    const geom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getGeom"])(polygonOrMultiPolygon);
    if (geom.type === "MultiPolygon") {
        const distances = geom.coordinates.map((coords)=>pointToPolygonDistance(point, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])(coords), {
                method,
                units
            }));
        return Math.min(...distances.map(Math.abs)) * ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(point, polygonOrMultiPolygon) ? -1 : 1);
    }
    if (geom.coordinates.length > 1) {
        const [exteriorDistance, ...interiorDistances] = geom.coordinates.map((coords)=>pointToPolygonDistance(point, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])([
                coords
            ]), {
                method,
                units
            }));
        if (exteriorDistance >= 0) return exteriorDistance;
        const smallestInteriorDistance = Math.min(...interiorDistances);
        if (smallestInteriorDistance < 0) return Math.abs(smallestInteriorDistance);
        return Math.min(smallestInteriorDistance, Math.abs(exteriorDistance));
    }
    const lines = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygon$2d$to$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygonToLine"])(geom);
    let minDistance = Infinity;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flattenEach"])(lines, (feature)=>{
        minDistance = Math.min(minDistance, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$point$2d$to$2d$line$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pointToLineDistance"])(point, feature, {
            method,
            units
        }));
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(point, geom) ? -minDistance : minDistance;
}
var turf_point_to_polygon_distance_default = pointToPolygonDistance;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/points-within-polygon/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_points_within_polygon_default),
    "pointsWithinPolygon": (()=>pointsWithinPolygon)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
function pointsWithinPolygon(points, polygons) {
    const results = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"])(points, function(point) {
        let contained = false;
        if (point.geometry.type === "Point") {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["geomEach"])(polygons, function(polygon) {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(point, polygon)) {
                    contained = true;
                }
            });
            if (contained) {
                results.push(point);
            }
        } else if (point.geometry.type === "MultiPoint") {
            var pointsWithin = [];
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["geomEach"])(polygons, function(polygon) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["coordEach"])(point, function(pointCoord) {
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(pointCoord, polygon)) {
                        contained = true;
                        pointsWithin.push(pointCoord);
                    }
                });
            });
            if (contained) {
                results.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["multiPoint"])(pointsWithin, point.properties));
            }
        } else {
            throw new Error("Input geometry must be a Point or MultiPoint");
        }
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(results);
}
var turf_points_within_polygon_default = pointsWithinPolygon;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/polygon-smooth/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_polygon_smooth_default),
    "polygonSmooth": (()=>polygonSmooth)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
function polygonSmooth(inputPolys, options) {
    options = options || {};
    options.iterations = options.iterations || 1;
    const { iterations } = options;
    const outPolys = [];
    if (!inputPolys) throw new Error("inputPolys is required");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["geomEach"])(inputPolys, function(geom, geomIndex, properties) {
        if (geom.type === "Polygon") {
            let outCoords = [
                []
            ];
            for(let i = 0; i < iterations; i++){
                let tempOutput = [];
                let poly = geom;
                if (i > 0) {
                    poly = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])(outCoords).geometry;
                }
                processPolygon(poly, tempOutput);
                outCoords = tempOutput.slice(0);
            }
            outPolys.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])(outCoords, properties));
        } else if (geom.type === "MultiPolygon") {
            let outCoords = [
                [
                    []
                ]
            ];
            for(let y = 0; y < iterations; y++){
                let tempOutput = [];
                let poly = geom;
                if (y > 0) {
                    poly = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["multiPolygon"])(outCoords).geometry;
                }
                processMultiPolygon(poly, tempOutput);
                outCoords = tempOutput.slice(0);
            }
            outPolys.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["multiPolygon"])(outCoords, properties));
        } else {
            throw new Error("geometry is invalid, must be Polygon or MultiPolygon");
        }
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(outPolys);
}
function processPolygon(poly, tempOutput) {
    var previousCoord;
    var previousGeometryIndex;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["coordEach"])(poly, function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
        if (previousGeometryIndex !== geometryIndex) {
            tempOutput.push([]);
        } else {
            var p0x = previousCoord[0];
            var p0y = previousCoord[1];
            var p1x = currentCoord[0];
            var p1y = currentCoord[1];
            tempOutput[geometryIndex].push([
                0.75 * p0x + 0.25 * p1x,
                0.75 * p0y + 0.25 * p1y
            ]);
            tempOutput[geometryIndex].push([
                0.25 * p0x + 0.75 * p1x,
                0.25 * p0y + 0.75 * p1y
            ]);
        }
        previousCoord = currentCoord;
        previousGeometryIndex = geometryIndex;
    }, false);
    tempOutput.forEach(function(ring) {
        ring.push(ring[0]);
    });
}
function processMultiPolygon(poly, tempOutput) {
    let previousCoord;
    let previousMultiFeatureIndex;
    let previousGeometryIndex;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["coordEach"])(poly, function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
        if (previousMultiFeatureIndex !== multiFeatureIndex) {
            tempOutput.push([
                []
            ]);
        } else if (previousGeometryIndex !== geometryIndex) {
            tempOutput[multiFeatureIndex].push([]);
        } else {
            var p0x = previousCoord[0];
            var p0y = previousCoord[1];
            var p1x = currentCoord[0];
            var p1y = currentCoord[1];
            tempOutput[multiFeatureIndex][geometryIndex].push([
                0.75 * p0x + 0.25 * p1x,
                0.75 * p0y + 0.25 * p1y
            ]);
            tempOutput[multiFeatureIndex][geometryIndex].push([
                0.25 * p0x + 0.75 * p1x,
                0.25 * p0y + 0.75 * p1y
            ]);
        }
        previousCoord = currentCoord;
        previousMultiFeatureIndex = multiFeatureIndex;
        previousGeometryIndex = geometryIndex;
    }, false);
    tempOutput.forEach(function(poly2) {
        poly2.forEach(function(ring) {
            ring.push(ring[0]);
        });
    });
}
var turf_polygon_smooth_default = polygonSmooth;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/polygon-tangents/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_polygon_tangents_default),
    "polygonTangents": (()=>polygonTangents)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/nearest-point/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$explode$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/explode/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
;
function polygonTangents(pt, polygon) {
    const pointCoords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(pt);
    const polyCoords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(polygon);
    let rtan = [];
    let ltan = [];
    let eprev;
    const bbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bbox"])(polygon);
    let nearestPtIndex = 0;
    let nearest = null;
    if (pointCoords[0] > bbox[0] && pointCoords[0] < bbox[2] && pointCoords[1] > bbox[1] && pointCoords[1] < bbox[3]) {
        nearest = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearestPoint"])(pt, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$explode$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["explode"])(polygon));
        nearestPtIndex = nearest.properties.featureIndex;
    }
    const type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getType"])(polygon);
    switch(type){
        case "Polygon":
            rtan = polyCoords[0][nearestPtIndex];
            ltan = polyCoords[0][0];
            if (nearest !== null) {
                if (nearest.geometry.coordinates[1] < pointCoords[1]) ltan = polyCoords[0][nearestPtIndex];
            }
            eprev = isLeft(polyCoords[0][0], polyCoords[0][polyCoords[0].length - 1], pointCoords);
            [rtan, ltan] = processPolygon(polyCoords[0], pointCoords, eprev, rtan, ltan);
            break;
        case "MultiPolygon":
            var closestFeature = 0;
            var closestVertex = 0;
            var verticesCounted = 0;
            for(var i = 0; i < polyCoords[0].length; i++){
                closestFeature = i;
                var verticeFound = false;
                for(var i2 = 0; i2 < polyCoords[0][i].length; i2++){
                    closestVertex = i2;
                    if (verticesCounted === nearestPtIndex) {
                        verticeFound = true;
                        break;
                    }
                    verticesCounted++;
                }
                if (verticeFound) break;
            }
            rtan = polyCoords[0][closestFeature][closestVertex];
            ltan = polyCoords[0][closestFeature][closestVertex];
            eprev = isLeft(polyCoords[0][0][0], polyCoords[0][0][polyCoords[0][0].length - 1], pointCoords);
            polyCoords.forEach(function(ring) {
                [rtan, ltan] = processPolygon(ring[0], pointCoords, eprev, rtan, ltan);
            });
            break;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])(rtan),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])(ltan)
    ]);
}
function processPolygon(polygonCoords, ptCoords, eprev, rtan, ltan) {
    for(let i = 0; i < polygonCoords.length; i++){
        const currentCoords = polygonCoords[i];
        let nextCoordPair = polygonCoords[i + 1];
        if (i === polygonCoords.length - 1) {
            nextCoordPair = polygonCoords[0];
        }
        const enext = isLeft(currentCoords, nextCoordPair, ptCoords);
        if (eprev <= 0 && enext > 0) {
            if (!isBelow(ptCoords, currentCoords, rtan)) {
                rtan = currentCoords;
            }
        } else if (eprev > 0 && enext <= 0) {
            if (!isAbove(ptCoords, currentCoords, ltan)) {
                ltan = currentCoords;
            }
        }
        eprev = enext;
    }
    return [
        rtan,
        ltan
    ];
}
function isAbove(point1, point2, point3) {
    return isLeft(point1, point2, point3) > 0;
}
function isBelow(point1, point2, point3) {
    return isLeft(point1, point2, point3) < 0;
}
function isLeft(point1, point2, point3) {
    return (point2[0] - point1[0]) * (point3[1] - point1[1]) - (point3[0] - point1[0]) * (point2[1] - point1[1]);
}
var turf_polygon_tangents_default = polygonTangents;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/polygonize/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_polygonize_default),
    "polygonize": (()=>polygonize)
});
// lib/util.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$envelope$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/envelope/dist/esm/index.js [app-ssr] (ecmascript)");
// lib/Graph.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
function mathSign(x) {
    return (x > 0) - (x < 0) || +x;
}
function orientationIndex(p1, p2, q) {
    const dx1 = p2[0] - p1[0], dy1 = p2[1] - p1[1], dx2 = q[0] - p2[0], dy2 = q[1] - p2[1];
    return mathSign(dx1 * dy2 - dx2 * dy1);
}
function envelopeIsEqual(env1, env2) {
    const envX1 = env1.geometry.coordinates[0].map((c)=>c[0]), envY1 = env1.geometry.coordinates[0].map((c)=>c[1]), envX2 = env2.geometry.coordinates[0].map((c)=>c[0]), envY2 = env2.geometry.coordinates[0].map((c)=>c[1]);
    return Math.max.apply(null, envX1) === Math.max.apply(null, envX2) && Math.max.apply(null, envY1) === Math.max.apply(null, envY2) && Math.min.apply(null, envX1) === Math.min.apply(null, envX2) && Math.min.apply(null, envY1) === Math.min.apply(null, envY2);
}
function envelopeContains(self, env) {
    return env.geometry.coordinates[0].every((c)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])(c), self));
}
function coordinatesEqual(coord1, coord2) {
    return coord1[0] === coord2[0] && coord1[1] === coord2[1];
}
// lib/Node.ts
var Node = class _Node {
    static buildId(coordinates) {
        return coordinates.join(",");
    }
    constructor(coordinates){
        this.id = _Node.buildId(coordinates);
        this.coordinates = coordinates;
        this.innerEdges = [];
        this.outerEdges = [];
        this.outerEdgesSorted = false;
    }
    removeInnerEdge(edge) {
        this.innerEdges = this.innerEdges.filter((e)=>e.from.id !== edge.from.id);
    }
    removeOuterEdge(edge) {
        this.outerEdges = this.outerEdges.filter((e)=>e.to.id !== edge.to.id);
    }
    /**
   * Outer edges are stored CCW order.
   *
   * @memberof Node
   * @param {Edge} edge - Edge to add as an outerEdge.
   */ addOuterEdge(edge) {
        this.outerEdges.push(edge);
        this.outerEdgesSorted = false;
    }
    /**
   * Sorts outer edges in CCW way.
   *
   * @memberof Node
   * @private
   */ sortOuterEdges() {
        if (!this.outerEdgesSorted) {
            this.outerEdges.sort((a, b)=>{
                const aNode = a.to, bNode = b.to;
                if (aNode.coordinates[0] - this.coordinates[0] >= 0 && bNode.coordinates[0] - this.coordinates[0] < 0) return 1;
                if (aNode.coordinates[0] - this.coordinates[0] < 0 && bNode.coordinates[0] - this.coordinates[0] >= 0) return -1;
                if (aNode.coordinates[0] - this.coordinates[0] === 0 && bNode.coordinates[0] - this.coordinates[0] === 0) {
                    if (aNode.coordinates[1] - this.coordinates[1] >= 0 || bNode.coordinates[1] - this.coordinates[1] >= 0) return aNode.coordinates[1] - bNode.coordinates[1];
                    return bNode.coordinates[1] - aNode.coordinates[1];
                }
                const det = orientationIndex(this.coordinates, aNode.coordinates, bNode.coordinates);
                if (det < 0) return 1;
                if (det > 0) return -1;
                const d1 = Math.pow(aNode.coordinates[0] - this.coordinates[0], 2) + Math.pow(aNode.coordinates[1] - this.coordinates[1], 2), d2 = Math.pow(bNode.coordinates[0] - this.coordinates[0], 2) + Math.pow(bNode.coordinates[1] - this.coordinates[1], 2);
                return d1 - d2;
            });
            this.outerEdgesSorted = true;
        }
    }
    /**
   * Retrieves outer edges.
   *
   * They are sorted if they aren't in the CCW order.
   *
   * @memberof Node
   * @returns {Edge[]} - List of outer edges sorted in a CCW order.
   */ getOuterEdges() {
        this.sortOuterEdges();
        return this.outerEdges;
    }
    getOuterEdge(i) {
        this.sortOuterEdges();
        return this.outerEdges[i];
    }
    addInnerEdge(edge) {
        this.innerEdges.push(edge);
    }
};
;
var Edge = class _Edge {
    /**
   * Creates or get the symetric Edge.
   *
   * @returns {Edge} - Symetric Edge.
   */ getSymetric() {
        if (!this.symetric) {
            this.symetric = new _Edge(this.to, this.from);
            this.symetric.symetric = this;
        }
        return this.symetric;
    }
    /**
   * @param {Node} from - start node of the Edge
   * @param {Node} to - end node of the edge
   */ constructor(from, to){
        this.from = from;
        this.to = to;
        this.next = void 0;
        this.label = void 0;
        this.symetric = void 0;
        this.ring = void 0;
        this.from.addOuterEdge(this);
        this.to.addInnerEdge(this);
    }
    /**
   * Removes edge from from and to nodes.
   */ deleteEdge() {
        this.from.removeOuterEdge(this);
        this.to.removeInnerEdge(this);
    }
    /**
   * Compares Edge equallity.
   *
   * An edge is equal to another, if the from and to nodes are the same.
   *
   * @param {Edge} edge - Another Edge
   * @returns {boolean} - True if Edges are equal, False otherwise
   */ isEqual(edge) {
        return this.from.id === edge.from.id && this.to.id === edge.to.id;
    }
    toString() {
        return `Edge { ${this.from.id} -> ${this.to.id} }`;
    }
    /**
   * Returns a LineString representation of the Edge
   *
   * @returns {Feature<LineString>} - LineString representation of the Edge
   */ toLineString() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineString"])([
            this.from.coordinates,
            this.to.coordinates
        ]);
    }
    /**
   * Comparator of two edges.
   *
   * Implementation of geos::planargraph::DirectedEdge::compareTo.
   *
   * @param {Edge} edge - Another edge to compare with this one
   * @returns {number} -1 if this Edge has a greater angle with the positive x-axis than b,
   *          0 if the Edges are colinear,
   *          1 otherwise
   */ compareTo(edge) {
        return orientationIndex(edge.from.coordinates, edge.to.coordinates, this.to.coordinates);
    }
};
;
;
;
var EdgeRing = class {
    constructor(){
        this.edges = [];
        this.polygon = void 0;
        this.envelope = void 0;
    }
    /**
   * Add an edge to the ring, inserting it in the last position.
   *
   * @memberof EdgeRing
   * @param {Edge} edge - Edge to be inserted
   */ push(edge) {
        this.edges.push(edge);
        this.polygon = this.envelope = void 0;
    }
    /**
   * Get Edge.
   *
   * @memberof EdgeRing
   * @param {number} i - Index
   * @returns {Edge} - Edge in the i position
   */ get(i) {
        return this.edges[i];
    }
    /**
   * Getter of length property.
   *
   * @memberof EdgeRing
   * @returns {number} - Length of the edge ring.
   */ get length() {
        return this.edges.length;
    }
    /**
   * Similar to Array.prototype.forEach for the list of Edges in the EdgeRing.
   *
   * @memberof EdgeRing
   * @param {Function} f - The same function to be passed to Array.prototype.forEach
   */ forEach(f) {
        this.edges.forEach(f);
    }
    /**
   * Similar to Array.prototype.map for the list of Edges in the EdgeRing.
   *
   * @memberof EdgeRing
   * @param {Function} f - The same function to be passed to Array.prototype.map
   * @returns {Array} - The mapped values in the function
   */ map(f) {
        return this.edges.map(f);
    }
    /**
   * Similar to Array.prototype.some for the list of Edges in the EdgeRing.
   *
   * @memberof EdgeRing
   * @param {Function} f - The same function to be passed to Array.prototype.some
   * @returns {boolean} - True if an Edge check the condition
   */ some(f) {
        return this.edges.some(f);
    }
    /**
   * Check if the ring is valid in geomtry terms.
   *
   * A ring must have either 0 or 4 or more points. The first and the last must be
   * equal (in 2D)
   * geos::geom::LinearRing::validateConstruction
   *
   * @memberof EdgeRing
   * @returns {boolean} - Validity of the EdgeRing
   */ isValid() {
        return true;
    }
    /**
   * Tests whether this ring is a hole.
   *
   * A ring is a hole if it is oriented counter-clockwise.
   * Similar implementation of geos::algorithm::CGAlgorithms::isCCW
   *
   * @memberof EdgeRing
   * @returns {boolean} - true: if it is a hole
   */ isHole() {
        const hiIndex = this.edges.reduce((high, edge, i)=>{
            if (edge.from.coordinates[1] > this.edges[high].from.coordinates[1]) high = i;
            return high;
        }, 0), iPrev = (hiIndex === 0 ? this.length : hiIndex) - 1, iNext = (hiIndex + 1) % this.length, disc = orientationIndex(this.edges[iPrev].from.coordinates, this.edges[hiIndex].from.coordinates, this.edges[iNext].from.coordinates);
        if (disc === 0) return this.edges[iPrev].from.coordinates[0] > this.edges[iNext].from.coordinates[0];
        return disc > 0;
    }
    /**
   * Creates a MultiPoint representing the EdgeRing (discarts edges directions).
   *
   * @memberof EdgeRing
   * @returns {Feature<MultiPoint>} - Multipoint representation of the EdgeRing
   */ toMultiPoint() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["multiPoint"])(this.edges.map((edge)=>edge.from.coordinates));
    }
    /**
   * Creates a Polygon representing the EdgeRing.
   *
   * @memberof EdgeRing
   * @returns {Feature<Polygon>} - Polygon representation of the Edge Ring
   */ toPolygon() {
        if (this.polygon) return this.polygon;
        const coordinates = this.edges.map((edge)=>edge.from.coordinates);
        coordinates.push(this.edges[0].from.coordinates);
        return this.polygon = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])([
            coordinates
        ]);
    }
    /**
   * Calculates the envelope of the EdgeRing.
   *
   * @memberof EdgeRing
   * @returns {Feature<Polygon>} - envelope
   */ getEnvelope() {
        if (this.envelope) return this.envelope;
        return this.envelope = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$envelope$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["envelope"])(this.toPolygon());
    }
    /**
   * `geos::operation::polygonize::EdgeRing::findEdgeRingContaining`
   *
   * @param {EdgeRing} testEdgeRing - EdgeRing to look in the list
   * @param {EdgeRing[]} shellList - List of EdgeRing in which to search
   *
   * @returns {EdgeRing} - EdgeRing which contains the testEdgeRing
   */ static findEdgeRingContaining(testEdgeRing, shellList) {
        const testEnvelope = testEdgeRing.getEnvelope();
        let minEnvelope, minShell;
        shellList.forEach((shell)=>{
            const tryEnvelope = shell.getEnvelope();
            if (minShell) minEnvelope = minShell.getEnvelope();
            if (envelopeIsEqual(tryEnvelope, testEnvelope)) return;
            if (envelopeContains(tryEnvelope, testEnvelope)) {
                const testEdgeRingCoordinates = testEdgeRing.map((edge)=>edge.from.coordinates);
                let testPoint;
                for (const pt of testEdgeRingCoordinates){
                    if (!shell.some((edge)=>coordinatesEqual(pt, edge.from.coordinates))) {
                        testPoint = pt;
                    }
                }
                if (testPoint && shell.inside((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])(testPoint))) {
                    if (!minShell || envelopeContains(minEnvelope, tryEnvelope)) minShell = shell;
                }
            }
        });
        return minShell;
    }
    /**
   * Checks if the point is inside the edgeRing
   *
   * @param {Feature<Point>} pt - Point to check if it is inside the edgeRing
   * @returns {boolean} - True if it is inside, False otherwise
   */ inside(pt) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(pt, this.toPolygon());
    }
};
;
;
function validateGeoJson(geoJson) {
    if (!geoJson) throw new Error("No geojson passed");
    if (geoJson.type !== "FeatureCollection" && geoJson.type !== "GeometryCollection" && geoJson.type !== "MultiLineString" && geoJson.type !== "LineString" && geoJson.type !== "Feature") throw new Error(`Invalid input type '${geoJson.type}'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature`);
}
var Graph = class _Graph {
    /**
   * Creates a graph from a GeoJSON.
   *
   * @param {FeatureCollection<LineString>} geoJson - it must comply with the restrictions detailed in the index
   * @returns {Graph} - The newly created graph
   * @throws {Error} if geoJson is invalid.
   */ static fromGeoJson(geoJson) {
        validateGeoJson(geoJson);
        const graph = new _Graph();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flattenEach"])(geoJson, (feature)=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureOf"])(feature, "LineString", "Graph::fromGeoJson");
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["coordReduce"])(feature, (prev, cur)=>{
                if (prev) {
                    const start = graph.getNode(prev), end = graph.getNode(cur);
                    graph.addEdge(start, end);
                }
                return cur;
            });
        });
        return graph;
    }
    /**
   * Creates or get a Node.
   *
   * @param {number[]} coordinates - Coordinates of the node
   * @returns {Node} - The created or stored node
   */ getNode(coordinates) {
        const id = Node.buildId(coordinates);
        let node = this.nodes[id];
        if (!node) node = this.nodes[id] = new Node(coordinates);
        return node;
    }
    /**
   * Adds an Edge and its symetricall.
   *
   * Edges are added symetrically, i.e.: we also add its symetric
   *
   * @param {Node} from - Node which starts the Edge
   * @param {Node} to - Node which ends the Edge
   */ addEdge(from, to) {
        const edge = new Edge(from, to), symetricEdge = edge.getSymetric();
        this.edges.push(edge);
        this.edges.push(symetricEdge);
    }
    constructor(){
        this.edges = [];
        this.nodes = {};
    }
    /**
   * Removes Dangle Nodes (nodes with grade 1).
   */ deleteDangles() {
        Object.keys(this.nodes).map((id)=>this.nodes[id]).forEach((node)=>this._removeIfDangle(node));
    }
    /**
   * Check if node is dangle, if so, remove it.
   *
   * It calls itself recursively, removing a dangling node might cause another dangling node
   *
   * @param {Node} node - Node to check if it's a dangle
   */ _removeIfDangle(node) {
        if (node.innerEdges.length <= 1) {
            const outerNodes = node.getOuterEdges().map((e)=>e.to);
            this.removeNode(node);
            outerNodes.forEach((n)=>this._removeIfDangle(n));
        }
    }
    /**
   * Delete cut-edges (bridge edges).
   *
   * The graph will be traversed, all the edges will be labeled according the ring
   * in which they are. (The label is a number incremented by 1). Edges with the same
   * label are cut-edges.
   */ deleteCutEdges() {
        this._computeNextCWEdges();
        this._findLabeledEdgeRings();
        this.edges.forEach((edge)=>{
            if (edge.label === edge.symetric.label) {
                this.removeEdge(edge.symetric);
                this.removeEdge(edge);
            }
        });
    }
    /**
   * Set the `next` property of each Edge.
   *
   * The graph will be transversed in a CW form, so, we set the next of the symetrical edge as the previous one.
   * OuterEdges are sorted CCW.
   *
   * @param {Node} [node] - If no node is passed, the function calls itself for every node in the Graph
   */ _computeNextCWEdges(node) {
        if (typeof node === "undefined") {
            Object.keys(this.nodes).forEach((id)=>this._computeNextCWEdges(this.nodes[id]));
        } else {
            node.getOuterEdges().forEach((edge, i)=>{
                node.getOuterEdge((i === 0 ? node.getOuterEdges().length : i) - 1).symetric.next = edge;
            });
        }
    }
    /**
   * Computes the next edge pointers going CCW around the given node, for the given edgering label.
   *
   * This algorithm has the effect of converting maximal edgerings into minimal edgerings
   *
   * XXX: method literally transcribed from `geos::operation::polygonize::PolygonizeGraph::computeNextCCWEdges`,
   * could be written in a more javascript way.
   *
   * @param {Node} node - Node
   * @param {number} label - Ring's label
   */ _computeNextCCWEdges(node, label) {
        const edges = node.getOuterEdges();
        let firstOutDE, prevInDE;
        for(let i = edges.length - 1; i >= 0; --i){
            let de = edges[i], sym = de.symetric, outDE, inDE;
            if (de.label === label) outDE = de;
            if (sym.label === label) inDE = sym;
            if (!outDE || !inDE) continue;
            if (inDE) prevInDE = inDE;
            if (outDE) {
                if (prevInDE) {
                    prevInDE.next = outDE;
                    prevInDE = void 0;
                }
                if (!firstOutDE) firstOutDE = outDE;
            }
        }
        if (prevInDE) prevInDE.next = firstOutDE;
    }
    /**
   * Finds rings and labels edges according to which rings are.
   *
   * The label is a number which is increased for each ring.
   *
   * @returns {Edge[]} edges that start rings
   */ _findLabeledEdgeRings() {
        const edgeRingStarts = [];
        let label = 0;
        this.edges.forEach((edge)=>{
            if (edge.label >= 0) return;
            edgeRingStarts.push(edge);
            let e = edge;
            do {
                e.label = label;
                e = e.next;
            }while (!edge.isEqual(e))
            label++;
        });
        return edgeRingStarts;
    }
    /**
   * Computes the EdgeRings formed by the edges in this graph.
   *
   * @returns {EdgeRing[]} - A list of all the EdgeRings in the graph.
   */ getEdgeRings() {
        this._computeNextCWEdges();
        this.edges.forEach((edge)=>{
            edge.label = void 0;
        });
        this._findLabeledEdgeRings().forEach((edge)=>{
            this._findIntersectionNodes(edge).forEach((node)=>{
                this._computeNextCCWEdges(node, edge.label);
            });
        });
        const edgeRingList = [];
        this.edges.forEach((edge)=>{
            if (edge.ring) return;
            edgeRingList.push(this._findEdgeRing(edge));
        });
        return edgeRingList;
    }
    /**
   * Find all nodes in a Maxima EdgeRing which are self-intersection nodes.
   *
   * @param {Node} startEdge - Start Edge of the Ring
   * @returns {Node[]} - intersection nodes
   */ _findIntersectionNodes(startEdge) {
        const intersectionNodes = [];
        let edge = startEdge;
        do {
            let degree = 0;
            edge.from.getOuterEdges().forEach((e)=>{
                if (e.label === startEdge.label) ++degree;
            });
            if (degree > 1) intersectionNodes.push(edge.from);
            edge = edge.next;
        }while (!startEdge.isEqual(edge))
        return intersectionNodes;
    }
    /**
   * Get the edge-ring which starts from the provided Edge.
   *
   * @param {Edge} startEdge - starting edge of the edge ring
   * @returns {EdgeRing} - EdgeRing which start Edge is the provided one.
   */ _findEdgeRing(startEdge) {
        let edge = startEdge;
        const edgeRing = new EdgeRing();
        do {
            edgeRing.push(edge);
            edge.ring = edgeRing;
            edge = edge.next;
        }while (!startEdge.isEqual(edge))
        return edgeRing;
    }
    /**
   * Removes a node from the Graph.
   *
   * It also removes edges asociated to that node
   * @param {Node} node - Node to be removed
   */ removeNode(node) {
        node.getOuterEdges().forEach((edge)=>this.removeEdge(edge));
        node.innerEdges.forEach((edge)=>this.removeEdge(edge));
        delete this.nodes[node.id];
    }
    /**
   * Remove edge from the graph and deletes the edge.
   *
   * @param {Edge} edge - Edge to be removed
   */ removeEdge(edge) {
        this.edges = this.edges.filter((e)=>!e.isEqual(edge));
        edge.deleteEdge();
    }
};
// index.ts
function polygonize(geoJson) {
    const graph = Graph.fromGeoJson(geoJson);
    graph.deleteDangles();
    graph.deleteCutEdges();
    const holes = [], shells = [];
    graph.getEdgeRings().filter((edgeRing)=>edgeRing.isValid()).forEach((edgeRing)=>{
        if (edgeRing.isHole()) holes.push(edgeRing);
        else shells.push(edgeRing);
    });
    holes.forEach((hole)=>{
        if (EdgeRing.findEdgeRingContaining(hole, shells)) shells.push(hole);
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(shells.map((shell)=>shell.toPolygon()));
}
var turf_polygonize_default = polygonize;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/projection/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "toMercator": (()=>toMercator),
    "toWgs84": (()=>toWgs84)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
function toMercator(geojson, options = {}) {
    return convert(geojson, "mercator", options);
}
function toWgs84(geojson, options = {}) {
    return convert(geojson, "wgs84", options);
}
function convert(geojson, projection, options = {}) {
    options = options || {};
    var mutate = options.mutate;
    if (!geojson) throw new Error("geojson is required");
    if (Array.isArray(geojson) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(geojson[0])) geojson = projection === "mercator" ? convertToMercator(geojson) : convertToWgs84(geojson);
    else {
        if (mutate !== true) geojson = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(geojson);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["coordEach"])(geojson, function(coord) {
            var newCoord = projection === "mercator" ? convertToMercator(coord) : convertToWgs84(coord);
            coord[0] = newCoord[0];
            coord[1] = newCoord[1];
        });
    }
    return geojson;
}
function convertToMercator(lonLat) {
    var D2R = Math.PI / 180, A = 6378137, MAXEXTENT = 20037508342789244e-9;
    var adjusted = Math.abs(lonLat[0]) <= 180 ? lonLat[0] : lonLat[0] - sign(lonLat[0]) * 360;
    var xy = [
        A * adjusted * D2R,
        A * Math.log(Math.tan(Math.PI * 0.25 + 0.5 * lonLat[1] * D2R))
    ];
    if (xy[0] > MAXEXTENT) xy[0] = MAXEXTENT;
    if (xy[0] < -MAXEXTENT) xy[0] = -MAXEXTENT;
    if (xy[1] > MAXEXTENT) xy[1] = MAXEXTENT;
    if (xy[1] < -MAXEXTENT) xy[1] = -MAXEXTENT;
    return xy;
}
function convertToWgs84(xy) {
    var R2D = 180 / Math.PI;
    var A = 6378137;
    return [
        xy[0] * R2D / A,
        (Math.PI * 0.5 - 2 * Math.atan(Math.exp(-xy[1] / A))) * R2D
    ];
}
function sign(x) {
    return x < 0 ? -1 : x > 0 ? 1 : 0;
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/random/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "randomLineString": (()=>randomLineString),
    "randomPoint": (()=>randomPoint),
    "randomPolygon": (()=>randomPolygon),
    "randomPosition": (()=>randomPosition)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
function randomPosition(bbox) {
    checkBBox(bbox);
    return randomPositionUnchecked(bbox);
}
function randomPositionUnchecked(bbox) {
    if (Array.isArray(bbox)) {
        return coordInBBox(bbox);
    }
    if (bbox && bbox.bbox) {
        return coordInBBox(bbox.bbox);
    }
    return [
        lon(),
        lat()
    ];
}
function checkBBox(bbox) {
    if (bbox == null) {
        return;
    } else if (Array.isArray(bbox)) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["validateBBox"])(bbox);
    } else if (bbox.bbox != null) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["validateBBox"])(bbox.bbox);
    }
}
function randomPoint(count, options = {}) {
    checkBBox(options.bbox);
    if (count === void 0 || count === null) {
        count = 1;
    }
    const features = [];
    for(let i = 0; i < count; i++){
        features.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])(randomPositionUnchecked(options.bbox)));
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(features);
}
function randomPolygon(count, options = {}) {
    checkBBox(options.bbox);
    if (count === void 0 || count === null) {
        count = 1;
    }
    if (options.bbox === void 0 || options.bbox === null) {
        options.bbox = [
            -180,
            -90,
            180,
            90
        ];
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(options.num_vertices) || options.num_vertices === void 0) {
        options.num_vertices = 10;
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(options.max_radial_length) || options.max_radial_length === void 0) {
        options.max_radial_length = 10;
    }
    const bboxWidth = Math.abs(options.bbox[0] - options.bbox[2]);
    const bboxHeight = Math.abs(options.bbox[1] - options.bbox[3]);
    const maxRadius = Math.min(bboxWidth / 2, bboxHeight / 2);
    if (options.max_radial_length > maxRadius) {
        throw new Error("max_radial_length is greater than the radius of the bbox");
    }
    const paddedBbox = [
        options.bbox[0] + options.max_radial_length,
        options.bbox[1] + options.max_radial_length,
        options.bbox[2] - options.max_radial_length,
        options.bbox[3] - options.max_radial_length
    ];
    const features = [];
    for(let i = 0; i < count; i++){
        let vertices = [];
        const circleOffsets = [
            ...Array(options.num_vertices + 1)
        ].map(Math.random);
        circleOffsets.forEach((cur, index, arr)=>{
            arr[index] = index > 0 ? cur + arr[index - 1] : cur;
        });
        circleOffsets.forEach((cur)=>{
            cur = cur * 2 * Math.PI / circleOffsets[circleOffsets.length - 1];
            const radialScaler = Math.random();
            vertices.push([
                radialScaler * (options.max_radial_length || 10) * Math.sin(cur),
                radialScaler * (options.max_radial_length || 10) * Math.cos(cur)
            ]);
        });
        vertices[vertices.length - 1] = vertices[0];
        vertices = vertices.reverse().map(vertexToCoordinate(randomPositionUnchecked(paddedBbox)));
        features.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])([
            vertices
        ]));
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(features);
}
function randomLineString(count, options = {}) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(options)) {
        throw new Error("options is invalid");
    }
    const bbox = options.bbox;
    checkBBox(bbox);
    let num_vertices = options.num_vertices;
    let max_length = options.max_length;
    let max_rotation = options.max_rotation;
    if (count === void 0 || count === null) {
        count = 1;
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(num_vertices) || num_vertices === void 0 || num_vertices < 2) {
        num_vertices = 10;
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(max_length) || max_length === void 0) {
        max_length = 1e-4;
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(max_rotation) || max_rotation === void 0) {
        max_rotation = Math.PI / 8;
    }
    const features = [];
    for(let i = 0; i < count; i++){
        const startingPoint = randomPositionUnchecked(bbox);
        const vertices = [
            startingPoint
        ];
        for(let j = 0; j < num_vertices - 1; j++){
            const priorAngle = j === 0 ? Math.random() * 2 * Math.PI : Math.tan((vertices[j][1] - vertices[j - 1][1]) / (vertices[j][0] - vertices[j - 1][0]));
            const angle = priorAngle + (Math.random() - 0.5) * max_rotation * 2;
            const distance = Math.random() * max_length;
            vertices.push([
                vertices[j][0] + distance * Math.cos(angle),
                vertices[j][1] + distance * Math.sin(angle)
            ]);
        }
        features.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineString"])(vertices));
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(features);
}
function vertexToCoordinate(hub) {
    return (cur)=>{
        return [
            cur[0] + hub[0],
            cur[1] + hub[1]
        ];
    };
}
function rnd() {
    return Math.random() - 0.5;
}
function lon() {
    return rnd() * 360;
}
function lat() {
    return rnd() * 180;
}
function coordInBBox(bbox) {
    return [
        Math.random() * (bbox[2] - bbox[0]) + bbox[0],
        Math.random() * (bbox[3] - bbox[1]) + bbox[1]
    ];
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/rewind/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_rewind_default),
    "rewind": (()=>rewind)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$clockwise$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-clockwise/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
;
function rewind(geojson, options = {}) {
    var _a, _b;
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    const mutate = (_a = options.mutate) != null ? _a : false;
    const reverse = (_b = options.reverse) != null ? _b : false;
    if (!geojson) throw new Error("<geojson> is required");
    if (typeof reverse !== "boolean") throw new Error("<reverse> must be a boolean");
    if (typeof mutate !== "boolean") throw new Error("<mutate> must be a boolean");
    if (!mutate && geojson.type !== "Point" && geojson.type !== "MultiPoint") {
        geojson = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(geojson);
    }
    const results = [];
    switch(geojson.type){
        case "GeometryCollection":
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["geomEach"])(geojson, function(geometry) {
                rewindFeature(geometry, reverse);
            });
            return geojson;
        case "FeatureCollection":
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"])(geojson, function(feature) {
                const rewoundFeature = rewindFeature(feature, reverse);
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"])(rewoundFeature, function(result) {
                    results.push(result);
                });
            });
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(results);
    }
    return rewindFeature(geojson, reverse);
}
function rewindFeature(geojson, reverse) {
    const type = geojson.type === "Feature" ? geojson.geometry.type : geojson.type;
    switch(type){
        case "GeometryCollection":
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["geomEach"])(geojson, function(geometry) {
                rewindFeature(geometry, reverse);
            });
            return geojson;
        case "LineString":
            rewindLineString((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(geojson), reverse);
            return geojson;
        case "Polygon":
            rewindPolygon((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(geojson), reverse);
            return geojson;
        case "MultiLineString":
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(geojson).forEach(function(lineCoords) {
                rewindLineString(lineCoords, reverse);
            });
            return geojson;
        case "MultiPolygon":
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(geojson).forEach(function(lineCoords) {
                rewindPolygon(lineCoords, reverse);
            });
            return geojson;
        case "Point":
        case "MultiPoint":
            return geojson;
    }
}
function rewindLineString(coords, reverse) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$clockwise$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanClockwise"])(coords) === reverse) coords.reverse();
}
function rewindPolygon(coords, reverse) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$clockwise$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanClockwise"])(coords[0]) !== reverse) {
        coords[0].reverse();
    }
    for(let i = 1; i < coords.length; i++){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$clockwise$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanClockwise"])(coords[i]) === reverse) {
            coords[i].reverse();
        }
    }
}
var turf_rewind_default = rewind;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/sample/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_sample_default),
    "sample": (()=>sample)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
function sample(fc, num) {
    if (!fc) throw new Error("fc is required");
    if (num === null || num === void 0) throw new Error("num is required");
    if (typeof num !== "number") throw new Error("num must be a number");
    var outFC = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(getRandomSubarray(fc.features, num));
    return outFC;
}
function getRandomSubarray(arr, size) {
    var shuffled = arr.slice(0), i = arr.length, min = i - size, temp, index;
    while(i-- > min){
        index = Math.floor((i + 1) * Math.random());
        temp = shuffled[index];
        shuffled[index] = shuffled[i];
        shuffled[i] = temp;
    }
    return shuffled.slice(min);
}
var turf_sample_default = sample;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/sector/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_sector_default),
    "sector": (()=>sector)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$arc$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-arc/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$circle$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/circle/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
;
function sector(center, radius, bearing1, bearing2, options = {}) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    const properties = options.properties;
    if (!center) throw new Error("center is required");
    if (bearing1 === void 0 || bearing1 === null) throw new Error("bearing1 is required");
    if (bearing2 === void 0 || bearing2 === null) throw new Error("bearing2 is required");
    if (!radius) throw new Error("radius is required");
    if (typeof options !== "object") throw new Error("options must be an object");
    if (convertAngleTo360(bearing1) === convertAngleTo360(bearing2)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$circle$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["circle"])(center, radius, options);
    }
    const coords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(center);
    const arc = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$arc$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineArc"])(center, radius, bearing1, bearing2, options);
    const sliceCoords = [
        [
            coords
        ]
    ];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["coordEach"])(arc, function(currentCoords) {
        sliceCoords[0].push(currentCoords);
    });
    sliceCoords[0].push(coords);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])(sliceCoords, properties);
}
function convertAngleTo360(alpha) {
    let beta = alpha % 360;
    if (beta < 0) {
        beta += 360;
    }
    return beta;
}
var turf_sector_default = sector;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/transform-scale/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_transform_scale_default),
    "transformScale": (()=>transformScale)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rhumb-distance/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rhumb-bearing/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rhumb-destination/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/center/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/centroid/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
function transformScale(geojson, factor, options) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    const origin = options.origin || "centroid";
    const mutate = options.mutate || false;
    if (!geojson) throw new Error("geojson required");
    if (typeof factor !== "number" || factor <= 0) throw new Error("invalid factor");
    const originIsPoint = Array.isArray(origin) || typeof origin === "object";
    if (mutate !== true) geojson = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(geojson);
    if (geojson.type === "FeatureCollection" && !originIsPoint) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"])(geojson, function(feature, index) {
            geojson.features[index] = scale(feature, factor, origin);
        });
        return geojson;
    }
    return scale(geojson, factor, origin);
}
function scale(feature, factor, origin) {
    const isPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getType"])(feature) === "Point";
    const originCoord = defineOrigin(feature, origin);
    if (factor === 1 || isPoint) return feature;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["coordEach"])(feature, function(coord) {
        const originalDistance = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rhumbDistance"])(originCoord, coord);
        const bearing = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rhumbBearing"])(originCoord, coord);
        const newDistance = originalDistance * factor;
        const newCoord = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rhumbDestination"])(originCoord, newDistance, bearing));
        coord[0] = newCoord[0];
        coord[1] = newCoord[1];
        if (coord.length === 3) coord[2] *= factor;
    });
    delete feature.bbox;
    return feature;
}
function defineOrigin(geojson, origin) {
    if (origin === void 0 || origin === null) origin = "centroid";
    if (Array.isArray(origin) || typeof origin === "object") return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(origin);
    const bbox = geojson.bbox ? geojson.bbox : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bbox"])(geojson, {
        recompute: true
    });
    const west = bbox[0];
    const south = bbox[1];
    const east = bbox[2];
    const north = bbox[3];
    switch(origin){
        case "sw":
        // @ts-expect-error undocumented, to be removed for v8 #techdebt
        case "southwest":
        // @ts-expect-error undocumented, to be removed for v8 #techdebt
        case "westsouth":
        // @ts-expect-error undocumented, to be removed for v8 #techdebt
        case "bottomleft":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])([
                west,
                south
            ]);
        case "se":
        // @ts-expect-error undocumented, to be removed for v8 #techdebt
        case "southeast":
        // @ts-expect-error undocumented, to be removed for v8 #techdebt
        case "eastsouth":
        // @ts-expect-error undocumented, to be removed for v8 #techdebt
        case "bottomright":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])([
                east,
                south
            ]);
        case "nw":
        // @ts-expect-error undocumented, to be removed for v8 #techdebt
        case "northwest":
        // @ts-expect-error undocumented, to be removed for v8 #techdebt
        case "westnorth":
        // @ts-expect-error undocumented, to be removed for v8 #techdebt
        case "topleft":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])([
                west,
                north
            ]);
        case "ne":
        // @ts-expect-error undocumented, to be removed for v8 #techdebt
        case "northeast":
        // @ts-expect-error undocumented, to be removed for v8 #techdebt
        case "eastnorth":
        // @ts-expect-error undocumented, to be removed for v8 #techdebt
        case "topright":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])([
                east,
                north
            ]);
        case "center":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["center"])(geojson);
        case void 0:
        case null:
        case "centroid":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["centroid"])(geojson);
        default:
            throw new Error("invalid origin");
    }
}
var turf_transform_scale_default = transformScale;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/shortest-path/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_shortest_path_default),
    "shortestPath": (()=>shortestPath)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$transform$2d$scale$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/transform-scale/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox-polygon/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clean$2d$coords$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clean-coords/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
// lib/javascript-astar.js
function pathTo(node) {
    var curr = node, path = [];
    while(curr.parent){
        path.unshift(curr);
        curr = curr.parent;
    }
    return path;
}
function getHeap() {
    return new BinaryHeap(function(node) {
        return node.f;
    });
}
var astar = {
    /**
   * Perform an A* Search on a graph given a start and end node.
   *
   * @private
   * @memberof astar
   * @param {Graph} graph Graph
   * @param {GridNode} start Start
   * @param {GridNode} end End
   * @param {Object} [options] Options
   * @param {bool} [options.closest] Specifies whether to return the path to the closest node if the target is unreachable.
   * @param {Function} [options.heuristic] Heuristic function (see astar.heuristics).
   * @returns {Object} Search
   */ search: function(graph, start, end, options) {
        var _a;
        graph.cleanDirty();
        options = options || {};
        var heuristic = options.heuristic || astar.heuristics.manhattan, closest = (_a = options.closest) != null ? _a : false;
        var openHeap = getHeap(), closestNode = start;
        start.h = heuristic(start, end);
        openHeap.push(start);
        while(openHeap.size() > 0){
            var currentNode = openHeap.pop();
            if (currentNode === end) {
                return pathTo(currentNode);
            }
            currentNode.closed = true;
            var neighbors = graph.neighbors(currentNode);
            for(var i = 0, il = neighbors.length; i < il; ++i){
                var neighbor = neighbors[i];
                if (neighbor.closed || neighbor.isWall()) {
                    continue;
                }
                var gScore = currentNode.g + neighbor.getCost(currentNode), beenVisited = neighbor.visited;
                if (!beenVisited || gScore < neighbor.g) {
                    neighbor.visited = true;
                    neighbor.parent = currentNode;
                    neighbor.h = neighbor.h || heuristic(neighbor, end);
                    neighbor.g = gScore;
                    neighbor.f = neighbor.g + neighbor.h;
                    graph.markDirty(neighbor);
                    if (closest) {
                        if (neighbor.h < closestNode.h || neighbor.h === closestNode.h && neighbor.g < closestNode.g) {
                            closestNode = neighbor;
                        }
                    }
                    if (!beenVisited) {
                        openHeap.push(neighbor);
                    } else {
                        openHeap.rescoreElement(neighbor);
                    }
                }
            }
        }
        if (closest) {
            return pathTo(closestNode);
        }
        return [];
    },
    // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html
    heuristics: {
        manhattan: function(pos0, pos1) {
            var d1 = Math.abs(pos1.x - pos0.x);
            var d2 = Math.abs(pos1.y - pos0.y);
            return d1 + d2;
        },
        diagonal: function(pos0, pos1) {
            var D = 1;
            var D2 = Math.sqrt(2);
            var d1 = Math.abs(pos1.x - pos0.x);
            var d2 = Math.abs(pos1.y - pos0.y);
            return D * (d1 + d2) + (D2 - 2 * D) * Math.min(d1, d2);
        }
    },
    cleanNode: function(node) {
        node.f = 0;
        node.g = 0;
        node.h = 0;
        node.visited = false;
        node.closed = false;
        node.parent = null;
    }
};
function Graph(gridIn, options) {
    options = options || {};
    this.nodes = [];
    this.diagonal = !!options.diagonal;
    this.grid = [];
    for(var x = 0; x < gridIn.length; x++){
        this.grid[x] = [];
        for(var y = 0, row = gridIn[x]; y < row.length; y++){
            var node = new GridNode(x, y, row[y]);
            this.grid[x][y] = node;
            this.nodes.push(node);
        }
    }
    this.init();
}
Graph.prototype.init = function() {
    this.dirtyNodes = [];
    for(var i = 0; i < this.nodes.length; i++){
        astar.cleanNode(this.nodes[i]);
    }
};
Graph.prototype.cleanDirty = function() {
    for(var i = 0; i < this.dirtyNodes.length; i++){
        astar.cleanNode(this.dirtyNodes[i]);
    }
    this.dirtyNodes = [];
};
Graph.prototype.markDirty = function(node) {
    this.dirtyNodes.push(node);
};
Graph.prototype.neighbors = function(node) {
    var ret = [], x = node.x, y = node.y, grid = this.grid;
    if (grid[x - 1] && grid[x - 1][y]) {
        ret.push(grid[x - 1][y]);
    }
    if (grid[x + 1] && grid[x + 1][y]) {
        ret.push(grid[x + 1][y]);
    }
    if (grid[x] && grid[x][y - 1]) {
        ret.push(grid[x][y - 1]);
    }
    if (grid[x] && grid[x][y + 1]) {
        ret.push(grid[x][y + 1]);
    }
    if (this.diagonal) {
        if (grid[x - 1] && grid[x - 1][y - 1]) {
            ret.push(grid[x - 1][y - 1]);
        }
        if (grid[x + 1] && grid[x + 1][y - 1]) {
            ret.push(grid[x + 1][y - 1]);
        }
        if (grid[x - 1] && grid[x - 1][y + 1]) {
            ret.push(grid[x - 1][y + 1]);
        }
        if (grid[x + 1] && grid[x + 1][y + 1]) {
            ret.push(grid[x + 1][y + 1]);
        }
    }
    return ret;
};
Graph.prototype.toString = function() {
    var graphString = [], nodes = this.grid, rowDebug, row, y, l;
    for(var x = 0, len = nodes.length; x < len; x++){
        rowDebug = [];
        row = nodes[x];
        for(y = 0, l = row.length; y < l; y++){
            rowDebug.push(row[y].weight);
        }
        graphString.push(rowDebug.join(" "));
    }
    return graphString.join("\n");
};
function GridNode(x, y, weight) {
    this.x = x;
    this.y = y;
    this.weight = weight;
}
GridNode.prototype.toString = function() {
    return "[" + this.x + " " + this.y + "]";
};
GridNode.prototype.getCost = function(fromNeighbor) {
    if (fromNeighbor && fromNeighbor.x !== this.x && fromNeighbor.y !== this.y) {
        return this.weight * 1.41421;
    }
    return this.weight;
};
GridNode.prototype.isWall = function() {
    return this.weight === 0;
};
function BinaryHeap(scoreFunction) {
    this.content = [];
    this.scoreFunction = scoreFunction;
}
BinaryHeap.prototype = {
    push: function(element) {
        this.content.push(element);
        this.sinkDown(this.content.length - 1);
    },
    pop: function() {
        var result = this.content[0];
        var end = this.content.pop();
        if (this.content.length > 0) {
            this.content[0] = end;
            this.bubbleUp(0);
        }
        return result;
    },
    remove: function(node) {
        var i = this.content.indexOf(node);
        var end = this.content.pop();
        if (i !== this.content.length - 1) {
            this.content[i] = end;
            if (this.scoreFunction(end) < this.scoreFunction(node)) {
                this.sinkDown(i);
            } else {
                this.bubbleUp(i);
            }
        }
    },
    size: function() {
        return this.content.length;
    },
    rescoreElement: function(node) {
        this.sinkDown(this.content.indexOf(node));
    },
    sinkDown: function(n) {
        var element = this.content[n];
        while(n > 0){
            var parentN = (n + 1 >> 1) - 1, parent = this.content[parentN];
            if (this.scoreFunction(element) < this.scoreFunction(parent)) {
                this.content[parentN] = element;
                this.content[n] = parent;
                n = parentN;
            } else {
                break;
            }
        }
    },
    bubbleUp: function(n) {
        var length = this.content.length, element = this.content[n], elemScore = this.scoreFunction(element);
        while(true){
            var child2N = n + 1 << 1, child1N = child2N - 1;
            var swap = null, child1Score;
            if (child1N < length) {
                var child1 = this.content[child1N];
                child1Score = this.scoreFunction(child1);
                if (child1Score < elemScore) {
                    swap = child1N;
                }
            }
            if (child2N < length) {
                var child2 = this.content[child2N], child2Score = this.scoreFunction(child2);
                if (child2Score < (swap === null ? elemScore : child1Score)) {
                    swap = child2N;
                }
            }
            if (swap !== null) {
                this.content[n] = this.content[swap];
                this.content[swap] = element;
                n = swap;
            } else {
                break;
            }
        }
    }
};
// index.ts
function shortestPath(start, end, options = {}) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    let obstacles = options.obstacles || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])([]);
    let resolution = options.resolution || 100;
    if (!start) throw new Error("start is required");
    if (!end) throw new Error("end is required");
    if (resolution && (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(resolution) || resolution <= 0)) throw new Error("options.resolution must be a number, greater than 0");
    const startCoord = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(start);
    const endCoord = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(end);
    start = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])(startCoord);
    end = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])(endCoord);
    if (obstacles.type === "FeatureCollection") {
        if (obstacles.features.length === 0) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineString"])([
                startCoord,
                endCoord
            ]);
        }
    } else if (obstacles.type === "Polygon") {
        obstacles = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])([
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["feature"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getGeom"])(obstacles))
        ]);
    } else {
        throw new Error("invalid obstacles");
    }
    const collection = obstacles;
    collection.features.push(start);
    collection.features.push(end);
    const box = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bbox"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$transform$2d$scale$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["transformScale"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bboxPolygon"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bbox"])(collection)), 1.15));
    const [west, south, east, north] = box;
    const width = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distance"])([
        west,
        south
    ], [
        east,
        south
    ], options);
    const division = width / resolution;
    collection.features.pop();
    collection.features.pop();
    const xFraction = division / (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distance"])([
        west,
        south
    ], [
        east,
        south
    ], options);
    const cellWidth = xFraction * (east - west);
    const yFraction = division / (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distance"])([
        west,
        south
    ], [
        west,
        north
    ], options);
    const cellHeight = yFraction * (north - south);
    const bboxHorizontalSide = east - west;
    const bboxVerticalSide = north - south;
    const columns = Math.floor(bboxHorizontalSide / cellWidth);
    const rows = Math.floor(bboxVerticalSide / cellHeight);
    const deltaX = (bboxHorizontalSide - columns * cellWidth) / 2;
    const deltaY = (bboxVerticalSide - rows * cellHeight) / 2;
    const pointMatrix = [];
    const matrix = [];
    let closestToStart;
    let closestToEnd;
    let minDistStart = Infinity;
    let minDistEnd = Infinity;
    let currentY = north - deltaY;
    let r = 0;
    while(currentY >= south){
        const matrixRow = [];
        const pointMatrixRow = [];
        let currentX = west + deltaX;
        let c = 0;
        while(currentX <= east){
            const pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["point"])([
                currentX,
                currentY
            ]);
            const isInsideObstacle = isInside(pt, obstacles);
            matrixRow.push(isInsideObstacle ? 0 : 1);
            pointMatrixRow.push(currentX + "|" + currentY);
            const distStart = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distance"])(pt, start);
            if (!isInsideObstacle && distStart < minDistStart) {
                minDistStart = distStart;
                closestToStart = {
                    x: c,
                    y: r
                };
            }
            const distEnd = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distance"])(pt, end);
            if (!isInsideObstacle && distEnd < minDistEnd) {
                minDistEnd = distEnd;
                closestToEnd = {
                    x: c,
                    y: r
                };
            }
            currentX += cellWidth;
            c++;
        }
        matrix.push(matrixRow);
        pointMatrix.push(pointMatrixRow);
        currentY -= cellHeight;
        r++;
    }
    const graph = new Graph(matrix, {
        diagonal: true
    });
    const startOnMatrix = graph.grid[closestToStart.y][closestToStart.x];
    const endOnMatrix = graph.grid[closestToEnd.y][closestToEnd.x];
    const result = astar.search(graph, startOnMatrix, endOnMatrix);
    const path = [
        startCoord
    ];
    result.forEach(function(coord) {
        const coords = pointMatrix[coord.x][coord.y].split("|");
        path.push([
            +coords[0],
            +coords[1]
        ]);
    });
    path.push(endCoord);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clean$2d$coords$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cleanCoords"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lineString"])(path));
}
function isInside(pt, polygons) {
    for(let i = 0; i < polygons.features.length; i++){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(pt, polygons.features[i])) {
            return true;
        }
    }
    return false;
}
var turf_shortest_path_default = shortestPath;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/simplify/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_simplify_default),
    "simplify": (()=>simplify2)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clean$2d$coords$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clean-coords/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
// lib/simplify.js
function getSqDist(p1, p2) {
    var dx = p1[0] - p2[0], dy = p1[1] - p2[1];
    return dx * dx + dy * dy;
}
function getSqSegDist(p, p1, p2) {
    var x = p1[0], y = p1[1], dx = p2[0] - x, dy = p2[1] - y;
    if (dx !== 0 || dy !== 0) {
        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);
        if (t > 1) {
            x = p2[0];
            y = p2[1];
        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }
    dx = p[0] - x;
    dy = p[1] - y;
    return dx * dx + dy * dy;
}
function simplifyRadialDist(points, sqTolerance) {
    var prevPoint = points[0], newPoints = [
        prevPoint
    ], point;
    for(var i = 1, len = points.length; i < len; i++){
        point = points[i];
        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }
    if (prevPoint !== point) newPoints.push(point);
    return newPoints;
}
function simplifyDPStep(points, first, last, sqTolerance, simplified) {
    var maxSqDist = sqTolerance, index;
    for(var i = first + 1; i < last; i++){
        var sqDist = getSqSegDist(points[i], points[first], points[last]);
        if (sqDist > maxSqDist) {
            index = i;
            maxSqDist = sqDist;
        }
    }
    if (maxSqDist > sqTolerance) {
        if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
        simplified.push(points[index]);
        if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
    }
}
function simplifyDouglasPeucker(points, sqTolerance) {
    var last = points.length - 1;
    var simplified = [
        points[0]
    ];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);
    return simplified;
}
function simplify(points, tolerance, highestQuality) {
    if (points.length <= 2) return points;
    var sqTolerance = tolerance !== void 0 ? tolerance * tolerance : 1;
    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);
    return points;
}
// index.ts
function simplify2(geojson, options = {}) {
    var _a, _b, _c;
    options = options != null ? options : {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    const tolerance = (_a = options.tolerance) != null ? _a : 1;
    const highQuality = (_b = options.highQuality) != null ? _b : false;
    const mutate = (_c = options.mutate) != null ? _c : false;
    if (!geojson) throw new Error("geojson is required");
    if (tolerance && tolerance < 0) throw new Error("invalid tolerance");
    if (mutate !== true) geojson = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(geojson);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["geomEach"])(geojson, function(geom) {
        simplifyGeom(geom, tolerance, highQuality);
    });
    return geojson;
}
function simplifyGeom(geometry, tolerance, highQuality) {
    const type = geometry.type;
    if (type === "Point" || type === "MultiPoint") return geometry;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clean$2d$coords$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cleanCoords"])(geometry, {
        mutate: true
    });
    if (type !== "GeometryCollection") {
        switch(type){
            case "LineString":
                geometry.coordinates = simplify(geometry.coordinates, tolerance, highQuality);
                break;
            case "MultiLineString":
                geometry.coordinates = geometry.coordinates.map((lines)=>simplify(lines, tolerance, highQuality));
                break;
            case "Polygon":
                geometry.coordinates = simplifyPolygon(geometry.coordinates, tolerance, highQuality);
                break;
            case "MultiPolygon":
                geometry.coordinates = geometry.coordinates.map((rings)=>simplifyPolygon(rings, tolerance, highQuality));
        }
    }
    return geometry;
}
function simplifyPolygon(coordinates, tolerance, highQuality) {
    return coordinates.map(function(ring) {
        if (ring.length < 4) {
            throw new Error("invalid polygon");
        }
        let ringTolerance = tolerance;
        let simpleRing = simplify(ring, ringTolerance, highQuality);
        while(!checkValidity(simpleRing)){
            ringTolerance -= ringTolerance * 0.01;
            simpleRing = simplify(ring, ringTolerance, highQuality);
        }
        if (simpleRing[simpleRing.length - 1][0] !== simpleRing[0][0] || simpleRing[simpleRing.length - 1][1] !== simpleRing[0][1]) {
            simpleRing.push(simpleRing[0]);
        }
        return simpleRing;
    });
}
function checkValidity(ring) {
    if (ring.length < 3) return false;
    return !(ring.length === 3 && ring[2][0] === ring[0][0] && ring[2][1] === ring[0][1]);
}
var turf_simplify_default = simplify2;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/standard-deviational-ellipse/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_standard_deviational_ellipse_default),
    "standardDeviationalEllipse": (()=>standardDeviationalEllipse)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2d$mean$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/center-mean/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$ellipse$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/ellipse/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$points$2d$within$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/points-within-polygon/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
function standardDeviationalEllipse(points, options) {
    var _a;
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    const steps = options.steps || 64;
    const weightTerm = options.weight;
    const properties = options.properties || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(steps)) throw new Error("steps must be a number");
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(properties)) throw new Error("properties must be a number");
    const numberOfFeatures = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["coordAll"])(points).length;
    const meanCenter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2d$mean$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["centerMean"])(points, {
        weight: weightTerm
    });
    let xDeviationSquaredSum = 0;
    let yDeviationSquaredSum = 0;
    let xyDeviationSum = 0;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"])(points, function(point) {
        var _a2;
        const weight = weightTerm ? ((_a2 = point.properties) == null ? void 0 : _a2[weightTerm]) || 1 : 1;
        const deviation = getDeviations((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(point), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(meanCenter));
        xDeviationSquaredSum += Math.pow(deviation.x, 2) * weight;
        yDeviationSquaredSum += Math.pow(deviation.y, 2) * weight;
        xyDeviationSum += deviation.x * deviation.y * weight;
    });
    const bigA = xDeviationSquaredSum - yDeviationSquaredSum;
    const bigB = Math.sqrt(Math.pow(bigA, 2) + 4 * Math.pow(xyDeviationSum, 2));
    const bigC = 2 * xyDeviationSum;
    const theta = Math.atan((bigA + bigB) / bigC);
    const thetaDeg = theta * 180 / Math.PI;
    let sigmaXsum = 0;
    let sigmaYsum = 0;
    let weightsum = 0;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"])(points, function(point) {
        var _a2;
        const weight = weightTerm ? ((_a2 = point.properties) == null ? void 0 : _a2[weightTerm]) || 1 : 1;
        const deviation = getDeviations((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(point), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(meanCenter));
        sigmaXsum += Math.pow(deviation.x * Math.cos(theta) - deviation.y * Math.sin(theta), 2) * weight;
        sigmaYsum += Math.pow(deviation.x * Math.sin(theta) + deviation.y * Math.cos(theta), 2) * weight;
        weightsum += weight;
    });
    const sigmaX = Math.sqrt(2 * sigmaXsum / weightsum);
    const sigmaY = Math.sqrt(2 * sigmaYsum / weightsum);
    const theEllipse = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$ellipse$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ellipse"])(meanCenter, sigmaX, sigmaY, {
        units: "degrees",
        angle: thetaDeg,
        steps,
        properties
    });
    const pointsWithinEllipse = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$points$2d$within$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pointsWithinPolygon"])(points, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])([
        theEllipse
    ]));
    const standardDeviationalEllipseProperties = {
        meanCenterCoordinates: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])(meanCenter),
        semiMajorAxis: sigmaX,
        semiMinorAxis: sigmaY,
        numberOfFeatures,
        angle: thetaDeg,
        percentageWithinEllipse: 100 * (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["coordAll"])(pointsWithinEllipse).length / numberOfFeatures
    };
    theEllipse.properties = (_a = theEllipse.properties) != null ? _a : {};
    theEllipse.properties.standardDeviationalEllipse = standardDeviationalEllipseProperties;
    return theEllipse;
}
function getDeviations(coordinates, center) {
    return {
        x: coordinates[0] - center[0],
        y: coordinates[1] - center[1]
    };
}
var turf_standard_deviational_ellipse_default = standardDeviationalEllipse;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/tag/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_tag_default),
    "tag": (()=>tag)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
function tag(points, polygons, field, outField) {
    points = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(points);
    polygons = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(polygons);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"])(points, function(pt) {
        if (!pt.properties) pt.properties = {};
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"])(polygons, function(poly) {
            if (pt.properties && poly.properties) {
                if (pt.properties[outField] === void 0) {
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(pt, poly)) pt.properties[outField] = poly.properties[field];
                }
            }
        });
    });
    return points;
}
var turf_tag_default = tag;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/tesselate/node_modules/earcut/src/earcut.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
module.exports = earcut;
module.exports.default = earcut;
function earcut(data, holeIndices, dim) {
    dim = dim || 2;
    var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) return triangles;
    var minX, minY, maxX, maxY, x, y, invSize;
    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for(var i = dim; i < outerLen; i += dim){
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }
        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
    return triangles;
}
// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;
    if (clockwise === signedArea(data, start, end, dim) > 0) {
        for(i = start; i < end; i += dim)last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for(i = end - dim; i >= start; i -= dim)last = insertNode(i, data[i], data[i + 1], last);
    }
    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }
    return last;
}
// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;
    var p = start, again;
    do {
        again = false;
        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;
        } else {
            p = p.next;
        }
    }while (again || p !== end)
    return end;
}
// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;
    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
    var stop = ear, prev, next;
    // iterate through ears, slicing them one by one
    while(ear.prev !== ear.next){
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);
            removeNode(ear);
            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;
            continue;
        }
        ear = next;
        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }
            break;
        }
    }
}
// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
    // now make sure we don't have other points inside the potential ear
    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    var p = c.next;
    while(p !== a){
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }
    return true;
}
function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    // z-order range for the current triangle bbox;
    var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
    var p = ear.prevZ, n = ear.nextZ;
    // look for points inside the triangle in both directions
    while(p && p.z >= minZ && n && n.z <= maxZ){
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }
    // look for remaining points in decreasing z-order
    while(p && p.z >= minZ){
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }
    // look for remaining points in increasing z-order
    while(n && n.z <= maxZ){
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }
    return true;
}
// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev, b = p.next.next;
        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim | 0);
            triangles.push(p.i / dim | 0);
            triangles.push(b.i / dim | 0);
            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);
            p = start = b;
        }
        p = p.next;
    }while (p !== start)
    return filterPoints(p);
}
// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while(b !== a.prev){
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);
                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);
                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
                return;
            }
            b = b.next;
        }
        a = a.next;
    }while (a !== start)
}
// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [], i, len, start, end, list;
    for(i = 0, len = holeIndices.length; i < len; i++){
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    // process holes from left to right
    for(i = 0; i < queue.length; i++){
        outerNode = eliminateHole(queue[i], outerNode);
    }
    return outerNode;
}
function compareX(a, b) {
    return a.x - b.x;
}
// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    var bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
        return outerNode;
    }
    var bridgeReverse = splitPolygon(bridge, hole);
    // filter collinear points around the cuts
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
}
// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                m = p.x < p.next.x ? p : p.next;
                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
            }
        }
        p = p.next;
    }while (p !== outerNode)
    if (!m) return null;
    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point
    var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
    p = m;
    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
            if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
                m = p;
                tanMin = tan;
            }
        }
        p = p.next;
    }while (p !== stop)
    return m;
}
// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}
// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    }while (p !== start)
    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked(p);
}
// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while(p){
            numMerges++;
            q = p;
            pSize = 0;
            for(i = 0; i < inSize; i++){
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;
            while(pSize > 0 || qSize > 0 && q){
                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }
                if (tail) tail.nextZ = e;
                else list = e;
                e.prevZ = tail;
                tail = e;
            }
            p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
    }while (numMerges > 1)
    return list;
}
// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = (x - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;
    x = (x | x << 8) & 0x00FF00FF;
    x = (x | x << 4) & 0x0F0F0F0F;
    x = (x | x << 2) & 0x33333333;
    x = (x | x << 1) & 0x55555555;
    y = (y | y << 8) & 0x00FF00FF;
    y = (y | y << 4) & 0x0F0F0F0F;
    y = (y | y << 2) & 0x33333333;
    y = (y | y << 1) & 0x55555555;
    return x | y << 1;
}
// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start, leftmost = start;
    do {
        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
        p = p.next;
    }while (p !== start)
    return leftmost;
}
// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
}
// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
    (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
    (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
    equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}
// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}
// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4) return true; // general case
    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2
    return false;
}
// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}
// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
        p = p.next;
    }while (p !== a)
    return false;
}
// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
    do {
        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
        p = p.next;
    }while (p !== a)
    return inside;
}
// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
}
// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);
    if (!last) {
        p.prev = p;
        p.next = p;
    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}
function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}
function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;
    // vertex coordinates
    this.x = x;
    this.y = y;
    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;
    // z-order curve value
    this.z = 0;
    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;
    // indicates whether this is a steiner point
    this.steiner = false;
}
// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function(data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for(var i = 0, len = holeIndices.length; i < len; i++){
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }
    var trianglesArea = 0;
    for(i = 0; i < triangles.length; i += 3){
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }
    return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
};
function signedArea(data, start, end, dim) {
    var sum = 0;
    for(var i = start, j = end - dim; i < end; i += dim){
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}
// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function(data) {
    var dim = data[0][0].length, result = {
        vertices: [],
        holes: [],
        dimensions: dim
    }, holeIndex = 0;
    for(var i = 0; i < data.length; i++){
        for(var j = 0; j < data[i].length; j++){
            for(var d = 0; d < dim; d++)result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};
}}),
"[project]/node_modules/@turf/tesselate/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_tesselate_default),
    "tesselate": (()=>tesselate)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$tesselate$2f$node_modules$2f$earcut$2f$src$2f$earcut$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/tesselate/node_modules/earcut/src/earcut.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
function tesselate(poly) {
    if (!poly.geometry || poly.geometry.type !== "Polygon" && poly.geometry.type !== "MultiPolygon") {
        throw new Error("input must be a Polygon or MultiPolygon");
    }
    const fc = {
        type: "FeatureCollection",
        features: []
    };
    if (poly.geometry.type === "Polygon") {
        fc.features = processPolygon(poly.geometry.coordinates);
    } else {
        poly.geometry.coordinates.forEach(function(coordinates) {
            fc.features = fc.features.concat(processPolygon(coordinates));
        });
    }
    return fc;
}
function processPolygon(coordinates) {
    const data = flattenCoords(coordinates);
    const dim = 2;
    const result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$tesselate$2f$node_modules$2f$earcut$2f$src$2f$earcut$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(data.vertices, data.holes, dim);
    const features = [];
    const vertices = [];
    result.forEach(function(vert, i2) {
        const index = result[i2];
        vertices.push([
            data.vertices[index * dim],
            data.vertices[index * dim + 1]
        ]);
    });
    for(var i = 0; i < vertices.length; i += 3){
        const coords = vertices.slice(i, i + 3);
        coords.push(vertices[i]);
        features.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])([
            coords
        ]));
    }
    return features;
}
function flattenCoords(data) {
    const dim = data[0][0].length, result = {
        vertices: [],
        holes: [],
        dimensions: dim
    };
    let holeIndex = 0;
    for(let i = 0; i < data.length; i++){
        for(let j = 0; j < data[i].length; j++){
            for(let d = 0; d < dim; d++)result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
}
var turf_tesselate_default = tesselate;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/transform-translate/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_transform_translate_default),
    "transformTranslate": (()=>transformTranslate)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rhumb-destination/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
;
function transformTranslate(geojson, distance, direction, options) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    var units = options.units;
    var zTranslation = options.zTranslation;
    var mutate = options.mutate;
    if (!geojson) throw new Error("geojson is required");
    if (distance === void 0 || distance === null || isNaN(distance)) throw new Error("distance is required");
    if (zTranslation && typeof zTranslation !== "number" && isNaN(zTranslation)) throw new Error("zTranslation is not a number");
    zTranslation = zTranslation !== void 0 ? zTranslation : 0;
    if (distance === 0 && zTranslation === 0) return geojson;
    if (direction === void 0 || direction === null || isNaN(direction)) throw new Error("direction is required");
    if (distance < 0) {
        distance = -distance;
        direction = direction + 180;
    }
    if (mutate === false || mutate === void 0) geojson = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clone"])(geojson);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["coordEach"])(geojson, function(pointCoords) {
        var newCoords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoords"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rhumbDestination"])(pointCoords, distance, direction, {
            units
        }));
        pointCoords[0] = newCoords[0];
        pointCoords[1] = newCoords[1];
        if (zTranslation && pointCoords.length === 3) pointCoords[2] += zTranslation;
    });
    return geojson;
}
var turf_transform_translate_default = transformTranslate;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/union/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_union_default),
    "union": (()=>union2)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/polyclip-ts/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
function union2(features, options = {}) {
    const geoms = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["geomEach"])(features, (geom)=>{
        geoms.push(geom.coordinates);
    });
    if (geoms.length < 2) {
        throw new Error("Must have at least 2 geometries");
    }
    const unioned = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.union(geoms[0], ...geoms.slice(1));
    if (unioned.length === 0) return null;
    if (unioned.length === 1) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])(unioned[0], options.properties);
    else return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["multiPolygon"])(unioned, options.properties);
}
var turf_union_default = union2;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/unkink-polygon/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_unkink_polygon_default),
    "unkinkPolygon": (()=>unkinkPolygon)
});
// lib/geojson-polygon-self-intersections.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rbush/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [app-ssr] (ecmascript)");
// lib/simplepolygon.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$area$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/area/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
function geojsonPolygonSelfIntersections(feature, filterFn, useSpatialIndex) {
    if (feature.geometry.type !== "Polygon") throw new Error("The input feature must be a Polygon");
    if (useSpatialIndex === void 0) useSpatialIndex = 1;
    var coord = feature.geometry.coordinates;
    var output = [];
    var seen = {};
    if (useSpatialIndex) {
        var allEdgesAsRbushTreeItems = [];
        for(var ring0 = 0; ring0 < coord.length; ring0++){
            for(var edge0 = 0; edge0 < coord[ring0].length - 1; edge0++){
                allEdgesAsRbushTreeItems.push(rbushTreeItem(ring0, edge0));
            }
        }
        var tree = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]();
        tree.load(allEdgesAsRbushTreeItems);
    }
    for(var ringA = 0; ringA < coord.length; ringA++){
        for(var edgeA = 0; edgeA < coord[ringA].length - 1; edgeA++){
            if (useSpatialIndex) {
                var bboxOverlaps = tree.search(rbushTreeItem(ringA, edgeA));
                bboxOverlaps.forEach(function(bboxIsect) {
                    var ring12 = bboxIsect.ring;
                    var edge12 = bboxIsect.edge;
                    ifIsectAddToOutput(ringA, edgeA, ring12, edge12);
                });
            } else {
                for(var ring1 = 0; ring1 < coord.length; ring1++){
                    for(var edge1 = 0; edge1 < coord[ring1].length - 1; edge1++){
                        ifIsectAddToOutput(ringA, edgeA, ring1, edge1);
                    }
                }
            }
        }
    }
    if (!filterFn) output = {
        type: "Feature",
        geometry: {
            type: "MultiPoint",
            coordinates: output
        }
    };
    return output;
    "TURBOPACK unreachable";
    function ifIsectAddToOutput(ring02, edge02, ring12, edge12) {
        var start0 = coord[ring02][edge02];
        var end0 = coord[ring02][edge02 + 1];
        var start1 = coord[ring12][edge12];
        var end1 = coord[ring12][edge12 + 1];
        var isect = intersect(start0, end0, start1, end1);
        if (isect === null) return;
        var frac0;
        var frac1;
        if (end0[0] !== start0[0]) {
            frac0 = (isect[0] - start0[0]) / (end0[0] - start0[0]);
        } else {
            frac0 = (isect[1] - start0[1]) / (end0[1] - start0[1]);
        }
        if (end1[0] !== start1[0]) {
            frac1 = (isect[0] - start1[0]) / (end1[0] - start1[0]);
        } else {
            frac1 = (isect[1] - start1[1]) / (end1[1] - start1[1]);
        }
        if (frac0 >= 1 || frac0 <= 0 || frac1 >= 1 || frac1 <= 0) return;
        var key = isect;
        var unique = !seen[key];
        if (unique) {
            seen[key] = true;
        }
        if (filterFn) {
            output.push(filterFn(isect, ring02, edge02, start0, end0, frac0, ring12, edge12, start1, end1, frac1, unique));
        } else {
            output.push(isect);
        }
    }
    function rbushTreeItem(ring, edge) {
        var start = coord[ring][edge];
        var end = coord[ring][edge + 1];
        var minX;
        var maxX;
        var minY;
        var maxY;
        if (start[0] < end[0]) {
            minX = start[0];
            maxX = end[0];
        } else {
            minX = end[0];
            maxX = start[0];
        }
        if (start[1] < end[1]) {
            minY = start[1];
            maxY = end[1];
        } else {
            minY = end[1];
            maxY = start[1];
        }
        return {
            minX,
            minY,
            maxX,
            maxY,
            ring,
            edge
        };
    }
}
function intersect(start0, end0, start1, end1) {
    if (equalArrays(start0, start1) || equalArrays(start0, end1) || equalArrays(end0, start1) || equalArrays(end1, start1)) return null;
    var x0 = start0[0], y0 = start0[1], x1 = end0[0], y1 = end0[1], x2 = start1[0], y2 = start1[1], x3 = end1[0], y3 = end1[1];
    var denom = (x0 - x1) * (y2 - y3) - (y0 - y1) * (x2 - x3);
    if (denom === 0) return null;
    var x4 = ((x0 * y1 - y0 * x1) * (x2 - x3) - (x0 - x1) * (x2 * y3 - y2 * x3)) / denom;
    var y4 = ((x0 * y1 - y0 * x1) * (y2 - y3) - (y0 - y1) * (x2 * y3 - y2 * x3)) / denom;
    return [
        x4,
        y4
    ];
}
function equalArrays(array1, array2) {
    if (!array1 || !array2) return false;
    if (array1.length !== array2.length) return false;
    for(var i = 0, l = array1.length; i < l; i++){
        if (array1[i] instanceof Array && array2[i] instanceof Array) {
            if (!equalArrays(array1[i], array2[i])) return false;
        } else if (array1[i] !== array2[i]) {
            return false;
        }
    }
    return true;
}
;
;
;
;
function simplepolygon(feature) {
    if (feature.type != "Feature") throw new Error("The input must a geojson object of type Feature");
    if (feature.geometry === void 0 || feature.geometry == null) throw new Error("The input must a geojson object with a non-empty geometry");
    if (feature.geometry.type != "Polygon") throw new Error("The input must be a geojson Polygon");
    var numRings = feature.geometry.coordinates.length;
    var vertices = [];
    for(var i = 0; i < numRings; i++){
        var ring = feature.geometry.coordinates[i];
        if (!equalArrays2(ring[0], ring[ring.length - 1])) {
            ring.push(ring[0]);
        }
        for(var j = 0; j < ring.length - 1; j++){
            vertices.push(ring[j]);
        }
    }
    if (!isUnique(vertices)) throw new Error("The input polygon may not have duplicate vertices (except for the first and last vertex of each ring)");
    var numvertices = vertices.length;
    var selfIsectsData = geojsonPolygonSelfIntersections(feature, function filterFn(isect, ring0, edge0, start0, end0, frac0, ring1, edge1, start1, end1, frac1, unique) {
        return [
            isect,
            ring0,
            edge0,
            start0,
            end0,
            frac0,
            ring1,
            edge1,
            start1,
            end1,
            frac1,
            unique
        ];
    });
    var numSelfIsect = selfIsectsData.length;
    if (numSelfIsect == 0) {
        var outputFeatureArray = [];
        for(var i = 0; i < numRings; i++){
            outputFeatureArray.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])([
                feature.geometry.coordinates[i]
            ], {
                parent: -1,
                winding: windingOfRing(feature.geometry.coordinates[i])
            }));
        }
        var output = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(outputFeatureArray);
        determineParents();
        setNetWinding();
        return output;
    }
    var pseudoVtxListByRingAndEdge = [];
    var isectList = [];
    for(var i = 0; i < numRings; i++){
        pseudoVtxListByRingAndEdge.push([]);
        for(var j = 0; j < feature.geometry.coordinates[i].length - 1; j++){
            pseudoVtxListByRingAndEdge[i].push([
                new PseudoVtx(feature.geometry.coordinates[i][modulo(j + 1, feature.geometry.coordinates[i].length - 1)], 1, [
                    i,
                    j
                ], [
                    i,
                    modulo(j + 1, feature.geometry.coordinates[i].length - 1)
                ], void 0)
            ]);
            isectList.push(new Isect(feature.geometry.coordinates[i][j], [
                i,
                modulo(j - 1, feature.geometry.coordinates[i].length - 1)
            ], [
                i,
                j
            ], void 0, void 0, false, true));
        }
    }
    for(var i = 0; i < numSelfIsect; i++){
        pseudoVtxListByRingAndEdge[selfIsectsData[i][1]][selfIsectsData[i][2]].push(new PseudoVtx(selfIsectsData[i][0], selfIsectsData[i][5], [
            selfIsectsData[i][1],
            selfIsectsData[i][2]
        ], [
            selfIsectsData[i][6],
            selfIsectsData[i][7]
        ], void 0));
        if (selfIsectsData[i][11]) isectList.push(new Isect(selfIsectsData[i][0], [
            selfIsectsData[i][1],
            selfIsectsData[i][2]
        ], [
            selfIsectsData[i][6],
            selfIsectsData[i][7]
        ], void 0, void 0, true, true));
    }
    var numIsect = isectList.length;
    for(var i = 0; i < pseudoVtxListByRingAndEdge.length; i++){
        for(var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++){
            pseudoVtxListByRingAndEdge[i][j].sort(function(a, b) {
                return a.param < b.param ? -1 : 1;
            });
        }
    }
    var allIsectsAsIsectRbushTreeItem = [];
    for(var i = 0; i < numIsect; i++){
        allIsectsAsIsectRbushTreeItem.push({
            minX: isectList[i].coord[0],
            minY: isectList[i].coord[1],
            maxX: isectList[i].coord[0],
            maxY: isectList[i].coord[1],
            index: i
        });
    }
    var isectRbushTree = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]();
    isectRbushTree.load(allIsectsAsIsectRbushTreeItem);
    for(var i = 0; i < pseudoVtxListByRingAndEdge.length; i++){
        for(var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++){
            for(var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++){
                var coordToFind;
                if (k == pseudoVtxListByRingAndEdge[i][j].length - 1) {
                    coordToFind = pseudoVtxListByRingAndEdge[i][modulo(j + 1, feature.geometry.coordinates[i].length - 1)][0].coord;
                } else {
                    coordToFind = pseudoVtxListByRingAndEdge[i][j][k + 1].coord;
                }
                var IsectRbushTreeItemFound = isectRbushTree.search({
                    minX: coordToFind[0],
                    minY: coordToFind[1],
                    maxX: coordToFind[0],
                    maxY: coordToFind[1]
                })[0];
                pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn = IsectRbushTreeItemFound.index;
            }
        }
    }
    for(var i = 0; i < pseudoVtxListByRingAndEdge.length; i++){
        for(var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++){
            for(var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++){
                var coordToFind = pseudoVtxListByRingAndEdge[i][j][k].coord;
                var IsectRbushTreeItemFound = isectRbushTree.search({
                    minX: coordToFind[0],
                    minY: coordToFind[1],
                    maxX: coordToFind[0],
                    maxY: coordToFind[1]
                })[0];
                var l = IsectRbushTreeItemFound.index;
                if (l < numvertices) {
                    isectList[l].nxtIsectAlongRingAndEdge2 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;
                } else {
                    if (equalArrays2(isectList[l].ringAndEdge1, pseudoVtxListByRingAndEdge[i][j][k].ringAndEdgeIn)) {
                        isectList[l].nxtIsectAlongRingAndEdge1 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;
                    } else {
                        isectList[l].nxtIsectAlongRingAndEdge2 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;
                    }
                }
            }
        }
    }
    var queue = [];
    var i = 0;
    for(var j = 0; j < numRings; j++){
        var leftIsect = i;
        for(var k = 0; k < feature.geometry.coordinates[j].length - 1; k++){
            if (isectList[i].coord[0] < isectList[leftIsect].coord[0]) {
                leftIsect = i;
            }
            i++;
        }
        var isectAfterLeftIsect = isectList[leftIsect].nxtIsectAlongRingAndEdge2;
        for(var k = 0; k < isectList.length; k++){
            if (isectList[k].nxtIsectAlongRingAndEdge1 == leftIsect || isectList[k].nxtIsectAlongRingAndEdge2 == leftIsect) {
                var isectBeforeLeftIsect = k;
                break;
            }
        }
        var windingAtIsect = isConvex([
            isectList[isectBeforeLeftIsect].coord,
            isectList[leftIsect].coord,
            isectList[isectAfterLeftIsect].coord
        ], true) ? 1 : -1;
        queue.push({
            isect: leftIsect,
            parent: -1,
            winding: windingAtIsect
        });
    }
    queue.sort(function(a, b) {
        return isectList[a.isect].coord > isectList[b.isect].coord ? -1 : 1;
    });
    var outputFeatureArray = [];
    while(queue.length > 0){
        var popped = queue.pop();
        var startIsect = popped.isect;
        var currentOutputRingParent = popped.parent;
        var currentOutputRingWinding = popped.winding;
        var currentOutputRing = outputFeatureArray.length;
        var currentOutputRingCoords = [
            isectList[startIsect].coord
        ];
        var currentIsect = startIsect;
        if (isectList[startIsect].ringAndEdge1Walkable) {
            var walkingRingAndEdge = isectList[startIsect].ringAndEdge1;
            var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge1;
        } else {
            var walkingRingAndEdge = isectList[startIsect].ringAndEdge2;
            var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge2;
        }
        while(!equalArrays2(isectList[startIsect].coord, isectList[nxtIsect].coord)){
            currentOutputRingCoords.push(isectList[nxtIsect].coord);
            var nxtIsectInQueue = void 0;
            for(var i = 0; i < queue.length; i++){
                if (queue[i].isect == nxtIsect) {
                    nxtIsectInQueue = i;
                    break;
                }
            }
            if (nxtIsectInQueue != void 0) {
                queue.splice(nxtIsectInQueue, 1);
            }
            if (equalArrays2(walkingRingAndEdge, isectList[nxtIsect].ringAndEdge1)) {
                walkingRingAndEdge = isectList[nxtIsect].ringAndEdge2;
                isectList[nxtIsect].ringAndEdge2Walkable = false;
                if (isectList[nxtIsect].ringAndEdge1Walkable) {
                    var pushing = {
                        isect: nxtIsect
                    };
                    if (isConvex([
                        isectList[currentIsect].coord,
                        isectList[nxtIsect].coord,
                        isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge2].coord
                    ], currentOutputRingWinding == 1)) {
                        pushing.parent = currentOutputRingParent;
                        pushing.winding = -currentOutputRingWinding;
                    } else {
                        pushing.parent = currentOutputRing;
                        pushing.winding = currentOutputRingWinding;
                    }
                    queue.push(pushing);
                }
                currentIsect = nxtIsect;
                nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge2;
            } else {
                walkingRingAndEdge = isectList[nxtIsect].ringAndEdge1;
                isectList[nxtIsect].ringAndEdge1Walkable = false;
                if (isectList[nxtIsect].ringAndEdge2Walkable) {
                    var pushing = {
                        isect: nxtIsect
                    };
                    if (isConvex([
                        isectList[currentIsect].coord,
                        isectList[nxtIsect].coord,
                        isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge1].coord
                    ], currentOutputRingWinding == 1)) {
                        pushing.parent = currentOutputRingParent;
                        pushing.winding = -currentOutputRingWinding;
                    } else {
                        pushing.parent = currentOutputRing;
                        pushing.winding = currentOutputRingWinding;
                    }
                    queue.push(pushing);
                }
                currentIsect = nxtIsect;
                nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge1;
            }
        }
        currentOutputRingCoords.push(isectList[nxtIsect].coord);
        outputFeatureArray.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])([
            currentOutputRingCoords
        ], {
            index: currentOutputRing,
            parent: currentOutputRingParent,
            winding: currentOutputRingWinding,
            netWinding: void 0
        }));
    }
    var output = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(outputFeatureArray);
    determineParents();
    setNetWinding();
    function determineParents() {
        var featuresWithoutParent = [];
        for(var i2 = 0; i2 < output.features.length; i2++){
            if (output.features[i2].properties.parent == -1) featuresWithoutParent.push(i2);
        }
        if (featuresWithoutParent.length > 1) {
            for(var i2 = 0; i2 < featuresWithoutParent.length; i2++){
                var parent = -1;
                var parentArea = Infinity;
                for(var j2 = 0; j2 < output.features.length; j2++){
                    if (featuresWithoutParent[i2] == j2) continue;
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(output.features[featuresWithoutParent[i2]].geometry.coordinates[0][0], output.features[j2], {
                        ignoreBoundary: true
                    })) {
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$area$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["area"])(output.features[j2]) < parentArea) {
                            parent = j2;
                        }
                    }
                }
                output.features[featuresWithoutParent[i2]].properties.parent = parent;
            }
        }
    }
    function setNetWinding() {
        for(var i2 = 0; i2 < output.features.length; i2++){
            if (output.features[i2].properties.parent == -1) {
                var netWinding = output.features[i2].properties.winding;
                output.features[i2].properties.netWinding = netWinding;
                setNetWindingOfChildren(i2, netWinding);
            }
        }
    }
    function setNetWindingOfChildren(parent, ParentNetWinding) {
        for(var i2 = 0; i2 < output.features.length; i2++){
            if (output.features[i2].properties.parent == parent) {
                var netWinding = ParentNetWinding + output.features[i2].properties.winding;
                output.features[i2].properties.netWinding = netWinding;
                setNetWindingOfChildren(i2, netWinding);
            }
        }
    }
    return output;
}
var PseudoVtx = function(coord, param, ringAndEdgeIn, ringAndEdgeOut, nxtIsectAlongEdgeIn) {
    this.coord = coord;
    this.param = param;
    this.ringAndEdgeIn = ringAndEdgeIn;
    this.ringAndEdgeOut = ringAndEdgeOut;
    this.nxtIsectAlongEdgeIn = nxtIsectAlongEdgeIn;
};
var Isect = function(coord, ringAndEdge1, ringAndEdge2, nxtIsectAlongRingAndEdge1, nxtIsectAlongRingAndEdge2, ringAndEdge1Walkable, ringAndEdge2Walkable) {
    this.coord = coord;
    this.ringAndEdge1 = ringAndEdge1;
    this.ringAndEdge2 = ringAndEdge2;
    this.nxtIsectAlongRingAndEdge1 = nxtIsectAlongRingAndEdge1;
    this.nxtIsectAlongRingAndEdge2 = nxtIsectAlongRingAndEdge2;
    this.ringAndEdge1Walkable = ringAndEdge1Walkable;
    this.ringAndEdge2Walkable = ringAndEdge2Walkable;
};
function isConvex(pts, righthanded) {
    if (typeof righthanded === "undefined") righthanded = true;
    if (pts.length != 3) throw new Error("This function requires an array of three points [x,y]");
    var d = (pts[1][0] - pts[0][0]) * (pts[2][1] - pts[0][1]) - (pts[1][1] - pts[0][1]) * (pts[2][0] - pts[0][0]);
    return d >= 0 == righthanded;
}
function windingOfRing(ring) {
    var leftVtx = 0;
    for(var i = 0; i < ring.length - 1; i++){
        if (ring[i][0] < ring[leftVtx][0]) leftVtx = i;
    }
    if (isConvex([
        ring[modulo(leftVtx - 1, ring.length - 1)],
        ring[leftVtx],
        ring[modulo(leftVtx + 1, ring.length - 1)]
    ], true)) {
        var winding = 1;
    } else {
        var winding = -1;
    }
    return winding;
}
function equalArrays2(array1, array2) {
    if (!array1 || !array2) return false;
    if (array1.length != array2.length) return false;
    for(var i = 0, l = array1.length; i < l; i++){
        if (array1[i] instanceof Array && array2[i] instanceof Array) {
            if (!equalArrays2(array1[i], array2[i])) return false;
        } else if (array1[i] != array2[i]) {
            return false;
        }
    }
    return true;
}
function modulo(n, m) {
    return (n % m + m) % m;
}
function isUnique(array) {
    var u = {};
    var isUnique2 = 1;
    for(var i = 0, l = array.length; i < l; ++i){
        if (Object.prototype.hasOwnProperty.call(u, array[i])) {
            isUnique2 = 0;
            break;
        }
        u[array[i]] = 1;
    }
    return isUnique2;
}
// index.ts
function unkinkPolygon(geojson) {
    var features = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flattenEach"])(geojson, function(feature) {
        if (feature.geometry.type !== "Polygon") return;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"])(simplepolygon(feature), function(poly) {
            features.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])(poly.geometry.coordinates, feature.properties));
        });
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(features);
}
var turf_unkink_polygon_default = unkinkPolygon;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/voronoi/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_voronoi_default),
    "voronoi": (()=>voronoi2)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/d3-voronoi/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-voronoi/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
function coordsToPolygon(coords) {
    coords = coords.slice();
    coords.push(coords[0]);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"])([
        coords
    ]);
}
function voronoi2(points, options) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    const bbox = options.bbox || [
        -180,
        -85,
        180,
        85
    ];
    if (!points) throw new Error("points is required");
    if (!Array.isArray(bbox)) throw new Error("bbox is invalid");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["collectionOf"])(points, "Point", "points");
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.voronoi().x((feature)=>feature.geometry.coordinates[0]).y((feature)=>feature.geometry.coordinates[1]).extent([
        [
            bbox[0],
            bbox[1]
        ],
        [
            bbox[2],
            bbox[3]
        ]
    ]).polygons(points.features).map(function(coords, index) {
        return Object.assign(coordsToPolygon(coords), {
            properties: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cloneProperties"])(points.features[index].properties)
        });
    }));
}
var turf_voronoi_default = voronoi2;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/nearest-neighbor-analysis/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_nearest_neighbor_analysis_default),
    "nearestNeighborAnalysis": (()=>nearestNeighborAnalysis)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox-polygon/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/centroid/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/nearest-point/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$area$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/area/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
function nearestNeighborAnalysis(dataset, options) {
    options = options || {};
    const studyArea = options.studyArea || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bboxPolygon"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bbox"])(dataset));
    const properties = options.properties || {};
    const units = options.units || "kilometers";
    const features = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureEach"])(dataset, (feature)=>{
        features.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["centroid"])(feature));
    });
    const n = features.length;
    const observedMeanDistance = features.map((feature, index)=>{
        const otherFeatures = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["featureCollection"])(features.filter((f, i)=>{
            return i !== index;
        }));
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["distance"])(feature, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nearestPoint"])(feature, otherFeatures).geometry.coordinates, {
            units
        });
    }).reduce((sum, value)=>{
        return sum + value;
    }, 0) / n;
    const populationDensity = n / (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["convertArea"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$area$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["area"])(studyArea), "meters", units);
    const expectedMeanDistance = 1 / (2 * Math.sqrt(populationDensity));
    const variance = 0.26136 / Math.sqrt(n * populationDensity);
    properties.nearestNeighborAnalysis = {
        units,
        arealUnits: units + "\xB2",
        observedMeanDistance,
        expectedMeanDistance,
        nearestNeighborIndex: observedMeanDistance / expectedMeanDistance,
        numberOfPoints: n,
        zScore: (observedMeanDistance - expectedMeanDistance) / variance
    };
    studyArea.properties = properties;
    return studyArea;
}
var turf_nearest_neighbor_analysis_default = nearestNeighborAnalysis;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/quadrat-analysis/dist/esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_quadrat_analysis_default),
    "quadratAnalysis": (()=>quadratAnalysis)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$area$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/area/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox-polygon/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$square$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/square-grid/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
;
function quadratAnalysis(pointFeatureSet, options) {
    options = options || {};
    const studyBbox = options.studyBbox || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bbox"])(pointFeatureSet);
    const confidenceLevel = options.confidenceLevel || 20;
    const points = pointFeatureSet.features;
    const numOfPoints = points.length;
    const sizeOfArea = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$area$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["area"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bboxPolygon"])(studyBbox));
    const lengthOfSide = Math.sqrt(sizeOfArea / numOfPoints * 2);
    const grid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$square$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["squareGrid"])(studyBbox, lengthOfSide, {
        units: "meters"
    });
    const quadrats = grid.features;
    const quadratIdDict = {};
    for(let i = 0; i < quadrats.length; i++){
        quadratIdDict[i] = {
            box: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bbox"])(quadrats[i]),
            cnt: 0
        };
    }
    let sumOfPoint = 0;
    for (const pt of points){
        for (const key of Object.keys(quadratIdDict)){
            const box = quadratIdDict[key].box;
            if (inBBox((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCoord"])(pt), box)) {
                quadratIdDict[key].cnt += 1;
                sumOfPoint += 1;
                break;
            }
        }
    }
    let maxCnt = 0;
    for (const key of Object.keys(quadratIdDict)){
        const cnt = quadratIdDict[key].cnt;
        if (cnt > maxCnt) {
            maxCnt = cnt;
        }
    }
    const expectedDistribution = [];
    const numOfQuadrat = Object.keys(quadratIdDict).length;
    const lambda = sumOfPoint / numOfQuadrat;
    let cumulativeProbility = 0;
    for(let x = 0; x < maxCnt + 1; x++){
        cumulativeProbility += Math.exp(-lambda) * Math.pow(lambda, x) / factorial(x);
        expectedDistribution.push(cumulativeProbility);
    }
    const observedDistribution = [];
    let cumulativeObservedQuads = 0;
    for(let x = 0; x < maxCnt + 1; x++){
        for (const key of Object.keys(quadratIdDict)){
            if (quadratIdDict[key].cnt === x) {
                cumulativeObservedQuads += 1;
            }
        }
        const p = cumulativeObservedQuads / numOfQuadrat;
        observedDistribution.push(p);
    }
    let maxDifference = 0;
    for(let x = 0; x < maxCnt + 1; x++){
        const difference = Math.abs(expectedDistribution[x] - observedDistribution[x]);
        if (difference > maxDifference) {
            maxDifference = difference;
        }
    }
    const k = K_TABLE[confidenceLevel];
    const criticalValue = k / Math.sqrt(numOfQuadrat);
    const result = {
        criticalValue,
        isRandom: true,
        maxAbsoluteDifference: maxDifference,
        observedDistribution
    };
    if (maxDifference > criticalValue) {
        result.isRandom = false;
    }
    return result;
}
var K_TABLE = {
    20: 1.07275,
    15: 1.13795,
    10: 1.22385,
    5: 1.3581,
    2: 1.51743,
    1: 1.62762
};
function inBBox(pt, bbox) {
    return bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1];
}
function factorial(num) {
    const f = [];
    function inner(n) {
        if (n === 0 || n === 1) {
            return 1;
        }
        if (f[n] > 0) {
            return f[n];
        }
        return f[n] = inner(n - 1) * n;
    }
    return inner(num);
}
var turf_quadrat_analysis_default = quadratAnalysis;
;
 //# sourceMappingURL=index.js.map
}}),

};

//# sourceMappingURL=node_modules_%40turf_5b667c._.js.map