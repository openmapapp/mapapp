(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_b0ab7a._.js", {

"[project]/node_modules/@vis.gl/react-maplibre/dist/components/use-map.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "MapProvider": (()=>MapProvider),
    "MountedMapsContext": (()=>MountedMapsContext),
    "useMap": (()=>useMap)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/components/map.js [app-client] (ecmascript)");
;
;
;
const MountedMapsContext = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.createContext(null);
const MapProvider = (props)=>{
    const [maps, setMaps] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])({});
    const onMapMount = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "MapProvider.useCallback[onMapMount]": (map, id = 'default')=>{
            setMaps({
                "MapProvider.useCallback[onMapMount]": (currMaps)=>{
                    if (id === 'current') {
                        throw new Error("'current' cannot be used as map id");
                    }
                    if (currMaps[id]) {
                        throw new Error(`Multiple maps with the same id: ${id}`);
                    }
                    return {
                        ...currMaps,
                        [id]: map
                    };
                }
            }["MapProvider.useCallback[onMapMount]"]);
        }
    }["MapProvider.useCallback[onMapMount]"], []);
    const onMapUnmount = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "MapProvider.useCallback[onMapUnmount]": (id = 'default')=>{
            setMaps({
                "MapProvider.useCallback[onMapUnmount]": (currMaps)=>{
                    if (currMaps[id]) {
                        const nextMaps = {
                            ...currMaps
                        };
                        delete nextMaps[id];
                        return nextMaps;
                    }
                    return currMaps;
                }
            }["MapProvider.useCallback[onMapUnmount]"]);
        }
    }["MapProvider.useCallback[onMapUnmount]"], []);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.createElement(MountedMapsContext.Provider, {
        value: {
            maps,
            onMapMount,
            onMapUnmount
        }
    }, props.children);
};
function useMap() {
    const maps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(MountedMapsContext)?.maps;
    const currentMap = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MapContext"]);
    const mapsWithCurrent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useMap.useMemo[mapsWithCurrent]": ()=>{
            return {
                ...maps,
                current: currentMap?.map
            };
        }
    }["useMap.useMemo[mapsWithCurrent]"], [
        maps,
        currentMap
    ]);
    return mapsWithCurrent;
} //# sourceMappingURL=use-map.js.map
}}),
"[project]/node_modules/@vis.gl/react-maplibre/dist/utils/deep-equal.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * Compare two points
 * @param a
 * @param b
 * @returns true if the points are equal
 */ __turbopack_esm__({
    "arePointsEqual": (()=>arePointsEqual),
    "deepEqual": (()=>deepEqual)
});
function arePointsEqual(a, b) {
    const ax = Array.isArray(a) ? a[0] : a ? a.x : 0;
    const ay = Array.isArray(a) ? a[1] : a ? a.y : 0;
    const bx = Array.isArray(b) ? b[0] : b ? b.x : 0;
    const by = Array.isArray(b) ? b[1] : b ? b.y : 0;
    return ax === bx && ay === by;
}
function deepEqual(a, b) {
    if (a === b) {
        return true;
    }
    if (!a || !b) {
        return false;
    }
    if (Array.isArray(a)) {
        if (!Array.isArray(b) || a.length !== b.length) {
            return false;
        }
        for(let i = 0; i < a.length; i++){
            if (!deepEqual(a[i], b[i])) {
                return false;
            }
        }
        return true;
    } else if (Array.isArray(b)) {
        return false;
    }
    if (typeof a === 'object' && typeof b === 'object') {
        const aKeys = Object.keys(a);
        const bKeys = Object.keys(b);
        if (aKeys.length !== bKeys.length) {
            return false;
        }
        for (const key of aKeys){
            if (!b.hasOwnProperty(key)) {
                return false;
            }
            if (!deepEqual(a[key], b[key])) {
                return false;
            }
        }
        return true;
    }
    return false;
} //# sourceMappingURL=deep-equal.js.map
}}),
"[project]/node_modules/@vis.gl/react-maplibre/dist/utils/transform.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "applyViewStateToTransform": (()=>applyViewStateToTransform),
    "transformToViewState": (()=>transformToViewState)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/utils/deep-equal.js [app-client] (ecmascript)");
;
function transformToViewState(tr) {
    return {
        longitude: tr.center.lng,
        latitude: tr.center.lat,
        zoom: tr.zoom,
        pitch: tr.pitch,
        bearing: tr.bearing,
        padding: tr.padding
    };
}
function applyViewStateToTransform(/** An object that describes Maplibre's camera state */ tr, /** Props from Map component */ props) {
    const v = props.viewState || props;
    const changes = {};
    if ('longitude' in v && 'latitude' in v && (v.longitude !== tr.center.lng || v.latitude !== tr.center.lat)) {
        const LngLat = tr.center.constructor;
        // @ts-expect-error we should not import LngLat class from maplibre-gl because we don't know the source of mapLib
        changes.center = new LngLat(v.longitude, v.latitude);
    }
    if ('zoom' in v && v.zoom !== tr.zoom) {
        changes.zoom = v.zoom;
    }
    if ('bearing' in v && v.bearing !== tr.bearing) {
        changes.bearing = v.bearing;
    }
    if ('pitch' in v && v.pitch !== tr.pitch) {
        changes.pitch = v.pitch;
    }
    if (v.padding && tr.padding && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepEqual"])(v.padding, tr.padding)) {
        changes.padding = v.padding;
    }
    return changes;
} //# sourceMappingURL=transform.js.map
}}),
"[project]/node_modules/@vis.gl/react-maplibre/dist/utils/style-utils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "normalizeStyle": (()=>normalizeStyle)
});
const refProps = [
    'type',
    'source',
    'source-layer',
    'minzoom',
    'maxzoom',
    'filter',
    'layout'
];
function normalizeStyle(style) {
    if (!style) {
        return null;
    }
    if (typeof style === 'string') {
        return style;
    }
    if ('toJS' in style) {
        style = style.toJS();
    }
    if (!style.layers) {
        return style;
    }
    const layerIndex = {};
    for (const layer of style.layers){
        layerIndex[layer.id] = layer;
    }
    const layers = style.layers.map((layer)=>{
        let normalizedLayer = null;
        if ('interactive' in layer) {
            normalizedLayer = Object.assign({}, layer);
            // Breaks style diffing :(
            // @ts-ignore legacy field not typed
            delete normalizedLayer.interactive;
        }
        // Style diffing doesn't work with refs so expand them out manually before diffing.
        // @ts-ignore legacy field not typed
        const layerRef = layerIndex[layer.ref];
        if (layerRef) {
            normalizedLayer = normalizedLayer || Object.assign({}, layer);
            // @ts-ignore
            delete normalizedLayer.ref;
            // https://github.com/mapbox/mapbox-gl-js/blob/master/src/style-spec/deref.js
            for (const propName of refProps){
                if (propName in layerRef) {
                    normalizedLayer[propName] = layerRef[propName];
                }
            }
        }
        return normalizedLayer || layer;
    });
    // Do not mutate the style object provided by the user
    return {
        ...style,
        layers
    };
} //# sourceMappingURL=style-utils.js.map
}}),
"[project]/node_modules/@vis.gl/react-maplibre/dist/maplibre/maplibre.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/utils/transform.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$style$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/utils/style-utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/utils/deep-equal.js [app-client] (ecmascript)");
;
;
;
const DEFAULT_STYLE = {
    version: 8,
    sources: {},
    layers: []
};
const pointerEvents = {
    mousedown: 'onMouseDown',
    mouseup: 'onMouseUp',
    mouseover: 'onMouseOver',
    mousemove: 'onMouseMove',
    click: 'onClick',
    dblclick: 'onDblClick',
    mouseenter: 'onMouseEnter',
    mouseleave: 'onMouseLeave',
    mouseout: 'onMouseOut',
    contextmenu: 'onContextMenu',
    touchstart: 'onTouchStart',
    touchend: 'onTouchEnd',
    touchmove: 'onTouchMove',
    touchcancel: 'onTouchCancel'
};
const cameraEvents = {
    movestart: 'onMoveStart',
    move: 'onMove',
    moveend: 'onMoveEnd',
    dragstart: 'onDragStart',
    drag: 'onDrag',
    dragend: 'onDragEnd',
    zoomstart: 'onZoomStart',
    zoom: 'onZoom',
    zoomend: 'onZoomEnd',
    rotatestart: 'onRotateStart',
    rotate: 'onRotate',
    rotateend: 'onRotateEnd',
    pitchstart: 'onPitchStart',
    pitch: 'onPitch',
    pitchend: 'onPitchEnd'
};
const otherEvents = {
    wheel: 'onWheel',
    boxzoomstart: 'onBoxZoomStart',
    boxzoomend: 'onBoxZoomEnd',
    boxzoomcancel: 'onBoxZoomCancel',
    resize: 'onResize',
    load: 'onLoad',
    render: 'onRender',
    idle: 'onIdle',
    remove: 'onRemove',
    data: 'onData',
    styledata: 'onStyleData',
    sourcedata: 'onSourceData',
    error: 'onError'
};
const settingNames = [
    'minZoom',
    'maxZoom',
    'minPitch',
    'maxPitch',
    'maxBounds',
    'projection',
    'renderWorldCopies'
];
const handlerNames = [
    'scrollZoom',
    'boxZoom',
    'dragRotate',
    'dragPan',
    'keyboard',
    'doubleClickZoom',
    'touchZoomRotate',
    'touchPitch'
];
/**
 * A wrapper for mapbox-gl's Map class
 */ class Maplibre {
    constructor(MapClass, props, container){
        // mapboxgl.Map instance
        this._map = null;
        // Internal states
        this._internalUpdate = false;
        this._hoveredFeatures = null;
        this._propsedCameraUpdate = null;
        this._styleComponents = {};
        this._onEvent = (e)=>{
            // @ts-ignore
            const cb = this.props[otherEvents[e.type]];
            if (cb) {
                cb(e);
            } else if (e.type === 'error') {
                console.error(e.error); // eslint-disable-line
            }
        };
        this._onCameraEvent = (e)=>{
            if (this._internalUpdate) {
                return;
            }
            e.viewState = this._propsedCameraUpdate || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transformToViewState"])(this._map.transform);
            // @ts-ignore
            const cb = this.props[cameraEvents[e.type]];
            if (cb) {
                cb(e);
            }
        };
        this._onCameraUpdate = (tr)=>{
            if (this._internalUpdate) {
                return tr;
            }
            this._propsedCameraUpdate = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transformToViewState"])(tr);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyViewStateToTransform"])(tr, this.props);
        };
        this._onPointerEvent = (e)=>{
            if (e.type === 'mousemove' || e.type === 'mouseout') {
                this._updateHover(e);
            }
            // @ts-ignore
            const cb = this.props[pointerEvents[e.type]];
            if (cb) {
                if (this.props.interactiveLayerIds && e.type !== 'mouseover' && e.type !== 'mouseout') {
                    e.features = this._hoveredFeatures || this._queryRenderedFeatures(e.point);
                }
                cb(e);
                delete e.features;
            }
        };
        this._MapClass = MapClass;
        this.props = props;
        this._initialize(container);
    }
    get map() {
        return this._map;
    }
    setProps(props) {
        const oldProps = this.props;
        this.props = props;
        const settingsChanged = this._updateSettings(props, oldProps);
        const sizeChanged = this._updateSize(props);
        const viewStateChanged = this._updateViewState(props);
        this._updateStyle(props, oldProps);
        this._updateStyleComponents(props);
        this._updateHandlers(props, oldProps);
        // If 1) view state has changed to match props and
        //    2) the props change is not triggered by map events,
        // it's driven by an external state change. Redraw immediately
        if (settingsChanged || sizeChanged || viewStateChanged && !this._map.isMoving()) {
            this.redraw();
        }
    }
    static reuse(props, container) {
        const that = Maplibre.savedMaps.pop();
        if (!that) {
            return null;
        }
        const map = that.map;
        // When reusing the saved map, we need to reparent the map(canvas) and other child nodes
        // intoto the new container from the props.
        // Step 1: reparenting child nodes from old container to new container
        const oldContainer = map.getContainer();
        container.className = oldContainer.className;
        while(oldContainer.childNodes.length > 0){
            container.appendChild(oldContainer.childNodes[0]);
        }
        // Step 2: replace the internal container with new container from the react component
        // @ts-ignore
        map._container = container;
        // With maplibre-gl as mapLib, map uses ResizeObserver to observe when its container resizes.
        // When reusing the saved map, we need to disconnect the observer and observe the new container.
        // Step 3: telling the ResizeObserver to disconnect and observe the new container
        // @ts-ignore
        const resizeObserver = map._resizeObserver;
        if (resizeObserver) {
            resizeObserver.disconnect();
            resizeObserver.observe(container);
        }
        // Step 4: apply new props
        that.setProps({
            ...props,
            styleDiffing: false
        });
        map.resize();
        const { initialViewState } = props;
        if (initialViewState) {
            if (initialViewState.bounds) {
                map.fitBounds(initialViewState.bounds, {
                    ...initialViewState.fitBoundsOptions,
                    duration: 0
                });
            } else {
                that._updateViewState(initialViewState);
            }
        }
        // Simulate load event
        if (map.isStyleLoaded()) {
            map.fire('load');
        } else {
            map.once('style.load', ()=>map.fire('load'));
        }
        // Force reload
        // @ts-ignore
        map._update();
        return that;
    }
    /* eslint-disable complexity,max-statements */ _initialize(container) {
        const { props } = this;
        const { mapStyle = DEFAULT_STYLE } = props;
        const mapOptions = {
            ...props,
            ...props.initialViewState,
            container,
            style: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$style$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeStyle"])(mapStyle)
        };
        const viewState = mapOptions.initialViewState || mapOptions.viewState || mapOptions;
        Object.assign(mapOptions, {
            center: [
                viewState.longitude || 0,
                viewState.latitude || 0
            ],
            zoom: viewState.zoom || 0,
            pitch: viewState.pitch || 0,
            bearing: viewState.bearing || 0
        });
        if (props.gl) {
            // eslint-disable-next-line
            const getContext = HTMLCanvasElement.prototype.getContext;
            // Hijack canvas.getContext to return our own WebGLContext
            // This will be called inside the mapboxgl.Map constructor
            // @ts-expect-error
            HTMLCanvasElement.prototype.getContext = ()=>{
                // Unhijack immediately
                HTMLCanvasElement.prototype.getContext = getContext;
                return props.gl;
            };
        }
        const map = new this._MapClass(mapOptions);
        // Props that are not part of constructor options
        if (viewState.padding) {
            map.setPadding(viewState.padding);
        }
        if (props.cursor) {
            map.getCanvas().style.cursor = props.cursor;
        }
        // add listeners
        map.transformCameraUpdate = this._onCameraUpdate;
        map.on('style.load', ()=>{
            // Map style has changed, this would have wiped out all settings from props
            this._styleComponents = {
                light: map.getLight(),
                sky: map.getSky(),
                // @ts-ignore getProjection() does not exist in v4
                projection: map.getProjection?.(),
                terrain: map.getTerrain()
            };
            this._updateStyleComponents(this.props);
        });
        map.on('sourcedata', ()=>{
            // Some sources have loaded, we may need them to attach terrain
            this._updateStyleComponents(this.props);
        });
        for(const eventName in pointerEvents){
            map.on(eventName, this._onPointerEvent);
        }
        for(const eventName in cameraEvents){
            map.on(eventName, this._onCameraEvent);
        }
        for(const eventName in otherEvents){
            map.on(eventName, this._onEvent);
        }
        this._map = map;
    }
    /* eslint-enable complexity,max-statements */ recycle() {
        // Clean up unnecessary elements before storing for reuse.
        const container = this.map.getContainer();
        const children = container.querySelector('[mapboxgl-children]');
        children?.remove();
        Maplibre.savedMaps.push(this);
    }
    destroy() {
        this._map.remove();
    }
    // Force redraw the map now. Typically resize() and jumpTo() is reflected in the next
    // render cycle, which is managed by Mapbox's animation loop.
    // This removes the synchronization issue caused by requestAnimationFrame.
    redraw() {
        const map = this._map;
        // map._render will throw error if style does not exist
        // https://github.com/mapbox/mapbox-gl-js/blob/fb9fc316da14e99ff4368f3e4faa3888fb43c513
        //   /src/ui/map.js#L1834
        if (map.style) {
            // cancel the scheduled update
            if (map._frame) {
                map._frame.cancel();
                map._frame = null;
            }
            // the order is important - render() may schedule another update
            map._render();
        }
    }
    /* Trigger map resize if size is controlled
       @param {object} nextProps
       @returns {bool} true if size has changed
     */ _updateSize(nextProps) {
        // Check if size is controlled
        const { viewState } = nextProps;
        if (viewState) {
            const map = this._map;
            if (viewState.width !== map.transform.width || viewState.height !== map.transform.height) {
                map.resize();
                return true;
            }
        }
        return false;
    }
    // Adapted from map.jumpTo
    /* Update camera to match props
       @param {object} nextProps
       @param {bool} triggerEvents - should fire camera events
       @returns {bool} true if anything is changed
     */ _updateViewState(nextProps) {
        const map = this._map;
        const tr = map.transform;
        const isMoving = map.isMoving();
        // Avoid manipulating the real transform when interaction/animation is ongoing
        // as it would interfere with Mapbox's handlers
        if (!isMoving) {
            const changes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyViewStateToTransform"])(tr, nextProps);
            if (Object.keys(changes).length > 0) {
                this._internalUpdate = true;
                map.jumpTo(changes);
                this._internalUpdate = false;
                return true;
            }
        }
        return false;
    }
    /* Update camera constraints and projection settings to match props
       @param {object} nextProps
       @param {object} currProps
       @returns {bool} true if anything is changed
     */ _updateSettings(nextProps, currProps) {
        const map = this._map;
        let changed = false;
        for (const propName of settingNames){
            if (propName in nextProps && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepEqual"])(nextProps[propName], currProps[propName])) {
                changed = true;
                const setter = map[`set${propName[0].toUpperCase()}${propName.slice(1)}`];
                setter?.call(map, nextProps[propName]);
            }
        }
        return changed;
    }
    /* Update map style to match props */ _updateStyle(nextProps, currProps) {
        if (nextProps.cursor !== currProps.cursor) {
            this._map.getCanvas().style.cursor = nextProps.cursor || '';
        }
        if (nextProps.mapStyle !== currProps.mapStyle) {
            const { mapStyle = DEFAULT_STYLE, styleDiffing = true } = nextProps;
            const options = {
                diff: styleDiffing
            };
            if ('localIdeographFontFamily' in nextProps) {
                // @ts-ignore Mapbox specific prop
                options.localIdeographFontFamily = nextProps.localIdeographFontFamily;
            }
            this._map.setStyle((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$style$2d$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeStyle"])(mapStyle), options);
        }
    }
    /* Update fog, light, projection and terrain to match props
     * These props are special because
     * 1. They can not be applied right away. Certain conditions (style loaded, source loaded, etc.) must be met
     * 2. They can be overwritten by mapStyle
     */ _updateStyleComponents({ light, projection, sky, terrain }) {
        const map = this._map;
        const currProps = this._styleComponents;
        // We can safely manipulate map style once it's loaded
        if (map.style._loaded) {
            if (light && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepEqual"])(light, currProps.light)) {
                currProps.light = light;
                map.setLight(light);
            }
            if (projection && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepEqual"])(projection, currProps.projection) && projection !== currProps.projection?.type) {
                currProps.projection = typeof projection === 'string' ? {
                    type: projection
                } : projection;
                // @ts-ignore setProjection does not exist in v4
                map.setProjection?.(currProps.projection);
            }
            if (sky && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepEqual"])(sky, currProps.sky)) {
                currProps.sky = sky;
                map.setSky(sky);
            }
            if (terrain !== undefined && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepEqual"])(terrain, currProps.terrain)) {
                if (!terrain || map.getSource(terrain.source)) {
                    currProps.terrain = terrain;
                    map.setTerrain(terrain);
                }
            }
        }
    }
    /* Update interaction handlers to match props */ _updateHandlers(nextProps, currProps) {
        const map = this._map;
        for (const propName of handlerNames){
            const newValue = nextProps[propName] ?? true;
            const oldValue = currProps[propName] ?? true;
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepEqual"])(newValue, oldValue)) {
                if (newValue) {
                    map[propName].enable(newValue);
                } else {
                    map[propName].disable();
                }
            }
        }
    }
    _queryRenderedFeatures(point) {
        const map = this._map;
        const { interactiveLayerIds = [] } = this.props;
        try {
            return map.queryRenderedFeatures(point, {
                layers: interactiveLayerIds.filter(map.getLayer.bind(map))
            });
        } catch  {
            // May fail if style is not loaded
            return [];
        }
    }
    _updateHover(e) {
        const { props } = this;
        const shouldTrackHoveredFeatures = props.interactiveLayerIds && (props.onMouseMove || props.onMouseEnter || props.onMouseLeave);
        if (shouldTrackHoveredFeatures) {
            const eventType = e.type;
            const wasHovering = this._hoveredFeatures?.length > 0;
            const features = this._queryRenderedFeatures(e.point);
            const isHovering = features.length > 0;
            if (!isHovering && wasHovering) {
                e.type = 'mouseleave';
                this._onPointerEvent(e);
            }
            this._hoveredFeatures = features;
            if (isHovering && !wasHovering) {
                e.type = 'mouseenter';
                this._onPointerEvent(e);
            }
            e.type = eventType;
        } else {
            this._hoveredFeatures = null;
        }
    }
}
Maplibre.savedMaps = [];
const __TURBOPACK__default__export__ = Maplibre;
 //# sourceMappingURL=maplibre.js.map
}}),
"[project]/node_modules/@vis.gl/react-maplibre/dist/maplibre/create-ref.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/** These methods may break the react binding if called directly */ __turbopack_esm__({
    "default": (()=>createRef)
});
const skipMethods = [
    'setMaxBounds',
    'setMinZoom',
    'setMaxZoom',
    'setMinPitch',
    'setMaxPitch',
    'setRenderWorldCopies',
    'setProjection',
    'setStyle',
    'addSource',
    'removeSource',
    'addLayer',
    'removeLayer',
    'setLayerZoomRange',
    'setFilter',
    'setPaintProperty',
    'setLayoutProperty',
    'setLight',
    'setTerrain',
    'setFog',
    'remove'
];
function createRef(mapInstance) {
    if (!mapInstance) {
        return null;
    }
    const map = mapInstance.map;
    const result = {
        getMap: ()=>map
    };
    for (const key of getMethodNames(map)){
        // @ts-expect-error
        if (!(key in result) && !skipMethods.includes(key)) {
            result[key] = map[key].bind(map);
        }
    }
    return result;
}
function getMethodNames(obj) {
    const result = new Set();
    let proto = obj;
    while(proto){
        for (const key of Object.getOwnPropertyNames(proto)){
            if (key[0] !== '_' && typeof obj[key] === 'function' && key !== 'fire' && key !== 'setEventedParent') {
                result.add(key);
            }
        }
        proto = Object.getPrototypeOf(proto);
    }
    return Array.from(result);
} //# sourceMappingURL=create-ref.js.map
}}),
"[project]/node_modules/@vis.gl/react-maplibre/dist/utils/use-isomorphic-layout-effect.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// From https://github.com/streamich/react-use/blob/master/src/useIsomorphicLayoutEffect.ts
// useLayoutEffect but does not trigger warning in server-side rendering
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
;
const useIsomorphicLayoutEffect = typeof document !== 'undefined' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLayoutEffect"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"];
const __TURBOPACK__default__export__ = useIsomorphicLayoutEffect;
 //# sourceMappingURL=use-isomorphic-layout-effect.js.map
}}),
"[project]/node_modules/@vis.gl/react-maplibre/dist/utils/set-globals.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>setGlobals)
});
function setGlobals(mapLib, props) {
    const { RTLTextPlugin, maxParallelImageRequests, workerCount, workerUrl } = props;
    if (RTLTextPlugin && mapLib.getRTLTextPluginStatus && mapLib.getRTLTextPluginStatus() === 'unavailable') {
        const { pluginUrl, lazy = true } = typeof RTLTextPlugin === 'string' ? {
            pluginUrl: RTLTextPlugin
        } : RTLTextPlugin;
        mapLib.setRTLTextPlugin(pluginUrl, (error)=>{
            if (error) {
                // eslint-disable-next-line
                console.error(error);
            }
        }, lazy);
    }
    if (maxParallelImageRequests !== undefined) {
        mapLib.setMaxParallelImageRequests(maxParallelImageRequests);
    }
    if (workerCount !== undefined) {
        mapLib.setWorkerCount(workerCount);
    }
    if (workerUrl !== undefined) {
        mapLib.setWorkerUrl(workerUrl);
    }
} //# sourceMappingURL=set-globals.js.map
}}),
"[project]/node_modules/@vis.gl/react-maplibre/dist/components/map.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Map": (()=>Map),
    "MapContext": (()=>MapContext)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$use$2d$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/components/use-map.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$maplibre$2f$maplibre$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/maplibre/maplibre.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$maplibre$2f$create$2d$ref$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/maplibre/create-ref.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$use$2d$isomorphic$2d$layout$2d$effect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/utils/use-isomorphic-layout-effect.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$set$2d$globals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/utils/set-globals.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
const MapContext = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.createContext(null);
function _Map(props, ref) {
    const mountedMapsContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$use$2d$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MountedMapsContext"]);
    const [mapInstance, setMapInstance] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(null);
    const containerRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])();
    const { current: contextValue } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])({
        mapLib: null,
        map: null
    });
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "_Map.useEffect": ()=>{
            const mapLib = props.mapLib;
            let isMounted = true;
            let maplibre;
            Promise.resolve(mapLib || __turbopack_require__("[project]/node_modules/maplibre-gl/dist/maplibre-gl.js [app-client] (ecmascript, async loader)")(__turbopack_import__)).then({
                "_Map.useEffect": (module)=>{
                    if (!isMounted) {
                        return;
                    }
                    if (!module) {
                        throw new Error('Invalid mapLib');
                    }
                    const mapboxgl = 'Map' in module ? module : module.default;
                    if (!mapboxgl.Map) {
                        throw new Error('Invalid mapLib');
                    }
                    // workerUrl & workerClass may change the result of supported()
                    // https://github.com/visgl/react-map-gl/discussions/2027
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$set$2d$globals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(mapboxgl, props);
                    if (!mapboxgl.supported || mapboxgl.supported(props)) {
                        if (props.reuseMaps) {
                            maplibre = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$maplibre$2f$maplibre$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].reuse(props, containerRef.current);
                        }
                        if (!maplibre) {
                            maplibre = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$maplibre$2f$maplibre$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](mapboxgl.Map, props, containerRef.current);
                        }
                        contextValue.map = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$maplibre$2f$create$2d$ref$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(maplibre);
                        contextValue.mapLib = mapboxgl;
                        setMapInstance(maplibre);
                        mountedMapsContext?.onMapMount(contextValue.map, props.id);
                    } else {
                        throw new Error('Map is not supported by this browser');
                    }
                }
            }["_Map.useEffect"]).catch({
                "_Map.useEffect": (error)=>{
                    const { onError } = props;
                    if (onError) {
                        onError({
                            type: 'error',
                            target: null,
                            originalEvent: null,
                            error
                        });
                    } else {
                        console.error(error); // eslint-disable-line
                    }
                }
            }["_Map.useEffect"]);
            return ({
                "_Map.useEffect": ()=>{
                    isMounted = false;
                    if (maplibre) {
                        mountedMapsContext?.onMapUnmount(props.id);
                        if (props.reuseMaps) {
                            maplibre.recycle();
                        } else {
                            maplibre.destroy();
                        }
                    }
                }
            })["_Map.useEffect"];
        }
    }["_Map.useEffect"], []);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$use$2d$isomorphic$2d$layout$2d$effect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({
        "_Map.useIsomorphicLayoutEffect": ()=>{
            if (mapInstance) {
                mapInstance.setProps(props);
            }
        }
    }["_Map.useIsomorphicLayoutEffect"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useImperativeHandle"])(ref, {
        "_Map.useImperativeHandle": ()=>contextValue.map
    }["_Map.useImperativeHandle"], [
        mapInstance
    ]);
    const style = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "_Map.useMemo[style]": ()=>({
                position: 'relative',
                width: '100%',
                height: '100%',
                ...props.style
            })
    }["_Map.useMemo[style]"], [
        props.style
    ]);
    const CHILD_CONTAINER_STYLE = {
        height: '100%'
    };
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.createElement("div", {
        id: props.id,
        ref: containerRef,
        style: style
    }, mapInstance && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.createElement(MapContext.Provider, {
        value: contextValue
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.createElement("div", {
        "mapboxgl-children": "",
        style: CHILD_CONTAINER_STYLE
    }, props.children)));
}
const Map = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.forwardRef(_Map); //# sourceMappingURL=map.js.map
}}),
"[project]/node_modules/@vis.gl/react-maplibre/dist/utils/apply-react-style.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// This is a simplified version of
// https://github.com/facebook/react/blob/4131af3e4bf52f3a003537ec95a1655147c81270/src/renderers/dom/shared/CSSPropertyOperations.js#L62
__turbopack_esm__({
    "applyReactStyle": (()=>applyReactStyle)
});
const unitlessNumber = /box|flex|grid|column|lineHeight|fontWeight|opacity|order|tabSize|zIndex/;
function applyReactStyle(element, styles) {
    if (!element || !styles) {
        return;
    }
    const style = element.style;
    for(const key in styles){
        const value = styles[key];
        if (Number.isFinite(value) && !unitlessNumber.test(key)) {
            style[key] = `${value}px`;
        } else {
            style[key] = value;
        }
    }
} //# sourceMappingURL=apply-react-style.js.map
}}),
"[project]/node_modules/@vis.gl/react-maplibre/dist/components/marker.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/* global document */ __turbopack_esm__({
    "Marker": (()=>Marker)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react-dom/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$apply$2d$react$2d$style$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/utils/apply-react-style.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/components/map.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/utils/deep-equal.js [app-client] (ecmascript)");
;
;
;
;
;
;
const Marker = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["memo"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"])((props, ref)=>{
    const { map, mapLib } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MapContext"]);
    const thisRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])({
        props
    });
    thisRef.current.props = props;
    const marker = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "Marker.useMemo[marker]": ()=>{
            let hasChildren = false;
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Children.forEach(props.children, {
                "Marker.useMemo[marker]": (el)=>{
                    if (el) {
                        hasChildren = true;
                    }
                }
            }["Marker.useMemo[marker]"]);
            const options = {
                ...props,
                element: hasChildren ? document.createElement('div') : null
            };
            const mk = new mapLib.Marker(options);
            mk.setLngLat([
                props.longitude,
                props.latitude
            ]);
            mk.getElement().addEventListener('click', {
                "Marker.useMemo[marker]": (e)=>{
                    thisRef.current.props.onClick?.({
                        type: 'click',
                        target: mk,
                        originalEvent: e
                    });
                }
            }["Marker.useMemo[marker]"]);
            mk.on('dragstart', {
                "Marker.useMemo[marker]": (e)=>{
                    const evt = e;
                    evt.lngLat = marker.getLngLat();
                    thisRef.current.props.onDragStart?.(evt);
                }
            }["Marker.useMemo[marker]"]);
            mk.on('drag', {
                "Marker.useMemo[marker]": (e)=>{
                    const evt = e;
                    evt.lngLat = marker.getLngLat();
                    thisRef.current.props.onDrag?.(evt);
                }
            }["Marker.useMemo[marker]"]);
            mk.on('dragend', {
                "Marker.useMemo[marker]": (e)=>{
                    const evt = e;
                    evt.lngLat = marker.getLngLat();
                    thisRef.current.props.onDragEnd?.(evt);
                }
            }["Marker.useMemo[marker]"]);
            return mk;
        }
    }["Marker.useMemo[marker]"], []);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "Marker.useEffect": ()=>{
            marker.addTo(map.getMap());
            return ({
                "Marker.useEffect": ()=>{
                    marker.remove();
                }
            })["Marker.useEffect"];
        }
    }["Marker.useEffect"], []);
    const { longitude, latitude, offset, style, draggable = false, popup = null, rotation = 0, rotationAlignment = 'auto', pitchAlignment = 'auto' } = props;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "Marker.useEffect": ()=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$apply$2d$react$2d$style$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyReactStyle"])(marker.getElement(), style);
        }
    }["Marker.useEffect"], [
        style
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useImperativeHandle"])(ref, {
        "Marker.useImperativeHandle": ()=>marker
    }["Marker.useImperativeHandle"], []);
    if (marker.getLngLat().lng !== longitude || marker.getLngLat().lat !== latitude) {
        marker.setLngLat([
            longitude,
            latitude
        ]);
    }
    if (offset && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arePointsEqual"])(marker.getOffset(), offset)) {
        marker.setOffset(offset);
    }
    if (marker.isDraggable() !== draggable) {
        marker.setDraggable(draggable);
    }
    if (marker.getRotation() !== rotation) {
        marker.setRotation(rotation);
    }
    if (marker.getRotationAlignment() !== rotationAlignment) {
        marker.setRotationAlignment(rotationAlignment);
    }
    if (marker.getPitchAlignment() !== pitchAlignment) {
        marker.setPitchAlignment(pitchAlignment);
    }
    if (marker.getPopup() !== popup) {
        marker.setPopup(popup);
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createPortal"])(props.children, marker.getElement());
})); //# sourceMappingURL=marker.js.map
}}),
"[project]/node_modules/@vis.gl/react-maplibre/dist/components/popup.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Popup": (()=>Popup)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react-dom/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$apply$2d$react$2d$style$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/utils/apply-react-style.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/components/map.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/utils/deep-equal.js [app-client] (ecmascript)");
;
;
;
;
;
// Adapted from https://github.com/mapbox/mapbox-gl-js/blob/v1.13.0/src/ui/popup.js
function getClassList(className) {
    return new Set(className ? className.trim().split(/\s+/) : []);
}
const Popup = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["memo"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"])((props, ref)=>{
    const { map, mapLib } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MapContext"]);
    const container = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "Popup.useMemo[container]": ()=>{
            return document.createElement('div');
        }
    }["Popup.useMemo[container]"], []);
    const thisRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])({
        props
    });
    thisRef.current.props = props;
    const popup = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "Popup.useMemo[popup]": ()=>{
            const options = {
                ...props
            };
            const pp = new mapLib.Popup(options);
            pp.setLngLat([
                props.longitude,
                props.latitude
            ]);
            pp.once('open', {
                "Popup.useMemo[popup]": (e)=>{
                    thisRef.current.props.onOpen?.(e);
                }
            }["Popup.useMemo[popup]"]);
            return pp;
        }
    }["Popup.useMemo[popup]"], []);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "Popup.useEffect": ()=>{
            const onClose = {
                "Popup.useEffect.onClose": (e)=>{
                    thisRef.current.props.onClose?.(e);
                }
            }["Popup.useEffect.onClose"];
            popup.on('close', onClose);
            popup.setDOMContent(container).addTo(map.getMap());
            return ({
                "Popup.useEffect": ()=>{
                    // https://github.com/visgl/react-map-gl/issues/1825
                    // onClose should not be fired if the popup is removed by unmounting
                    // When using React strict mode, the component is mounted twice.
                    // Firing the onClose callback here would be a false signal to remove the component.
                    popup.off('close', onClose);
                    if (popup.isOpen()) {
                        popup.remove();
                    }
                }
            })["Popup.useEffect"];
        }
    }["Popup.useEffect"], []);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "Popup.useEffect": ()=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$apply$2d$react$2d$style$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyReactStyle"])(popup.getElement(), props.style);
        }
    }["Popup.useEffect"], [
        props.style
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useImperativeHandle"])(ref, {
        "Popup.useImperativeHandle": ()=>popup
    }["Popup.useImperativeHandle"], []);
    if (popup.isOpen()) {
        if (popup.getLngLat().lng !== props.longitude || popup.getLngLat().lat !== props.latitude) {
            popup.setLngLat([
                props.longitude,
                props.latitude
            ]);
        }
        if (props.offset && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepEqual"])(popup.options.offset, props.offset)) {
            popup.setOffset(props.offset);
        }
        if (popup.options.anchor !== props.anchor || popup.options.maxWidth !== props.maxWidth) {
            popup.options.anchor = props.anchor;
            popup.setMaxWidth(props.maxWidth);
        }
        if (popup.options.className !== props.className) {
            const prevClassList = getClassList(popup.options.className);
            const nextClassList = getClassList(props.className);
            for (const c of prevClassList){
                if (!nextClassList.has(c)) {
                    popup.removeClassName(c);
                }
            }
            for (const c of nextClassList){
                if (!prevClassList.has(c)) {
                    popup.addClassName(c);
                }
            }
            popup.options.className = props.className;
        }
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createPortal"])(props.children, container);
})); //# sourceMappingURL=popup.js.map
}}),
"[project]/node_modules/@vis.gl/react-maplibre/dist/components/use-control.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "useControl": (()=>useControl)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/components/map.js [app-client] (ecmascript)");
;
;
function useControl(onCreate, arg1, arg2, arg3) {
    const context = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MapContext"]);
    const ctrl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useControl.useMemo[ctrl]": ()=>onCreate(context)
    }["useControl.useMemo[ctrl]"], []);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useControl.useEffect": ()=>{
            const opts = arg3 || arg2 || arg1;
            const onAdd = typeof arg1 === 'function' && typeof arg2 === 'function' ? arg1 : null;
            const onRemove = typeof arg2 === 'function' ? arg2 : typeof arg1 === 'function' ? arg1 : null;
            const { map } = context;
            if (!map.hasControl(ctrl)) {
                map.addControl(ctrl, opts?.position);
                if (onAdd) {
                    onAdd(context);
                }
            }
            return ({
                "useControl.useEffect": ()=>{
                    if (onRemove) {
                        onRemove(context);
                    }
                    // Map might have been removed (parent effects are destroyed before child ones)
                    if (map.hasControl(ctrl)) {
                        map.removeControl(ctrl);
                    }
                }
            })["useControl.useEffect"];
        }
    }["useControl.useEffect"], []);
    return ctrl;
} //# sourceMappingURL=use-control.js.map
}}),
"[project]/node_modules/@vis.gl/react-maplibre/dist/components/attribution-control.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "AttributionControl": (()=>AttributionControl)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$apply$2d$react$2d$style$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/utils/apply-react-style.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$use$2d$control$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/components/use-control.js [app-client] (ecmascript)");
;
;
;
function _AttributionControl(props) {
    const ctrl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$use$2d$control$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useControl"])({
        "_AttributionControl.useControl[ctrl]": ({ mapLib })=>new mapLib.AttributionControl(props)
    }["_AttributionControl.useControl[ctrl]"], {
        position: props.position
    });
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "_AttributionControl.useEffect": ()=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$apply$2d$react$2d$style$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyReactStyle"])(ctrl._container, props.style);
        }
    }["_AttributionControl.useEffect"], [
        props.style
    ]);
    return null;
}
const AttributionControl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["memo"])(_AttributionControl); //# sourceMappingURL=attribution-control.js.map
}}),
"[project]/node_modules/@vis.gl/react-maplibre/dist/components/fullscreen-control.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "FullscreenControl": (()=>FullscreenControl)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$apply$2d$react$2d$style$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/utils/apply-react-style.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$use$2d$control$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/components/use-control.js [app-client] (ecmascript)");
;
;
;
function _FullscreenControl(props) {
    const ctrl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$use$2d$control$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useControl"])({
        "_FullscreenControl.useControl[ctrl]": ({ mapLib })=>new mapLib.FullscreenControl({
                container: props.containerId && document.getElementById(props.containerId)
            })
    }["_FullscreenControl.useControl[ctrl]"], {
        position: props.position
    });
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "_FullscreenControl.useEffect": ()=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$apply$2d$react$2d$style$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyReactStyle"])(ctrl._controlContainer, props.style);
        }
    }["_FullscreenControl.useEffect"], [
        props.style
    ]);
    return null;
}
const FullscreenControl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["memo"])(_FullscreenControl); //# sourceMappingURL=fullscreen-control.js.map
}}),
"[project]/node_modules/@vis.gl/react-maplibre/dist/components/geolocate-control.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "GeolocateControl": (()=>GeolocateControl)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$apply$2d$react$2d$style$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/utils/apply-react-style.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$use$2d$control$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/components/use-control.js [app-client] (ecmascript)");
;
;
;
function _GeolocateControl(props, ref) {
    const thisRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])({
        props
    });
    const ctrl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$use$2d$control$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useControl"])({
        "_GeolocateControl.useControl[ctrl]": ({ mapLib })=>{
            const gc = new mapLib.GeolocateControl(props);
            // Hack: fix GeolocateControl reuse
            // When using React strict mode, the component is mounted twice.
            // GeolocateControl's UI creation is asynchronous. Removing and adding it back causes the UI to be initialized twice.
            const setupUI = gc._setupUI;
            gc._setupUI = ({
                "_GeolocateControl.useControl[ctrl]": ()=>{
                    if (!gc._container.hasChildNodes()) {
                        setupUI();
                    }
                }
            })["_GeolocateControl.useControl[ctrl]"];
            gc.on('geolocate', {
                "_GeolocateControl.useControl[ctrl]": (e)=>{
                    thisRef.current.props.onGeolocate?.(e);
                }
            }["_GeolocateControl.useControl[ctrl]"]);
            gc.on('error', {
                "_GeolocateControl.useControl[ctrl]": (e)=>{
                    thisRef.current.props.onError?.(e);
                }
            }["_GeolocateControl.useControl[ctrl]"]);
            gc.on('outofmaxbounds', {
                "_GeolocateControl.useControl[ctrl]": (e)=>{
                    thisRef.current.props.onOutOfMaxBounds?.(e);
                }
            }["_GeolocateControl.useControl[ctrl]"]);
            gc.on('trackuserlocationstart', {
                "_GeolocateControl.useControl[ctrl]": (e)=>{
                    thisRef.current.props.onTrackUserLocationStart?.(e);
                }
            }["_GeolocateControl.useControl[ctrl]"]);
            gc.on('trackuserlocationend', {
                "_GeolocateControl.useControl[ctrl]": (e)=>{
                    thisRef.current.props.onTrackUserLocationEnd?.(e);
                }
            }["_GeolocateControl.useControl[ctrl]"]);
            return gc;
        }
    }["_GeolocateControl.useControl[ctrl]"], {
        position: props.position
    });
    thisRef.current.props = props;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useImperativeHandle"])(ref, {
        "_GeolocateControl.useImperativeHandle": ()=>ctrl
    }["_GeolocateControl.useImperativeHandle"], []);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "_GeolocateControl.useEffect": ()=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$apply$2d$react$2d$style$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyReactStyle"])(ctrl._container, props.style);
        }
    }["_GeolocateControl.useEffect"], [
        props.style
    ]);
    return null;
}
const GeolocateControl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["memo"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"])(_GeolocateControl)); //# sourceMappingURL=geolocate-control.js.map
}}),
"[project]/node_modules/@vis.gl/react-maplibre/dist/components/navigation-control.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "NavigationControl": (()=>NavigationControl)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$apply$2d$react$2d$style$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/utils/apply-react-style.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$use$2d$control$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/components/use-control.js [app-client] (ecmascript)");
;
;
;
function _NavigationControl(props) {
    const ctrl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$use$2d$control$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useControl"])({
        "_NavigationControl.useControl[ctrl]": ({ mapLib })=>new mapLib.NavigationControl(props)
    }["_NavigationControl.useControl[ctrl]"], {
        position: props.position
    });
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "_NavigationControl.useEffect": ()=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$apply$2d$react$2d$style$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyReactStyle"])(ctrl._container, props.style);
        }
    }["_NavigationControl.useEffect"], [
        props.style
    ]);
    return null;
}
const NavigationControl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["memo"])(_NavigationControl); //# sourceMappingURL=navigation-control.js.map
}}),
"[project]/node_modules/@vis.gl/react-maplibre/dist/components/scale-control.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ScaleControl": (()=>ScaleControl)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$apply$2d$react$2d$style$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/utils/apply-react-style.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$use$2d$control$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/components/use-control.js [app-client] (ecmascript)");
;
;
;
function _ScaleControl(props) {
    const ctrl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$use$2d$control$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useControl"])({
        "_ScaleControl.useControl[ctrl]": ({ mapLib })=>new mapLib.ScaleControl(props)
    }["_ScaleControl.useControl[ctrl]"], {
        position: props.position
    });
    const propsRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(props);
    const prevProps = propsRef.current;
    propsRef.current = props;
    const { style } = props;
    if (props.maxWidth !== undefined && props.maxWidth !== prevProps.maxWidth) {
        ctrl.options.maxWidth = props.maxWidth;
    }
    if (props.unit !== undefined && props.unit !== prevProps.unit) {
        ctrl.setUnit(props.unit);
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "_ScaleControl.useEffect": ()=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$apply$2d$react$2d$style$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyReactStyle"])(ctrl._container, style);
        }
    }["_ScaleControl.useEffect"], [
        style
    ]);
    return null;
}
const ScaleControl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["memo"])(_ScaleControl); //# sourceMappingURL=scale-control.js.map
}}),
"[project]/node_modules/@vis.gl/react-maplibre/dist/components/terrain-control.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "TerrainControl": (()=>TerrainControl)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$apply$2d$react$2d$style$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/utils/apply-react-style.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$use$2d$control$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/components/use-control.js [app-client] (ecmascript)");
;
;
;
function _TerrainControl(props) {
    const ctrl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$use$2d$control$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useControl"])({
        "_TerrainControl.useControl[ctrl]": ({ mapLib })=>new mapLib.TerrainControl(props)
    }["_TerrainControl.useControl[ctrl]"], {
        position: props.position
    });
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "_TerrainControl.useEffect": ()=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$apply$2d$react$2d$style$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyReactStyle"])(ctrl._container, props.style);
        }
    }["_TerrainControl.useEffect"], [
        props.style
    ]);
    return null;
}
const TerrainControl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["memo"])(_TerrainControl); //# sourceMappingURL=terrain-control.js.map
}}),
"[project]/node_modules/@vis.gl/react-maplibre/dist/components/logo-control.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "LogoControl": (()=>LogoControl)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$apply$2d$react$2d$style$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/utils/apply-react-style.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$use$2d$control$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/components/use-control.js [app-client] (ecmascript)");
;
;
;
function _LogoControl(props) {
    const ctrl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$use$2d$control$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useControl"])({
        "_LogoControl.useControl[ctrl]": ({ mapLib })=>new mapLib.LogoControl(props)
    }["_LogoControl.useControl[ctrl]"], {
        position: props.position
    });
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "_LogoControl.useEffect": ()=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$apply$2d$react$2d$style$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyReactStyle"])(ctrl._container, props.style);
        }
    }["_LogoControl.useEffect"], [
        props.style
    ]);
    return null;
}
const LogoControl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["memo"])(_LogoControl); //# sourceMappingURL=logo-control.js.map
}}),
"[project]/node_modules/@vis.gl/react-maplibre/dist/utils/assert.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>assert)
});
function assert(condition, message) {
    if (!condition) {
        throw new Error(message);
    }
} //# sourceMappingURL=assert.js.map
}}),
"[project]/node_modules/@vis.gl/react-maplibre/dist/components/source.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Source": (()=>Source)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/components/map.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/utils/assert.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/utils/deep-equal.js [app-client] (ecmascript)");
;
;
;
;
;
let sourceCounter = 0;
function createSource(map, id, props) {
    // @ts-ignore
    if (map.style && map.style._loaded) {
        const options = {
            ...props
        };
        delete options.id;
        delete options.children;
        // @ts-ignore
        map.addSource(id, options);
        return map.getSource(id);
    }
    return null;
}
/* eslint-disable complexity */ function updateSource(source, props, prevProps) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(props.id === prevProps.id, 'source id changed');
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(props.type === prevProps.type, 'source type changed');
    let changedKey = '';
    let changedKeyCount = 0;
    for(const key in props){
        if (key !== 'children' && key !== 'id' && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepEqual"])(prevProps[key], props[key])) {
            changedKey = key;
            changedKeyCount++;
        }
    }
    if (!changedKeyCount) {
        return;
    }
    const type = props.type;
    if (type === 'geojson') {
        source.setData(props.data);
    } else if (type === 'image') {
        source.updateImage({
            url: props.url,
            coordinates: props.coordinates
        });
    } else {
        switch(changedKey){
            case 'coordinates':
                // @ts-ignore
                source.setCoordinates?.(props.coordinates);
                break;
            case 'url':
                // @ts-ignore
                source.setUrl?.(props.url);
                break;
            case 'tiles':
                // @ts-ignore
                source.setTiles?.(props.tiles);
                break;
            default:
                // eslint-disable-next-line
                console.warn(`Unable to update <Source> prop: ${changedKey}`);
        }
    }
}
function Source(props) {
    const map = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MapContext"]).map.getMap();
    const propsRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(props);
    const [, setStyleLoaded] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(0);
    const id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "Source.useMemo[id]": ()=>props.id || `jsx-source-${sourceCounter++}`
    }["Source.useMemo[id]"], []);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "Source.useEffect": ()=>{
            if (map) {
                /* global setTimeout */ const forceUpdate = {
                    "Source.useEffect.forceUpdate": ()=>setTimeout({
                            "Source.useEffect.forceUpdate": ()=>setStyleLoaded({
                                    "Source.useEffect.forceUpdate": (version)=>version + 1
                                }["Source.useEffect.forceUpdate"])
                        }["Source.useEffect.forceUpdate"], 0)
                }["Source.useEffect.forceUpdate"];
                map.on('styledata', forceUpdate);
                forceUpdate();
                return ({
                    "Source.useEffect": ()=>{
                        map.off('styledata', forceUpdate);
                        // @ts-ignore
                        if (map.style && map.style._loaded && map.getSource(id)) {
                            // Parent effects are destroyed before child ones, see
                            // https://github.com/facebook/react/issues/16728
                            // Source can only be removed after all child layers are removed
                            const allLayers = map.getStyle()?.layers;
                            if (allLayers) {
                                for (const layer of allLayers){
                                    // @ts-ignore (2339) source does not exist on all layer types
                                    if (layer.source === id) {
                                        map.removeLayer(layer.id);
                                    }
                                }
                            }
                            map.removeSource(id);
                        }
                    }
                })["Source.useEffect"];
            }
            return undefined;
        }
    }["Source.useEffect"], [
        map
    ]);
    // @ts-ignore
    let source = map && map.style && map.getSource(id);
    if (source) {
        updateSource(source, props, propsRef.current);
    } else {
        source = createSource(map, id, props);
    }
    propsRef.current = props;
    return source && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Children.map(props.children, (child)=>child && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cloneElement"])(child, {
            source: id
        })) || null;
} //# sourceMappingURL=source.js.map
}}),
"[project]/node_modules/@vis.gl/react-maplibre/dist/components/layer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Layer": (()=>Layer)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/components/map.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/utils/assert.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/utils/deep-equal.js [app-client] (ecmascript)");
;
;
;
;
/* eslint-disable complexity, max-statements */ function updateLayer(map, id, props, prevProps) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(props.id === prevProps.id, 'layer id changed');
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(props.type === prevProps.type, 'layer type changed');
    if (props.type === 'custom' || prevProps.type === 'custom') {
        return;
    }
    // @ts-ignore filter does not exist in some Layer types
    const { layout = {}, paint = {}, filter, minzoom, maxzoom, beforeId } = props;
    if (beforeId !== prevProps.beforeId) {
        map.moveLayer(id, beforeId);
    }
    if (layout !== prevProps.layout) {
        const prevLayout = prevProps.layout || {};
        for(const key in layout){
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepEqual"])(layout[key], prevLayout[key])) {
                map.setLayoutProperty(id, key, layout[key]);
            }
        }
        for(const key in prevLayout){
            if (!layout.hasOwnProperty(key)) {
                map.setLayoutProperty(id, key, undefined);
            }
        }
    }
    if (paint !== prevProps.paint) {
        const prevPaint = prevProps.paint || {};
        for(const key in paint){
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepEqual"])(paint[key], prevPaint[key])) {
                map.setPaintProperty(id, key, paint[key]);
            }
        }
        for(const key in prevPaint){
            if (!paint.hasOwnProperty(key)) {
                map.setPaintProperty(id, key, undefined);
            }
        }
    }
    // @ts-ignore filter does not exist in some Layer types
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$utils$2f$deep$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepEqual"])(filter, prevProps.filter)) {
        map.setFilter(id, filter);
    }
    if (minzoom !== prevProps.minzoom || maxzoom !== prevProps.maxzoom) {
        map.setLayerZoomRange(id, minzoom, maxzoom);
    }
}
function createLayer(map, id, props) {
    // @ts-ignore
    if (map.style && map.style._loaded && (!('source' in props) || map.getSource(props.source))) {
        const options = {
            ...props,
            id
        };
        delete options.beforeId;
        // @ts-ignore
        map.addLayer(options, props.beforeId);
    }
}
/* eslint-enable complexity, max-statements */ let layerCounter = 0;
function Layer(props) {
    const map = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MapContext"]).map.getMap();
    const propsRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(props);
    const [, setStyleLoaded] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(0);
    const id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "Layer.useMemo[id]": ()=>props.id || `jsx-layer-${layerCounter++}`
    }["Layer.useMemo[id]"], []);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "Layer.useEffect": ()=>{
            if (map) {
                const forceUpdate = {
                    "Layer.useEffect.forceUpdate": ()=>setStyleLoaded({
                            "Layer.useEffect.forceUpdate": (version)=>version + 1
                        }["Layer.useEffect.forceUpdate"])
                }["Layer.useEffect.forceUpdate"];
                map.on('styledata', forceUpdate);
                forceUpdate();
                return ({
                    "Layer.useEffect": ()=>{
                        map.off('styledata', forceUpdate);
                        // @ts-ignore
                        if (map.style && map.style._loaded && map.getLayer(id)) {
                            map.removeLayer(id);
                        }
                    }
                })["Layer.useEffect"];
            }
            return undefined;
        }
    }["Layer.useEffect"], [
        map
    ]);
    // @ts-ignore
    const layer = map && map.style && map.getLayer(id);
    if (layer) {
        try {
            updateLayer(map, id, props, propsRef.current);
        } catch (error) {
            console.warn(error); // eslint-disable-line
        }
    } else {
        createLayer(map, id, props);
    }
    // Store last rendered props
    propsRef.current = props;
    return null;
} //# sourceMappingURL=layer.js.map
}}),
"[project]/node_modules/@vis.gl/react-maplibre/dist/types/common.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({});
;
 //# sourceMappingURL=common.js.map
}}),
"[project]/node_modules/@vis.gl/react-maplibre/dist/types/events.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({});
;
 //# sourceMappingURL=events.js.map
}}),
"[project]/node_modules/@vis.gl/react-maplibre/dist/types/lib.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({});
;
 //# sourceMappingURL=lib.js.map
}}),
"[project]/node_modules/@vis.gl/react-maplibre/dist/types/style-spec.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({});
;
 //# sourceMappingURL=style-spec.js.map
}}),
"[project]/node_modules/@vis.gl/react-maplibre/dist/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/components/map.js [app-client] (ecmascript)");
;
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Map"];
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@vis.gl/react-maplibre/dist/index.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/components/map.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$marker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/components/marker.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$popup$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/components/popup.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$attribution$2d$control$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/components/attribution-control.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$fullscreen$2d$control$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/components/fullscreen-control.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$geolocate$2d$control$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/components/geolocate-control.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$navigation$2d$control$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/components/navigation-control.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$scale$2d$control$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/components/scale-control.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$terrain$2d$control$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/components/terrain-control.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$logo$2d$control$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/components/logo-control.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$source$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/components/source.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/components/layer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$use$2d$control$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/components/use-control.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$components$2f$use$2d$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/components/use-map.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$types$2f$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/types/common.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$types$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/types/events.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$types$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/types/lib.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$types$2f$style$2d$spec$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/types/style-spec.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/index.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/react-map-gl/dist/maplibre.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({});
;
;
 //# sourceMappingURL=maplibre.js.map
}}),
"[project]/node_modules/react-map-gl/dist/maplibre.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vis$2e$gl$2f$react$2d$maplibre$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@vis.gl/react-maplibre/dist/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$map$2d$gl$2f$dist$2f$maplibre$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/react-map-gl/dist/maplibre.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/next/dist/build/webpack/loaders/next-flight-loader/action-client-wrapper.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
// This file must be bundled in the app's client layer, it shouldn't be directly
// imported by the server.
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    callServer: null,
    createServerReference: null,
    findSourceMapURL: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    callServer: function() {
        return _appcallserver.callServer;
    },
    createServerReference: function() {
        return createServerReference;
    },
    findSourceMapURL: function() {
        return _appfindsourcemapurl.findSourceMapURL;
    }
});
const _appcallserver = __turbopack_require__("[project]/node_modules/next/dist/client/app-call-server.js [app-client] (ecmascript)");
const _appfindsourcemapurl = __turbopack_require__("[project]/node_modules/next/dist/client/app-find-source-map-url.js [app-client] (ecmascript)");
const createServerReference = (("TURBOPACK compile-time falsy", 0) ? ("TURBOPACK unreachable", undefined) : __turbopack_require__("[project]/node_modules/next/dist/compiled/react-server-dom-turbopack/client.js [app-client] (ecmascript)")).createServerReference; //# sourceMappingURL=action-client-wrapper.js.map
}}),
"[project]/node_modules/next-themes/dist/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ThemeProvider": (()=>J),
    "useTheme": (()=>z)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
"use client";
;
var L = (e, r, s, u, d, m, l, h)=>{
    let c = document.documentElement, v = [
        "light",
        "dark"
    ];
    function p(i) {
        (Array.isArray(e) ? e : [
            e
        ]).forEach((y)=>{
            let k = y === "class", S = k && m ? d.map((f)=>m[f] || f) : d;
            k ? (c.classList.remove(...S), c.classList.add(i)) : c.setAttribute(y, i);
        }), R(i);
    }
    function R(i) {
        h && v.includes(i) && (c.style.colorScheme = i);
    }
    function a() {
        return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
    if (u) p(u);
    else try {
        let i = localStorage.getItem(r) || s, y = l && i === "system" ? a() : i;
        p(y);
    } catch (i) {}
};
var M = [
    "light",
    "dark"
], Q = "(prefers-color-scheme: dark)", U = typeof window == "undefined", E = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.createContext(void 0), N = {
    setTheme: (e)=>{},
    themes: []
}, z = ()=>{
    var e;
    return (e = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.useContext(E)) != null ? e : N;
}, J = (e)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.useContext(E) ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.createElement(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Fragment, null, e.children) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.createElement(_, {
        ...e
    }), V = [
    "light",
    "dark"
], _ = ({ forcedTheme: e, disableTransitionOnChange: r = !1, enableSystem: s = !0, enableColorScheme: u = !0, storageKey: d = "theme", themes: m = V, defaultTheme: l = s ? "system" : "light", attribute: h = "data-theme", value: c, children: v, nonce: p, scriptProps: R })=>{
    let [a, i] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.useState({
        "_.useState": ()=>b(d, l)
    }["_.useState"]), [w, y] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.useState({
        "_.useState": ()=>b(d)
    }["_.useState"]), k = c ? Object.values(c) : m, S = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.useCallback({
        "_.useCallback[S]": (n)=>{
            let o = n;
            if (!o) return;
            n === "system" && s && (o = I());
            let T = c ? c[o] : o, C = r ? W(p) : null, P = document.documentElement, x = {
                "_.useCallback[S].x": (g)=>{
                    g === "class" ? (P.classList.remove(...k), T && P.classList.add(T)) : g.startsWith("data-") && (T ? P.setAttribute(g, T) : P.removeAttribute(g));
                }
            }["_.useCallback[S].x"];
            if (Array.isArray(h) ? h.forEach(x) : x(h), u) {
                let g = M.includes(l) ? l : null, O = M.includes(o) ? o : g;
                P.style.colorScheme = O;
            }
            C == null || C();
        }
    }["_.useCallback[S]"], [
        p
    ]), f = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.useCallback({
        "_.useCallback[f]": (n)=>{
            let o = typeof n == "function" ? n(a) : n;
            i(o);
            try {
                localStorage.setItem(d, o);
            } catch (T) {}
        }
    }["_.useCallback[f]"], [
        a
    ]), A = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.useCallback({
        "_.useCallback[A]": (n)=>{
            let o = I(n);
            y(o), a === "system" && s && !e && S("system");
        }
    }["_.useCallback[A]"], [
        a,
        e
    ]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.useEffect({
        "_.useEffect": ()=>{
            let n = window.matchMedia(Q);
            return n.addListener(A), A(n), ({
                "_.useEffect": ()=>n.removeListener(A)
            })["_.useEffect"];
        }
    }["_.useEffect"], [
        A
    ]), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.useEffect({
        "_.useEffect": ()=>{
            let n = {
                "_.useEffect.n": (o)=>{
                    o.key === d && (o.newValue ? i(o.newValue) : f(l));
                }
            }["_.useEffect.n"];
            return window.addEventListener("storage", n), ({
                "_.useEffect": ()=>window.removeEventListener("storage", n)
            })["_.useEffect"];
        }
    }["_.useEffect"], [
        f
    ]), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.useEffect({
        "_.useEffect": ()=>{
            S(e != null ? e : a);
        }
    }["_.useEffect"], [
        e,
        a
    ]);
    let D = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.useMemo({
        "_.useMemo[D]": ()=>({
                theme: a,
                setTheme: f,
                forcedTheme: e,
                resolvedTheme: a === "system" ? w : a,
                themes: s ? [
                    ...m,
                    "system"
                ] : m,
                systemTheme: s ? w : void 0
            })
    }["_.useMemo[D]"], [
        a,
        f,
        e,
        w,
        s,
        m
    ]);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.createElement(E.Provider, {
        value: D
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.createElement(H, {
        forcedTheme: e,
        storageKey: d,
        attribute: h,
        enableSystem: s,
        enableColorScheme: u,
        defaultTheme: l,
        value: c,
        themes: m,
        nonce: p,
        scriptProps: R
    }), v);
}, H = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.memo(({ forcedTheme: e, storageKey: r, attribute: s, enableSystem: u, enableColorScheme: d, defaultTheme: m, value: l, themes: h, nonce: c, scriptProps: v })=>{
    let p = JSON.stringify([
        s,
        r,
        m,
        e,
        h,
        l,
        u,
        d
    ]).slice(1, -1);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.createElement("script", {
        ...v,
        suppressHydrationWarning: !0,
        nonce: typeof window == "undefined" ? c : "",
        dangerouslySetInnerHTML: {
            __html: `(${L.toString()})(${p})`
        }
    });
}), b = (e, r)=>{
    if (U) return;
    let s;
    try {
        s = localStorage.getItem(e) || void 0;
    } catch (u) {}
    return s || r;
}, W = (e)=>{
    let r = document.createElement("style");
    return e && r.setAttribute("nonce", e), r.appendChild(document.createTextNode("*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}")), document.head.appendChild(r), ()=>{
        window.getComputedStyle(document.body), setTimeout(()=>{
            document.head.removeChild(r);
        }, 1);
    };
}, I = (e)=>(e || (e = window.matchMedia(Q)), e.matches ? "dark" : "light");
;
}}),
"[project]/node_modules/@turf/turf/dist/esm/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({});
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/turf/dist/esm/index.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@turf/turf/dist/esm/index.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/@turf/turf/dist/esm/index.js [app-client] (ecmascript) <exports>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "along": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$along$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["along"]),
    "angle": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$angle$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["angle"]),
    "applyFilter": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clusters$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyFilter"]),
    "area": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$area$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["area"]),
    "areaFactors": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["areaFactors"]),
    "azimuthToBearing": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["azimuthToBearing"]),
    "bbox": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bbox"]),
    "bboxClip": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2d$clip$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bboxClip"]),
    "bboxPolygon": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bboxPolygon"]),
    "bearing": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bearing"]),
    "bearingToAzimuth": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bearingToAzimuth"]),
    "bezierSpline": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bezier$2d$spline$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bezierSpline"]),
    "booleanClockwise": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$clockwise$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanClockwise"]),
    "booleanConcave": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$concave$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanConcave"]),
    "booleanContains": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$contains$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanContains"]),
    "booleanCrosses": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$crosses$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanCrosses"]),
    "booleanDisjoint": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$disjoint$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanDisjoint"]),
    "booleanEqual": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$equal$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanEqual"]),
    "booleanIntersects": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$intersects$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanIntersects"]),
    "booleanOverlap": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$overlap$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanOverlap"]),
    "booleanParallel": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$parallel$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanParallel"]),
    "booleanPointInPolygon": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"]),
    "booleanPointOnLine": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"]),
    "booleanTouches": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$touches$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanTouches"]),
    "booleanValid": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$valid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanValid"]),
    "booleanWithin": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$within$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanWithin"]),
    "buffer": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$buffer$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["buffer"]),
    "center": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["center"]),
    "centerMean": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2d$mean$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["centerMean"]),
    "centerMedian": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2d$median$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["centerMedian"]),
    "centerOfMass": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2d$of$2d$mass$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["centerOfMass"]),
    "centroid": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["centroid"]),
    "circle": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$circle$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["circle"]),
    "cleanCoords": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clean$2d$coords$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cleanCoords"]),
    "clone": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"]),
    "cloneProperties": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cloneProperties"]),
    "clusterEach": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clusters$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clusterEach"]),
    "clusterReduce": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clusters$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clusterReduce"]),
    "clusters": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clusters$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__),
    "clustersDbscan": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clusters$2d$dbscan$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clustersDbscan"]),
    "clustersKmeans": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clusters$2d$kmeans$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clustersKmeans"]),
    "collect": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$collect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["collect"]),
    "collectionOf": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["collectionOf"]),
    "combine": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$combine$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["combine"]),
    "concave": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$concave$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["concave"]),
    "containsNumber": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["containsNumber"]),
    "convertArea": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertArea"]),
    "convertLength": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertLength"]),
    "convex": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$convex$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convex"]),
    "coordAll": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coordAll"]),
    "coordEach": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coordEach"]),
    "coordReduce": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coordReduce"]),
    "createBins": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clusters$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createBins"]),
    "degreesToRadians": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"]),
    "destination": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["destination"]),
    "difference": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$difference$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["difference"]),
    "dissolve": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$dissolve$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dissolve"]),
    "distance": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"]),
    "distanceWeight": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2d$weight$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distanceWeight"]),
    "earthRadius": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["earthRadius"]),
    "ellipse": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$ellipse$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ellipse"]),
    "envelope": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$envelope$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["envelope"]),
    "explode": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$explode$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["explode"]),
    "factors": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factors"]),
    "feature": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["feature"]),
    "featureCollection": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"]),
    "featureEach": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"]),
    "featureOf": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureOf"]),
    "featureReduce": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureReduce"]),
    "filterProperties": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clusters$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["filterProperties"]),
    "findPoint": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["findPoint"]),
    "findSegment": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["findSegment"]),
    "flatten": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$flatten$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["flatten"]),
    "flattenEach": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["flattenEach"]),
    "flattenReduce": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["flattenReduce"]),
    "flip": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$flip$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["flip"]),
    "geojsonRbush": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$geojson$2d$rbush$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["geojsonRbush"]),
    "geojsonType": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["geojsonType"]),
    "geomEach": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["geomEach"]),
    "geomReduce": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["geomReduce"]),
    "geometry": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["geometry"]),
    "geometryCollection": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["geometryCollection"]),
    "getCluster": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clusters$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCluster"]),
    "getCoord": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"]),
    "getCoords": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"]),
    "getGeom": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGeom"]),
    "getType": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getType"]),
    "greatCircle": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$great$2d$circle$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["greatCircle"]),
    "helpers": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__),
    "hexGrid": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$hex$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hexGrid"]),
    "interpolate": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$interpolate$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["interpolate"]),
    "intersect": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["intersect"]),
    "invariant": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__),
    "isNumber": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"]),
    "isObject": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"]),
    "isobands": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$isobands$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isobands"]),
    "isolines": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$isolines$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isolines"]),
    "kinks": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$kinks$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kinks"]),
    "length": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$length$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["length"]),
    "lengthToDegrees": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lengthToDegrees"]),
    "lengthToRadians": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lengthToRadians"]),
    "lineArc": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$arc$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineArc"]),
    "lineChunk": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$chunk$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineChunk"]),
    "lineEach": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineEach"]),
    "lineIntersect": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineIntersect"]),
    "lineOffset": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$offset$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineOffset"]),
    "lineOverlap": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$overlap$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineOverlap"]),
    "lineReduce": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineReduce"]),
    "lineSegment": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$segment$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineSegment"]),
    "lineSlice": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$slice$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineSlice"]),
    "lineSliceAlong": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$slice$2d$along$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineSliceAlong"]),
    "lineSplit": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$split$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineSplit"]),
    "lineString": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineString"]),
    "lineStrings": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineStrings"]),
    "lineToPolygon": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$to$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineToPolygon"]),
    "mask": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$mask$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mask"]),
    "meta": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__),
    "midpoint": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$midpoint$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["midpoint"]),
    "moranIndex": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$moran$2d$index$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["moranIndex"]),
    "multiLineString": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiLineString"]),
    "multiPoint": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiPoint"]),
    "multiPolygon": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiPolygon"]),
    "nearestNeighborAnalysis": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$neighbor$2d$analysis$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nearestNeighborAnalysis"]),
    "nearestPoint": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nearestPoint"]),
    "nearestPointOnLine": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nearestPointOnLine"]),
    "nearestPointToLine": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2d$to$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nearestPointToLine"]),
    "planepoint": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$planepoint$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["planepoint"]),
    "point": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"]),
    "pointGrid": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$point$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pointGrid"]),
    "pointOnFeature": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$point$2d$on$2d$feature$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pointOnFeature"]),
    "pointToLineDistance": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$point$2d$to$2d$line$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pointToLineDistance"]),
    "pointToPolygonDistance": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$point$2d$to$2d$polygon$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pointToPolygonDistance"]),
    "points": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["points"]),
    "pointsWithinPolygon": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$points$2d$within$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pointsWithinPolygon"]),
    "polygon": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"]),
    "polygonSmooth": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygon$2d$smooth$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygonSmooth"]),
    "polygonTangents": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygon$2d$tangents$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygonTangents"]),
    "polygonToLine": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygon$2d$to$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygonToLine"]),
    "polygonize": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygonize$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygonize"]),
    "polygons": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygons"]),
    "projection": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$projection$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__),
    "propEach": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["propEach"]),
    "propReduce": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["propReduce"]),
    "propertiesContainsFilter": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clusters$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["propertiesContainsFilter"]),
    "quadratAnalysis": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$quadrat$2d$analysis$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["quadratAnalysis"]),
    "radiansToDegrees": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["radiansToDegrees"]),
    "radiansToLength": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["radiansToLength"]),
    "random": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$random$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__),
    "randomLineString": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$random$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["randomLineString"]),
    "randomPoint": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$random$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["randomPoint"]),
    "randomPolygon": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$random$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["randomPolygon"]),
    "randomPosition": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$random$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["randomPosition"]),
    "rectangleGrid": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rectangle$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rectangleGrid"]),
    "rewind": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rewind$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rewind"]),
    "rhumbBearing": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rhumbBearing"]),
    "rhumbDestination": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rhumbDestination"]),
    "rhumbDistance": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rhumbDistance"]),
    "round": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["round"]),
    "sample": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$sample$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sample"]),
    "sector": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$sector$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sector"]),
    "segmentEach": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["segmentEach"]),
    "segmentReduce": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["segmentReduce"]),
    "shortestPath": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$shortest$2d$path$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shortestPath"]),
    "simplify": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$simplify$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["simplify"]),
    "square": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$square$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["square"]),
    "squareGrid": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$square$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["squareGrid"]),
    "standardDeviationalEllipse": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$standard$2d$deviational$2d$ellipse$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["standardDeviationalEllipse"]),
    "tag": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$tag$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["tag"]),
    "tesselate": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$tesselate$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["tesselate"]),
    "tin": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$tin$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["tin"]),
    "toMercator": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$projection$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toMercator"]),
    "toWgs84": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$projection$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toWgs84"]),
    "transformRotate": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$transform$2d$rotate$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transformRotate"]),
    "transformScale": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$transform$2d$scale$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transformScale"]),
    "transformTranslate": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$transform$2d$translate$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transformTranslate"]),
    "triangleGrid": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$triangle$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["triangleGrid"]),
    "truncate": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$truncate$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["truncate"]),
    "union": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$union$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"]),
    "unkinkPolygon": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$unkink$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unkinkPolygon"]),
    "validateBBox": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateBBox"]),
    "validateId": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateId"]),
    "voronoi": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$voronoi$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["voronoi"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$along$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/along/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$angle$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/angle/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$area$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/area/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2d$clip$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox-clip/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox-polygon/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bearing/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bezier$2d$spline$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bezier-spline/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$clockwise$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-clockwise/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$concave$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-concave/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$contains$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-contains/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$crosses$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-crosses/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$disjoint$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-disjoint/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$equal$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-equal/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$intersects$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-intersects/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$overlap$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-overlap/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$parallel$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-parallel/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-on-line/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$touches$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-touches/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$valid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-valid/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$within$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-within/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$buffer$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/buffer/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/center/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2d$mean$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/center-mean/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2d$median$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/center-median/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2d$of$2d$mass$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/center-of-mass/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/centroid/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$circle$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/circle/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clean$2d$coords$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clean-coords/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clusters$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clusters/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clusters$2d$dbscan$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clusters-dbscan/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clusters$2d$kmeans$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clusters-kmeans/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$collect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/collect/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$combine$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/combine/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$concave$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/concave/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$convex$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/convex/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/destination/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$difference$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/difference/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$dissolve$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/dissolve/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2d$weight$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance-weight/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$ellipse$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/ellipse/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$envelope$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/envelope/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$explode$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/explode/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$flatten$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/flatten/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$flip$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/flip/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$geojson$2d$rbush$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/geojson-rbush/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$great$2d$circle$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/great-circle/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$hex$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/hex-grid/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$interpolate$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/interpolate/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/intersect/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$isobands$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/isobands/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$isolines$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/isolines/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$kinks$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/kinks/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$length$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/length/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$arc$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-arc/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$chunk$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-chunk/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-intersect/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$offset$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-offset/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$overlap$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-overlap/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$segment$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-segment/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$slice$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-slice/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$slice$2d$along$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-slice-along/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$split$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-split/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$to$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-to-polygon/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$mask$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/mask/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$midpoint$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/midpoint/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$moran$2d$index$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/moran-index/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/nearest-point/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/nearest-point-on-line/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2d$to$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/nearest-point-to-line/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$planepoint$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/planepoint/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$point$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/point-grid/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$point$2d$on$2d$feature$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/point-on-feature/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$point$2d$to$2d$line$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/point-to-line-distance/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$point$2d$to$2d$polygon$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/point-to-polygon-distance/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$points$2d$within$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/points-within-polygon/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygon$2d$smooth$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/polygon-smooth/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygon$2d$tangents$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/polygon-tangents/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygon$2d$to$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/polygon-to-line/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygonize$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/polygonize/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$projection$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/projection/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$random$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/random/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rectangle$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rectangle-grid/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rewind$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rewind/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rhumb-bearing/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rhumb-destination/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rhumb-distance/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$sample$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/sample/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$sector$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/sector/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$shortest$2d$path$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/shortest-path/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$simplify$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/simplify/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$square$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/square/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$square$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/square-grid/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$standard$2d$deviational$2d$ellipse$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/standard-deviational-ellipse/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$tag$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/tag/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$tesselate$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/tesselate/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$tin$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/tin/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$transform$2d$rotate$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/transform-rotate/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$transform$2d$scale$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/transform-scale/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$transform$2d$translate$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/transform-translate/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$triangle$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/triangle-grid/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$truncate$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/truncate/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$union$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/union/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$unkink$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/unkink-polygon/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$voronoi$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/voronoi/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$neighbor$2d$analysis$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/nearest-neighbor-analysis/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$quadrat$2d$analysis$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/quadrat-analysis/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@turf/turf/dist/esm/index.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/@turf/turf/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "along": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["along"]),
    "angle": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["angle"]),
    "applyFilter": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["applyFilter"]),
    "area": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["area"]),
    "areaFactors": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["areaFactors"]),
    "azimuthToBearing": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["azimuthToBearing"]),
    "bbox": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["bbox"]),
    "bboxClip": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["bboxClip"]),
    "bboxPolygon": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["bboxPolygon"]),
    "bearing": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["bearing"]),
    "bearingToAzimuth": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["bearingToAzimuth"]),
    "bezierSpline": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["bezierSpline"]),
    "booleanClockwise": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["booleanClockwise"]),
    "booleanConcave": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["booleanConcave"]),
    "booleanContains": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["booleanContains"]),
    "booleanCrosses": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["booleanCrosses"]),
    "booleanDisjoint": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["booleanDisjoint"]),
    "booleanEqual": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["booleanEqual"]),
    "booleanIntersects": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["booleanIntersects"]),
    "booleanOverlap": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["booleanOverlap"]),
    "booleanParallel": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["booleanParallel"]),
    "booleanPointInPolygon": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["booleanPointInPolygon"]),
    "booleanPointOnLine": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["booleanPointOnLine"]),
    "booleanTouches": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["booleanTouches"]),
    "booleanValid": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["booleanValid"]),
    "booleanWithin": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["booleanWithin"]),
    "buffer": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["buffer"]),
    "center": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["center"]),
    "centerMean": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["centerMean"]),
    "centerMedian": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["centerMedian"]),
    "centerOfMass": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["centerOfMass"]),
    "centroid": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["centroid"]),
    "circle": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["circle"]),
    "cleanCoords": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["cleanCoords"]),
    "clone": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["clone"]),
    "cloneProperties": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["cloneProperties"]),
    "clusterEach": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["clusterEach"]),
    "clusterReduce": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["clusterReduce"]),
    "clusters": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["clusters"]),
    "clustersDbscan": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["clustersDbscan"]),
    "clustersKmeans": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["clustersKmeans"]),
    "collect": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["collect"]),
    "collectionOf": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["collectionOf"]),
    "combine": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["combine"]),
    "concave": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["concave"]),
    "containsNumber": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["containsNumber"]),
    "convertArea": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["convertArea"]),
    "convertLength": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["convertLength"]),
    "convex": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["convex"]),
    "coordAll": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["coordAll"]),
    "coordEach": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["coordEach"]),
    "coordReduce": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["coordReduce"]),
    "createBins": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["createBins"]),
    "degreesToRadians": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["degreesToRadians"]),
    "destination": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["destination"]),
    "difference": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["difference"]),
    "dissolve": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["dissolve"]),
    "distance": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["distance"]),
    "distanceWeight": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["distanceWeight"]),
    "earthRadius": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["earthRadius"]),
    "ellipse": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["ellipse"]),
    "envelope": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["envelope"]),
    "explode": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["explode"]),
    "factors": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["factors"]),
    "feature": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["feature"]),
    "featureCollection": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["featureCollection"]),
    "featureEach": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["featureEach"]),
    "featureOf": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["featureOf"]),
    "featureReduce": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["featureReduce"]),
    "filterProperties": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["filterProperties"]),
    "findPoint": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["findPoint"]),
    "findSegment": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["findSegment"]),
    "flatten": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["flatten"]),
    "flattenEach": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["flattenEach"]),
    "flattenReduce": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["flattenReduce"]),
    "flip": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["flip"]),
    "geojsonRbush": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["geojsonRbush"]),
    "geojsonType": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["geojsonType"]),
    "geomEach": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["geomEach"]),
    "geomReduce": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["geomReduce"]),
    "geometry": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["geometry"]),
    "geometryCollection": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["geometryCollection"]),
    "getCluster": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["getCluster"]),
    "getCoord": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["getCoord"]),
    "getCoords": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["getCoords"]),
    "getGeom": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["getGeom"]),
    "getType": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["getType"]),
    "greatCircle": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["greatCircle"]),
    "helpers": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["helpers"]),
    "hexGrid": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["hexGrid"]),
    "interpolate": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["interpolate"]),
    "intersect": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["intersect"]),
    "invariant": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["invariant"]),
    "isNumber": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["isNumber"]),
    "isObject": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["isObject"]),
    "isobands": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["isobands"]),
    "isolines": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["isolines"]),
    "kinks": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["kinks"]),
    "length": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["length"]),
    "lengthToDegrees": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["lengthToDegrees"]),
    "lengthToRadians": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["lengthToRadians"]),
    "lineArc": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["lineArc"]),
    "lineChunk": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["lineChunk"]),
    "lineEach": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["lineEach"]),
    "lineIntersect": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["lineIntersect"]),
    "lineOffset": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["lineOffset"]),
    "lineOverlap": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["lineOverlap"]),
    "lineReduce": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["lineReduce"]),
    "lineSegment": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["lineSegment"]),
    "lineSlice": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["lineSlice"]),
    "lineSliceAlong": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["lineSliceAlong"]),
    "lineSplit": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["lineSplit"]),
    "lineString": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["lineString"]),
    "lineStrings": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["lineStrings"]),
    "lineToPolygon": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["lineToPolygon"]),
    "mask": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["mask"]),
    "meta": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["meta"]),
    "midpoint": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["midpoint"]),
    "moranIndex": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["moranIndex"]),
    "multiLineString": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["multiLineString"]),
    "multiPoint": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["multiPoint"]),
    "multiPolygon": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["multiPolygon"]),
    "nearestNeighborAnalysis": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["nearestNeighborAnalysis"]),
    "nearestPoint": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["nearestPoint"]),
    "nearestPointOnLine": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["nearestPointOnLine"]),
    "nearestPointToLine": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["nearestPointToLine"]),
    "planepoint": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["planepoint"]),
    "point": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["point"]),
    "pointGrid": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["pointGrid"]),
    "pointOnFeature": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["pointOnFeature"]),
    "pointToLineDistance": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["pointToLineDistance"]),
    "pointToPolygonDistance": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["pointToPolygonDistance"]),
    "points": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["points"]),
    "pointsWithinPolygon": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["pointsWithinPolygon"]),
    "polygon": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["polygon"]),
    "polygonSmooth": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["polygonSmooth"]),
    "polygonTangents": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["polygonTangents"]),
    "polygonToLine": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["polygonToLine"]),
    "polygonize": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["polygonize"]),
    "polygons": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["polygons"]),
    "projection": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["projection"]),
    "propEach": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["propEach"]),
    "propReduce": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["propReduce"]),
    "propertiesContainsFilter": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["propertiesContainsFilter"]),
    "quadratAnalysis": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["quadratAnalysis"]),
    "radiansToDegrees": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["radiansToDegrees"]),
    "radiansToLength": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["radiansToLength"]),
    "random": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["random"]),
    "randomLineString": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["randomLineString"]),
    "randomPoint": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["randomPoint"]),
    "randomPolygon": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["randomPolygon"]),
    "randomPosition": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["randomPosition"]),
    "rectangleGrid": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["rectangleGrid"]),
    "rewind": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["rewind"]),
    "rhumbBearing": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["rhumbBearing"]),
    "rhumbDestination": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["rhumbDestination"]),
    "rhumbDistance": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["rhumbDistance"]),
    "round": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["round"]),
    "sample": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["sample"]),
    "sector": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["sector"]),
    "segmentEach": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["segmentEach"]),
    "segmentReduce": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["segmentReduce"]),
    "shortestPath": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["shortestPath"]),
    "simplify": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["simplify"]),
    "square": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["square"]),
    "squareGrid": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["squareGrid"]),
    "standardDeviationalEllipse": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["standardDeviationalEllipse"]),
    "tag": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["tag"]),
    "tesselate": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["tesselate"]),
    "tin": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["tin"]),
    "toMercator": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["toMercator"]),
    "toWgs84": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["toWgs84"]),
    "transformRotate": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["transformRotate"]),
    "transformScale": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["transformScale"]),
    "transformTranslate": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["transformTranslate"]),
    "triangleGrid": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["triangleGrid"]),
    "truncate": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["truncate"]),
    "union": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["union"]),
    "unkinkPolygon": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["unkinkPolygon"]),
    "validateBBox": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["validateBBox"]),
    "validateId": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["validateId"]),
    "voronoi": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["voronoi"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@turf/turf/dist/esm/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$turf$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__ = __turbopack_import__("[project]/node_modules/@turf/turf/dist/esm/index.js [app-client] (ecmascript) <exports>");
}}),
"[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "areaFactors": (()=>areaFactors),
    "azimuthToBearing": (()=>azimuthToBearing),
    "bearingToAzimuth": (()=>bearingToAzimuth),
    "convertArea": (()=>convertArea),
    "convertLength": (()=>convertLength),
    "degreesToRadians": (()=>degreesToRadians),
    "earthRadius": (()=>earthRadius),
    "factors": (()=>factors),
    "feature": (()=>feature),
    "featureCollection": (()=>featureCollection),
    "geometry": (()=>geometry),
    "geometryCollection": (()=>geometryCollection),
    "isNumber": (()=>isNumber),
    "isObject": (()=>isObject),
    "lengthToDegrees": (()=>lengthToDegrees),
    "lengthToRadians": (()=>lengthToRadians),
    "lineString": (()=>lineString),
    "lineStrings": (()=>lineStrings),
    "multiLineString": (()=>multiLineString),
    "multiPoint": (()=>multiPoint),
    "multiPolygon": (()=>multiPolygon),
    "point": (()=>point),
    "points": (()=>points),
    "polygon": (()=>polygon),
    "polygons": (()=>polygons),
    "radiansToDegrees": (()=>radiansToDegrees),
    "radiansToLength": (()=>radiansToLength),
    "round": (()=>round),
    "validateBBox": (()=>validateBBox),
    "validateId": (()=>validateId)
});
var earthRadius = 63710088e-1;
var factors = {
    centimeters: earthRadius * 100,
    centimetres: earthRadius * 100,
    degrees: 360 / (2 * Math.PI),
    feet: earthRadius * 3.28084,
    inches: earthRadius * 39.37,
    kilometers: earthRadius / 1e3,
    kilometres: earthRadius / 1e3,
    meters: earthRadius,
    metres: earthRadius,
    miles: earthRadius / 1609.344,
    millimeters: earthRadius * 1e3,
    millimetres: earthRadius * 1e3,
    nauticalmiles: earthRadius / 1852,
    radians: 1,
    yards: earthRadius * 1.0936
};
var areaFactors = {
    acres: 247105e-9,
    centimeters: 1e4,
    centimetres: 1e4,
    feet: 10.763910417,
    hectares: 1e-4,
    inches: 1550.003100006,
    kilometers: 1e-6,
    kilometres: 1e-6,
    meters: 1,
    metres: 1,
    miles: 386e-9,
    nauticalmiles: 29155334959812285e-23,
    millimeters: 1e6,
    millimetres: 1e6,
    yards: 1.195990046
};
function feature(geom, properties, options = {}) {
    const feat = {
        type: "Feature"
    };
    if (options.id === 0 || options.id) {
        feat.id = options.id;
    }
    if (options.bbox) {
        feat.bbox = options.bbox;
    }
    feat.properties = properties || {};
    feat.geometry = geom;
    return feat;
}
function geometry(type, coordinates, _options = {}) {
    switch(type){
        case "Point":
            return point(coordinates).geometry;
        case "LineString":
            return lineString(coordinates).geometry;
        case "Polygon":
            return polygon(coordinates).geometry;
        case "MultiPoint":
            return multiPoint(coordinates).geometry;
        case "MultiLineString":
            return multiLineString(coordinates).geometry;
        case "MultiPolygon":
            return multiPolygon(coordinates).geometry;
        default:
            throw new Error(type + " is invalid");
    }
}
function point(coordinates, properties, options = {}) {
    if (!coordinates) {
        throw new Error("coordinates is required");
    }
    if (!Array.isArray(coordinates)) {
        throw new Error("coordinates must be an Array");
    }
    if (coordinates.length < 2) {
        throw new Error("coordinates must be at least 2 numbers long");
    }
    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {
        throw new Error("coordinates must contain numbers");
    }
    const geom = {
        type: "Point",
        coordinates
    };
    return feature(geom, properties, options);
}
function points(coordinates, properties, options = {}) {
    return featureCollection(coordinates.map((coords)=>{
        return point(coords, properties);
    }), options);
}
function polygon(coordinates, properties, options = {}) {
    for (const ring of coordinates){
        if (ring.length < 4) {
            throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
        }
        if (ring[ring.length - 1].length !== ring[0].length) {
            throw new Error("First and last Position are not equivalent.");
        }
        for(let j = 0; j < ring[ring.length - 1].length; j++){
            if (ring[ring.length - 1][j] !== ring[0][j]) {
                throw new Error("First and last Position are not equivalent.");
            }
        }
    }
    const geom = {
        type: "Polygon",
        coordinates
    };
    return feature(geom, properties, options);
}
function polygons(coordinates, properties, options = {}) {
    return featureCollection(coordinates.map((coords)=>{
        return polygon(coords, properties);
    }), options);
}
function lineString(coordinates, properties, options = {}) {
    if (coordinates.length < 2) {
        throw new Error("coordinates must be an array of two or more positions");
    }
    const geom = {
        type: "LineString",
        coordinates
    };
    return feature(geom, properties, options);
}
function lineStrings(coordinates, properties, options = {}) {
    return featureCollection(coordinates.map((coords)=>{
        return lineString(coords, properties);
    }), options);
}
function featureCollection(features, options = {}) {
    const fc = {
        type: "FeatureCollection"
    };
    if (options.id) {
        fc.id = options.id;
    }
    if (options.bbox) {
        fc.bbox = options.bbox;
    }
    fc.features = features;
    return fc;
}
function multiLineString(coordinates, properties, options = {}) {
    const geom = {
        type: "MultiLineString",
        coordinates
    };
    return feature(geom, properties, options);
}
function multiPoint(coordinates, properties, options = {}) {
    const geom = {
        type: "MultiPoint",
        coordinates
    };
    return feature(geom, properties, options);
}
function multiPolygon(coordinates, properties, options = {}) {
    const geom = {
        type: "MultiPolygon",
        coordinates
    };
    return feature(geom, properties, options);
}
function geometryCollection(geometries, properties, options = {}) {
    const geom = {
        type: "GeometryCollection",
        geometries
    };
    return feature(geom, properties, options);
}
function round(num, precision = 0) {
    if (precision && !(precision >= 0)) {
        throw new Error("precision must be a positive number");
    }
    const multiplier = Math.pow(10, precision || 0);
    return Math.round(num * multiplier) / multiplier;
}
function radiansToLength(radians, units = "kilometers") {
    const factor = factors[units];
    if (!factor) {
        throw new Error(units + " units is invalid");
    }
    return radians * factor;
}
function lengthToRadians(distance, units = "kilometers") {
    const factor = factors[units];
    if (!factor) {
        throw new Error(units + " units is invalid");
    }
    return distance / factor;
}
function lengthToDegrees(distance, units) {
    return radiansToDegrees(lengthToRadians(distance, units));
}
function bearingToAzimuth(bearing) {
    let angle = bearing % 360;
    if (angle < 0) {
        angle += 360;
    }
    return angle;
}
function azimuthToBearing(angle) {
    angle = angle % 360;
    if (angle > 180) {
        return angle - 360;
    } else if (angle < -180) {
        return angle + 360;
    }
    return angle;
}
function radiansToDegrees(radians) {
    const normalisedRadians = radians % (2 * Math.PI);
    return normalisedRadians * 180 / Math.PI;
}
function degreesToRadians(degrees) {
    const normalisedDegrees = degrees % 360;
    return normalisedDegrees * Math.PI / 180;
}
function convertLength(length, originalUnit = "kilometers", finalUnit = "kilometers") {
    if (!(length >= 0)) {
        throw new Error("length must be a positive number");
    }
    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);
}
function convertArea(area, originalUnit = "meters", finalUnit = "kilometers") {
    if (!(area >= 0)) {
        throw new Error("area must be a positive number");
    }
    const startFactor = areaFactors[originalUnit];
    if (!startFactor) {
        throw new Error("invalid original units");
    }
    const finalFactor = areaFactors[finalUnit];
    if (!finalFactor) {
        throw new Error("invalid final units");
    }
    return area / startFactor * finalFactor;
}
function isNumber(num) {
    return !isNaN(num) && num !== null && !Array.isArray(num);
}
function isObject(input) {
    return input !== null && typeof input === "object" && !Array.isArray(input);
}
function validateBBox(bbox) {
    if (!bbox) {
        throw new Error("bbox is required");
    }
    if (!Array.isArray(bbox)) {
        throw new Error("bbox must be an Array");
    }
    if (bbox.length !== 4 && bbox.length !== 6) {
        throw new Error("bbox must be an Array of 4 or 6 numbers");
    }
    bbox.forEach((num)=>{
        if (!isNumber(num)) {
            throw new Error("bbox must only contain numbers");
        }
    });
}
function validateId(id) {
    if (!id) {
        throw new Error("id is required");
    }
    if ([
        "string",
        "number"
    ].indexOf(typeof id) === -1) {
        throw new Error("id must be a number or a string");
    }
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "collectionOf": (()=>collectionOf),
    "containsNumber": (()=>containsNumber),
    "featureOf": (()=>featureOf),
    "geojsonType": (()=>geojsonType),
    "getCoord": (()=>getCoord),
    "getCoords": (()=>getCoords),
    "getGeom": (()=>getGeom),
    "getType": (()=>getType)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
function getCoord(coord) {
    if (!coord) {
        throw new Error("coord is required");
    }
    if (!Array.isArray(coord)) {
        if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
            return [
                ...coord.geometry.coordinates
            ];
        }
        if (coord.type === "Point") {
            return [
                ...coord.coordinates
            ];
        }
    }
    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
        return [
            ...coord
        ];
    }
    throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
function getCoords(coords) {
    if (Array.isArray(coords)) {
        return coords;
    }
    if (coords.type === "Feature") {
        if (coords.geometry !== null) {
            return coords.geometry.coordinates;
        }
    } else {
        if (coords.coordinates) {
            return coords.coordinates;
        }
    }
    throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}
function containsNumber(coordinates) {
    if (coordinates.length > 1 && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(coordinates[0]) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(coordinates[1])) {
        return true;
    }
    if (Array.isArray(coordinates[0]) && coordinates[0].length) {
        return containsNumber(coordinates[0]);
    }
    throw new Error("coordinates must only contain numbers");
}
function geojsonType(value, type, name) {
    if (!type || !name) {
        throw new Error("type and name required");
    }
    if (!value || value.type !== type) {
        throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + value.type);
    }
}
function featureOf(feature, type, name) {
    if (!feature) {
        throw new Error("No feature passed");
    }
    if (!name) {
        throw new Error(".featureOf() requires a name");
    }
    if (!feature || feature.type !== "Feature" || !feature.geometry) {
        throw new Error("Invalid input to " + name + ", Feature with geometry required");
    }
    if (!feature.geometry || feature.geometry.type !== type) {
        throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature.geometry.type);
    }
}
function collectionOf(featureCollection, type, name) {
    if (!featureCollection) {
        throw new Error("No featureCollection passed");
    }
    if (!name) {
        throw new Error(".collectionOf() requires a name");
    }
    if (!featureCollection || featureCollection.type !== "FeatureCollection") {
        throw new Error("Invalid input to " + name + ", FeatureCollection required");
    }
    for (const feature of featureCollection.features){
        if (!feature || feature.type !== "Feature" || !feature.geometry) {
            throw new Error("Invalid input to " + name + ", Feature with geometry required");
        }
        if (!feature.geometry || feature.geometry.type !== type) {
            throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature.geometry.type);
        }
    }
}
function getGeom(geojson) {
    if (geojson.type === "Feature") {
        return geojson.geometry;
    }
    return geojson;
}
function getType(geojson, _name) {
    if (geojson.type === "FeatureCollection") {
        return "FeatureCollection";
    }
    if (geojson.type === "GeometryCollection") {
        return "GeometryCollection";
    }
    if (geojson.type === "Feature" && geojson.geometry !== null) {
        return geojson.geometry.type;
    }
    return geojson.type;
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/bearing/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "bearing": (()=>bearing),
    "default": (()=>turf_bearing_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
;
function bearing(start, end, options = {}) {
    if (options.final === true) {
        return calculateFinalBearing(start, end);
    }
    const coordinates1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(start);
    const coordinates2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(end);
    const lon1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])(coordinates1[0]);
    const lon2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])(coordinates2[0]);
    const lat1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])(coordinates1[1]);
    const lat2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])(coordinates2[1]);
    const a = Math.sin(lon2 - lon1) * Math.cos(lat2);
    const b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["radiansToDegrees"])(Math.atan2(a, b));
}
function calculateFinalBearing(start, end) {
    let bear = bearing(end, start);
    bear = (bear + 180) % 360;
    return bear;
}
var turf_bearing_default = bearing;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/destination/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_destination_default),
    "destination": (()=>destination)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
;
function destination(origin, distance, bearing, options = {}) {
    const coordinates1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(origin);
    const longitude1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])(coordinates1[0]);
    const latitude1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])(coordinates1[1]);
    const bearingRad = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])(bearing);
    const radians = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lengthToRadians"])(distance, options.units);
    const latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) + Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));
    const longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));
    const lng = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["radiansToDegrees"])(longitude2);
    const lat = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["radiansToDegrees"])(latitude2);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])([
        lng,
        lat
    ], options.properties);
}
var turf_destination_default = destination;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/distance/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_distance_default),
    "distance": (()=>distance)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
;
function distance(from, to, options = {}) {
    var coordinates1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(from);
    var coordinates2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(to);
    var dLat = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])(coordinates2[1] - coordinates1[1]);
    var dLon = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])(coordinates2[0] - coordinates1[0]);
    var lat1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])(coordinates1[1]);
    var lat2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])(coordinates2[1]);
    var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["radiansToLength"])(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);
}
var turf_distance_default = distance;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/along/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "along": (()=>along),
    "default": (()=>turf_along_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bearing/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/destination/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
;
function along(line, distance, options = {}) {
    const geom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGeom"])(line);
    const coords = geom.coordinates;
    let travelled = 0;
    for(let i = 0; i < coords.length; i++){
        if (distance >= travelled && i === coords.length - 1) {
            break;
        } else if (travelled >= distance) {
            const overshot = distance - travelled;
            if (!overshot) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])(coords[i]);
            } else {
                const direction = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bearing"])(coords[i], coords[i - 1]) - 180;
                const interpolated = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["destination"])(coords[i], overshot, direction, options);
                return interpolated;
            }
        } else {
            travelled += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(coords[i], coords[i + 1], options);
        }
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])(coords[coords.length - 1]);
}
var turf_along_default = along;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/rhumb-bearing/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_rhumb_bearing_default),
    "rhumbBearing": (()=>rhumbBearing)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
;
function rhumbBearing(start, end, options = {}) {
    let bear360;
    if (options.final) {
        bear360 = calculateRhumbBearing((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(end), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(start));
    } else {
        bear360 = calculateRhumbBearing((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(start), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(end));
    }
    const bear180 = bear360 > 180 ? -(360 - bear360) : bear360;
    return bear180;
}
function calculateRhumbBearing(from, to) {
    const phi1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])(from[1]);
    const phi2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])(to[1]);
    let deltaLambda = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])(to[0] - from[0]);
    if (deltaLambda > Math.PI) {
        deltaLambda -= 2 * Math.PI;
    }
    if (deltaLambda < -Math.PI) {
        deltaLambda += 2 * Math.PI;
    }
    const deltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
    const theta = Math.atan2(deltaLambda, deltaPsi);
    return ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["radiansToDegrees"])(theta) + 360) % 360;
}
var turf_rhumb_bearing_default = rhumbBearing;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/angle/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "angle": (()=>angle),
    "default": (()=>turf_angle_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rhumb-bearing/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bearing/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
function angle(startPoint, midPoint, endPoint, options = {}) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(options)) {
        throw new Error("options is invalid");
    }
    if (!startPoint) {
        throw new Error("startPoint is required");
    }
    if (!midPoint) {
        throw new Error("midPoint is required");
    }
    if (!endPoint) {
        throw new Error("endPoint is required");
    }
    const A = startPoint;
    const O = midPoint;
    const B = endPoint;
    const azimuthOA = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bearingToAzimuth"])(options.mercator !== true ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bearing"])(O, A) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rhumbBearing"])(O, A));
    let azimuthOB = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bearingToAzimuth"])(options.mercator !== true ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bearing"])(O, B) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rhumbBearing"])(O, B));
    if (azimuthOB < azimuthOA) {
        azimuthOB = azimuthOB + 360;
    }
    const angleAOB = azimuthOB - azimuthOA;
    if (options.explementary === true) {
        return 360 - angleAOB;
    }
    return angleAOB;
}
var turf_angle_default = angle;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.js
__turbopack_esm__({
    "coordAll": (()=>coordAll),
    "coordEach": (()=>coordEach),
    "coordReduce": (()=>coordReduce),
    "featureEach": (()=>featureEach),
    "featureReduce": (()=>featureReduce),
    "findPoint": (()=>findPoint),
    "findSegment": (()=>findSegment),
    "flattenEach": (()=>flattenEach),
    "flattenReduce": (()=>flattenReduce),
    "geomEach": (()=>geomEach),
    "geomReduce": (()=>geomReduce),
    "lineEach": (()=>lineEach),
    "lineReduce": (()=>lineReduce),
    "propEach": (()=>propEach),
    "propReduce": (()=>propReduce),
    "segmentEach": (()=>segmentEach),
    "segmentReduce": (()=>segmentReduce)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
function coordEach(geojson, callback, excludeWrapCoord) {
    if (geojson === null) return;
    var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === "FeatureCollection", isFeature = type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
    for(var featureIndex = 0; featureIndex < stop; featureIndex++){
        geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
        isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
        for(var geomIndex = 0; geomIndex < stopG; geomIndex++){
            var multiFeatureIndex = 0;
            var geometryIndex = 0;
            geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;
            if (geometry === null) continue;
            coords = geometry.coordinates;
            var geomType = geometry.type;
            wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;
            switch(geomType){
                case null:
                    break;
                case "Point":
                    if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                    coordIndex++;
                    multiFeatureIndex++;
                    break;
                case "LineString":
                case "MultiPoint":
                    for(j = 0; j < coords.length; j++){
                        if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                        coordIndex++;
                        if (geomType === "MultiPoint") multiFeatureIndex++;
                    }
                    if (geomType === "LineString") multiFeatureIndex++;
                    break;
                case "Polygon":
                case "MultiLineString":
                    for(j = 0; j < coords.length; j++){
                        for(k = 0; k < coords[j].length - wrapShrink; k++){
                            if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                            coordIndex++;
                        }
                        if (geomType === "MultiLineString") multiFeatureIndex++;
                        if (geomType === "Polygon") geometryIndex++;
                    }
                    if (geomType === "Polygon") multiFeatureIndex++;
                    break;
                case "MultiPolygon":
                    for(j = 0; j < coords.length; j++){
                        geometryIndex = 0;
                        for(k = 0; k < coords[j].length; k++){
                            for(l = 0; l < coords[j][k].length - wrapShrink; l++){
                                if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                                coordIndex++;
                            }
                            geometryIndex++;
                        }
                        multiFeatureIndex++;
                    }
                    break;
                case "GeometryCollection":
                    for(j = 0; j < geometry.geometries.length; j++)if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;
                    break;
                default:
                    throw new Error("Unknown Geometry Type");
            }
        }
    }
}
function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
    var previousValue = initialValue;
    coordEach(geojson, function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
        if (coordIndex === 0 && initialValue === void 0) previousValue = currentCoord;
        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);
    }, excludeWrapCoord);
    return previousValue;
}
function propEach(geojson, callback) {
    var i;
    switch(geojson.type){
        case "FeatureCollection":
            for(i = 0; i < geojson.features.length; i++){
                if (callback(geojson.features[i].properties, i) === false) break;
            }
            break;
        case "Feature":
            callback(geojson.properties, 0);
            break;
    }
}
function propReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    propEach(geojson, function(currentProperties, featureIndex) {
        if (featureIndex === 0 && initialValue === void 0) previousValue = currentProperties;
        else previousValue = callback(previousValue, currentProperties, featureIndex);
    });
    return previousValue;
}
function featureEach(geojson, callback) {
    if (geojson.type === "Feature") {
        callback(geojson, 0);
    } else if (geojson.type === "FeatureCollection") {
        for(var i = 0; i < geojson.features.length; i++){
            if (callback(geojson.features[i], i) === false) break;
        }
    }
}
function featureReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    featureEach(geojson, function(currentFeature, featureIndex) {
        if (featureIndex === 0 && initialValue === void 0) previousValue = currentFeature;
        else previousValue = callback(previousValue, currentFeature, featureIndex);
    });
    return previousValue;
}
function coordAll(geojson) {
    var coords = [];
    coordEach(geojson, function(coord) {
        coords.push(coord);
    });
    return coords;
}
function geomEach(geojson, callback) {
    var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
    for(i = 0; i < stop; i++){
        geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;
        featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};
        featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;
        featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;
        isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
        for(g = 0; g < stopG; g++){
            geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
            if (geometry === null) {
                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;
                continue;
            }
            switch(geometry.type){
                case "Point":
                case "LineString":
                case "MultiPoint":
                case "Polygon":
                case "MultiLineString":
                case "MultiPolygon":
                    {
                        if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;
                        break;
                    }
                case "GeometryCollection":
                    {
                        for(j = 0; j < geometry.geometries.length; j++){
                            if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;
                        }
                        break;
                    }
                default:
                    throw new Error("Unknown Geometry Type");
            }
        }
        featureIndex++;
    }
}
function geomReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    geomEach(geojson, function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
        if (featureIndex === 0 && initialValue === void 0) previousValue = currentGeometry;
        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);
    });
    return previousValue;
}
function flattenEach(geojson, callback) {
    geomEach(geojson, function(geometry, featureIndex, properties, bbox, id) {
        var type = geometry === null ? null : geometry.type;
        switch(type){
            case null:
            case "Point":
            case "LineString":
            case "Polygon":
                if (callback((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["feature"])(geometry, properties, {
                    bbox,
                    id
                }), featureIndex, 0) === false) return false;
                return;
        }
        var geomType;
        switch(type){
            case "MultiPoint":
                geomType = "Point";
                break;
            case "MultiLineString":
                geomType = "LineString";
                break;
            case "MultiPolygon":
                geomType = "Polygon";
                break;
        }
        for(var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++){
            var coordinate = geometry.coordinates[multiFeatureIndex];
            var geom = {
                type: geomType,
                coordinates: coordinate
            };
            if (callback((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["feature"])(geom, properties), featureIndex, multiFeatureIndex) === false) return false;
        }
    });
}
function flattenReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    flattenEach(geojson, function(currentFeature, featureIndex, multiFeatureIndex) {
        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === void 0) previousValue = currentFeature;
        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);
    });
    return previousValue;
}
function segmentEach(geojson, callback) {
    flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {
        var segmentIndex = 0;
        if (!feature2.geometry) return;
        var type = feature2.geometry.type;
        if (type === "Point" || type === "MultiPoint") return;
        var previousCoords;
        var previousFeatureIndex = 0;
        var previousMultiIndex = 0;
        var prevGeomIndex = 0;
        if (coordEach(feature2, function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {
            if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {
                previousCoords = currentCoord;
                previousFeatureIndex = featureIndex;
                previousMultiIndex = multiPartIndexCoord;
                prevGeomIndex = geometryIndex;
                segmentIndex = 0;
                return;
            }
            var currentSegment = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineString"])([
                previousCoords,
                currentCoord
            ], feature2.properties);
            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;
            segmentIndex++;
            previousCoords = currentCoord;
        }) === false) return false;
    });
}
function segmentReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    var started = false;
    segmentEach(geojson, function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
        if (started === false && initialValue === void 0) previousValue = currentSegment;
        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);
        started = true;
    });
    return previousValue;
}
function lineEach(geojson, callback) {
    if (!geojson) throw new Error("geojson is required");
    flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {
        if (feature2.geometry === null) return;
        var type = feature2.geometry.type;
        var coords = feature2.geometry.coordinates;
        switch(type){
            case "LineString":
                if (callback(feature2, featureIndex, multiFeatureIndex, 0, 0) === false) return false;
                break;
            case "Polygon":
                for(var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++){
                    if (callback((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineString"])(coords[geometryIndex], feature2.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                }
                break;
        }
    });
}
function lineReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    lineEach(geojson, function(currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
        if (featureIndex === 0 && initialValue === void 0) previousValue = currentLine;
        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);
    });
    return previousValue;
}
function findSegment(geojson, options) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    var featureIndex = options.featureIndex || 0;
    var multiFeatureIndex = options.multiFeatureIndex || 0;
    var geometryIndex = options.geometryIndex || 0;
    var segmentIndex = options.segmentIndex || 0;
    var properties = options.properties;
    var geometry;
    switch(geojson.type){
        case "FeatureCollection":
            if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;
            properties = properties || geojson.features[featureIndex].properties;
            geometry = geojson.features[featureIndex].geometry;
            break;
        case "Feature":
            properties = properties || geojson.properties;
            geometry = geojson.geometry;
            break;
        case "Point":
        case "MultiPoint":
            return null;
        case "LineString":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon":
            geometry = geojson;
            break;
        default:
            throw new Error("geojson is invalid");
    }
    if (geometry === null) return null;
    var coords = geometry.coordinates;
    switch(geometry.type){
        case "Point":
        case "MultiPoint":
            return null;
        case "LineString":
            if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineString"])([
                coords[segmentIndex],
                coords[segmentIndex + 1]
            ], properties, options);
        case "Polygon":
            if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
            if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineString"])([
                coords[geometryIndex][segmentIndex],
                coords[geometryIndex][segmentIndex + 1]
            ], properties, options);
        case "MultiLineString":
            if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
            if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineString"])([
                coords[multiFeatureIndex][segmentIndex],
                coords[multiFeatureIndex][segmentIndex + 1]
            ], properties, options);
        case "MultiPolygon":
            if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
            if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
            if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineString"])([
                coords[multiFeatureIndex][geometryIndex][segmentIndex],
                coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]
            ], properties, options);
    }
    throw new Error("geojson is invalid");
}
function findPoint(geojson, options) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    var featureIndex = options.featureIndex || 0;
    var multiFeatureIndex = options.multiFeatureIndex || 0;
    var geometryIndex = options.geometryIndex || 0;
    var coordIndex = options.coordIndex || 0;
    var properties = options.properties;
    var geometry;
    switch(geojson.type){
        case "FeatureCollection":
            if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;
            properties = properties || geojson.features[featureIndex].properties;
            geometry = geojson.features[featureIndex].geometry;
            break;
        case "Feature":
            properties = properties || geojson.properties;
            geometry = geojson.geometry;
            break;
        case "Point":
        case "MultiPoint":
            return null;
        case "LineString":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon":
            geometry = geojson;
            break;
        default:
            throw new Error("geojson is invalid");
    }
    if (geometry === null) return null;
    var coords = geometry.coordinates;
    switch(geometry.type){
        case "Point":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])(coords, properties, options);
        case "MultiPoint":
            if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])(coords[multiFeatureIndex], properties, options);
        case "LineString":
            if (coordIndex < 0) coordIndex = coords.length + coordIndex;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])(coords[coordIndex], properties, options);
        case "Polygon":
            if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
            if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])(coords[geometryIndex][coordIndex], properties, options);
        case "MultiLineString":
            if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
            if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])(coords[multiFeatureIndex][coordIndex], properties, options);
        case "MultiPolygon":
            if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
            if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
            if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);
    }
    throw new Error("geojson is invalid");
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/area/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "area": (()=>area),
    "default": (()=>turf_area_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
;
function area(geojson) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["geomReduce"])(geojson, (value, geom)=>{
        return value + calculateArea(geom);
    }, 0);
}
function calculateArea(geom) {
    let total = 0;
    let i;
    switch(geom.type){
        case "Polygon":
            return polygonArea(geom.coordinates);
        case "MultiPolygon":
            for(i = 0; i < geom.coordinates.length; i++){
                total += polygonArea(geom.coordinates[i]);
            }
            return total;
        case "Point":
        case "MultiPoint":
        case "LineString":
        case "MultiLineString":
            return 0;
    }
    return 0;
}
function polygonArea(coords) {
    let total = 0;
    if (coords && coords.length > 0) {
        total += Math.abs(ringArea(coords[0]));
        for(let i = 1; i < coords.length; i++){
            total -= Math.abs(ringArea(coords[i]));
        }
    }
    return total;
}
var FACTOR = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["earthRadius"] * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["earthRadius"] / 2;
var PI_OVER_180 = Math.PI / 180;
function ringArea(coords) {
    const coordsLength = coords.length - 1;
    if (coordsLength <= 2) return 0;
    let total = 0;
    let i = 0;
    while(i < coordsLength){
        const lower = coords[i];
        const middle = coords[i + 1 === coordsLength ? 0 : i + 1];
        const upper = coords[i + 2 >= coordsLength ? (i + 2) % coordsLength : i + 2];
        const lowerX = lower[0] * PI_OVER_180;
        const middleY = middle[1] * PI_OVER_180;
        const upperX = upper[0] * PI_OVER_180;
        total += (upperX - lowerX) * Math.sin(middleY);
        i++;
    }
    return total * FACTOR;
}
var turf_area_default = area;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/bbox/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "bbox": (()=>bbox),
    "default": (()=>turf_bbox_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
;
function bbox(geojson, options = {}) {
    if (geojson.bbox != null && true !== options.recompute) {
        return geojson.bbox;
    }
    const result = [
        Infinity,
        Infinity,
        -Infinity,
        -Infinity
    ];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coordEach"])(geojson, (coord)=>{
        if (result[0] > coord[0]) {
            result[0] = coord[0];
        }
        if (result[1] > coord[1]) {
            result[1] = coord[1];
        }
        if (result[2] < coord[0]) {
            result[2] = coord[0];
        }
        if (result[3] < coord[1]) {
            result[3] = coord[1];
        }
    });
    return result;
}
var turf_bbox_default = bbox;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/bbox-clip/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "bboxClip": (()=>bboxClip),
    "default": (()=>turf_bbox_clip_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
;
// lib/lineclip.ts
function lineclip(points, bbox, result) {
    var len = points.length, codeA = bitCode(points[0], bbox), part = [], i, codeB, lastCode;
    let a;
    let b;
    if (!result) result = [];
    for(i = 1; i < len; i++){
        a = points[i - 1];
        b = points[i];
        codeB = lastCode = bitCode(b, bbox);
        while(true){
            if (!(codeA | codeB)) {
                part.push(a);
                if (codeB !== lastCode) {
                    part.push(b);
                    if (i < len - 1) {
                        result.push(part);
                        part = [];
                    }
                } else if (i === len - 1) {
                    part.push(b);
                }
                break;
            } else if (codeA & codeB) {
                break;
            } else if (codeA) {
                a = intersect(a, b, codeA, bbox);
                codeA = bitCode(a, bbox);
            } else {
                b = intersect(a, b, codeB, bbox);
                codeB = bitCode(b, bbox);
            }
        }
        codeA = lastCode;
    }
    if (part.length) result.push(part);
    return result;
}
function polygonclip(points, bbox) {
    var result, edge, prev, prevInside, i, p, inside;
    for(edge = 1; edge <= 8; edge *= 2){
        result = [];
        prev = points[points.length - 1];
        prevInside = !(bitCode(prev, bbox) & edge);
        for(i = 0; i < points.length; i++){
            p = points[i];
            inside = !(bitCode(p, bbox) & edge);
            if (inside !== prevInside) result.push(intersect(prev, p, edge, bbox));
            if (inside) result.push(p);
            prev = p;
            prevInside = inside;
        }
        points = result;
        if (!points.length) break;
    }
    return result;
}
function intersect(a, b, edge, bbox) {
    return edge & 8 ? [
        a[0] + (b[0] - a[0]) * (bbox[3] - a[1]) / (b[1] - a[1]),
        bbox[3]
    ] : edge & 4 ? [
        a[0] + (b[0] - a[0]) * (bbox[1] - a[1]) / (b[1] - a[1]),
        bbox[1]
    ] : edge & 2 ? [
        bbox[2],
        a[1] + (b[1] - a[1]) * (bbox[2] - a[0]) / (b[0] - a[0])
    ] : edge & 1 ? [
        bbox[0],
        a[1] + (b[1] - a[1]) * (bbox[0] - a[0]) / (b[0] - a[0])
    ] : null;
}
function bitCode(p, bbox) {
    var code = 0;
    if (p[0] < bbox[0]) code |= 1;
    else if (p[0] > bbox[2]) code |= 2;
    if (p[1] < bbox[1]) code |= 4;
    else if (p[1] > bbox[3]) code |= 8;
    return code;
}
// index.ts
function bboxClip(feature, bbox) {
    const geom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGeom"])(feature);
    const type = geom.type;
    const properties = feature.type === "Feature" ? feature.properties : {};
    let coords = geom.coordinates;
    switch(type){
        case "LineString":
        case "MultiLineString":
            {
                const lines = [];
                if (type === "LineString") {
                    coords = [
                        coords
                    ];
                }
                coords.forEach((line)=>{
                    lineclip(line, bbox, lines);
                });
                if (lines.length === 1) {
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineString"])(lines[0], properties);
                }
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiLineString"])(lines, properties);
            }
        case "Polygon":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])(clipPolygon(coords, bbox), properties);
        case "MultiPolygon":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiPolygon"])(coords.map((poly)=>{
                return clipPolygon(poly, bbox);
            }), properties);
        default:
            throw new Error("geometry " + type + " not supported");
    }
}
function clipPolygon(rings, bbox) {
    const outRings = [];
    for (const ring of rings){
        const clipped = polygonclip(ring, bbox);
        if (clipped.length > 0) {
            if (clipped[0][0] !== clipped[clipped.length - 1][0] || clipped[0][1] !== clipped[clipped.length - 1][1]) {
                clipped.push(clipped[0]);
            }
            if (clipped.length >= 4) {
                outRings.push(clipped);
            }
        }
    }
    return outRings;
}
var turf_bbox_clip_default = bboxClip;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/bbox-polygon/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "bboxPolygon": (()=>bboxPolygon),
    "default": (()=>turf_bbox_polygon_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
function bboxPolygon(bbox, options = {}) {
    const west = Number(bbox[0]);
    const south = Number(bbox[1]);
    const east = Number(bbox[2]);
    const north = Number(bbox[3]);
    if (bbox.length === 6) {
        throw new Error("@turf/bbox-polygon does not support BBox with 6 positions");
    }
    const lowLeft = [
        west,
        south
    ];
    const topLeft = [
        west,
        north
    ];
    const topRight = [
        east,
        north
    ];
    const lowRight = [
        east,
        south
    ];
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])([
        [
            lowLeft,
            lowRight,
            topRight,
            topLeft,
            lowLeft
        ]
    ], options.properties, {
        bbox,
        id: options.id
    });
}
var turf_bbox_polygon_default = bboxPolygon;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/bezier-spline/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "bezierSpline": (()=>bezierSpline),
    "default": (()=>turf_bezier_spline_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
;
// lib/spline.ts
var Spline = class {
    constructor(options){
        this.points = options.points || [];
        this.duration = options.duration || 1e4;
        this.sharpness = options.sharpness || 0.85;
        this.centers = [];
        this.controls = [];
        this.stepLength = options.stepLength || 60;
        this.length = this.points.length;
        this.delay = 0;
        for(let i = 0; i < this.length; i++){
            this.points[i].z = this.points[i].z || 0;
        }
        for(let i = 0; i < this.length - 1; i++){
            const p1 = this.points[i];
            const p2 = this.points[i + 1];
            this.centers.push({
                x: (p1.x + p2.x) / 2,
                y: (p1.y + p2.y) / 2,
                z: (p1.z + p2.z) / 2
            });
        }
        this.controls.push([
            this.points[0],
            this.points[0]
        ]);
        for(let i = 0; i < this.centers.length - 1; i++){
            const dx = this.points[i + 1].x - (this.centers[i].x + this.centers[i + 1].x) / 2;
            const dy = this.points[i + 1].y - (this.centers[i].y + this.centers[i + 1].y) / 2;
            const dz = this.points[i + 1].z - (this.centers[i].y + this.centers[i + 1].z) / 2;
            this.controls.push([
                {
                    x: (1 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i].x + dx),
                    y: (1 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i].y + dy),
                    z: (1 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i].z + dz)
                },
                {
                    x: (1 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i + 1].x + dx),
                    y: (1 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i + 1].y + dy),
                    z: (1 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i + 1].z + dz)
                }
            ]);
        }
        this.controls.push([
            this.points[this.length - 1],
            this.points[this.length - 1]
        ]);
        this.steps = this.cacheSteps(this.stepLength);
        return this;
    }
    /**
   * Caches an array of equidistant (more or less) points on the curve.
   */ cacheSteps(mindist) {
        const steps = [];
        let laststep = this.pos(0);
        steps.push(0);
        for(let t = 0; t < this.duration; t += 10){
            const step = this.pos(t);
            const dist = Math.sqrt((step.x - laststep.x) * (step.x - laststep.x) + (step.y - laststep.y) * (step.y - laststep.y) + (step.z - laststep.z) * (step.z - laststep.z));
            if (dist > mindist) {
                steps.push(t);
                laststep = step;
            }
        }
        return steps;
    }
    /**
   * returns angle and speed in the given point in the curve
   */ vector(t) {
        const p1 = this.pos(t + 10);
        const p2 = this.pos(t - 10);
        return {
            angle: 180 * Math.atan2(p1.y - p2.y, p1.x - p2.x) / 3.14,
            speed: Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y) + (p2.z - p1.z) * (p2.z - p1.z))
        };
    }
    /**
   * Gets the position of the point, given time.
   *
   * WARNING: The speed is not constant. The time it takes between control points is constant.
   *
   * For constant speed, use Spline.steps[i];
   */ pos(time) {
        let t = time - this.delay;
        if (t < 0) {
            t = 0;
        }
        if (t > this.duration) {
            t = this.duration - 1;
        }
        const t2 = t / this.duration;
        if (t2 >= 1) {
            return this.points[this.length - 1];
        }
        const n = Math.floor((this.points.length - 1) * t2);
        const t1 = (this.length - 1) * t2 - n;
        return bezier(t1, this.points[n], this.controls[n][1], this.controls[n + 1][0], this.points[n + 1]);
    }
};
function bezier(t, p1, c1, c2, p2) {
    const b = B(t);
    const pos = {
        x: p2.x * b[0] + c2.x * b[1] + c1.x * b[2] + p1.x * b[3],
        y: p2.y * b[0] + c2.y * b[1] + c1.y * b[2] + p1.y * b[3],
        z: p2.z * b[0] + c2.z * b[1] + c1.z * b[2] + p1.z * b[3]
    };
    return pos;
}
function B(t) {
    const t2 = t * t;
    const t3 = t2 * t;
    return [
        t3,
        3 * t2 * (1 - t),
        3 * t * (1 - t) * (1 - t),
        (1 - t) * (1 - t) * (1 - t)
    ];
}
// index.ts
function bezierSpline(line, options = {}) {
    const resolution = options.resolution || 1e4;
    const sharpness = options.sharpness || 0.85;
    const coords = [];
    const points = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGeom"])(line).coordinates.map((pt)=>{
        return {
            x: pt[0],
            y: pt[1]
        };
    });
    const spline = new Spline({
        duration: resolution,
        points,
        sharpness
    });
    const pushCoord = (time)=>{
        var pos = spline.pos(time);
        if (Math.floor(time / 100) % 2 === 0) {
            coords.push([
                pos.x,
                pos.y
            ]);
        }
    };
    for(var i = 0; i < spline.duration; i += 10){
        pushCoord(i);
    }
    pushCoord(spline.duration);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineString"])(coords, options.properties);
}
var turf_bezier_spline_default = bezierSpline;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/boolean-clockwise/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "booleanClockwise": (()=>booleanClockwise),
    "default": (()=>turf_boolean_clockwise_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
;
function booleanClockwise(line) {
    const ring = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(line);
    let sum = 0;
    let i = 1;
    let prev;
    let cur;
    while(i < ring.length){
        prev = cur || ring[0];
        cur = ring[i];
        sum += (cur[0] - prev[0]) * (cur[1] + prev[1]);
        i++;
    }
    return sum > 0;
}
var turf_boolean_clockwise_default = booleanClockwise;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/boolean-concave/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "booleanConcave": (()=>booleanConcave),
    "default": (()=>turf_boolean_concave_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
;
function booleanConcave(polygon) {
    const coords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGeom"])(polygon).coordinates;
    if (coords[0].length <= 4) {
        return false;
    }
    let sign = false;
    const n = coords[0].length - 1;
    for(let i = 0; i < n; i++){
        const dx1 = coords[0][(i + 2) % n][0] - coords[0][(i + 1) % n][0];
        const dy1 = coords[0][(i + 2) % n][1] - coords[0][(i + 1) % n][1];
        const dx2 = coords[0][i][0] - coords[0][(i + 1) % n][0];
        const dy2 = coords[0][i][1] - coords[0][(i + 1) % n][1];
        const zcrossproduct = dx1 * dy2 - dy1 * dx2;
        if (i === 0) {
            sign = zcrossproduct > 0;
        } else if (sign !== zcrossproduct > 0) {
            return true;
        }
    }
    return false;
}
var turf_boolean_concave_default = booleanConcave;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/boolean-point-on-line/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "booleanPointOnLine": (()=>booleanPointOnLine),
    "default": (()=>turf_boolean_point_on_line_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
;
function booleanPointOnLine(pt, line, options = {}) {
    const ptCoords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(pt);
    const lineCoords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(line);
    for(let i = 0; i < lineCoords.length - 1; i++){
        let ignoreBoundary = false;
        if (options.ignoreEndVertices) {
            if (i === 0) {
                ignoreBoundary = "start";
            }
            if (i === lineCoords.length - 2) {
                ignoreBoundary = "end";
            }
            if (i === 0 && i + 1 === lineCoords.length - 1) {
                ignoreBoundary = "both";
            }
        }
        if (isPointOnLineSegment(lineCoords[i], lineCoords[i + 1], ptCoords, ignoreBoundary, typeof options.epsilon === "undefined" ? null : options.epsilon)) {
            return true;
        }
    }
    return false;
}
function isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary, epsilon) {
    const x = pt[0];
    const y = pt[1];
    const x1 = lineSegmentStart[0];
    const y1 = lineSegmentStart[1];
    const x2 = lineSegmentEnd[0];
    const y2 = lineSegmentEnd[1];
    const dxc = pt[0] - x1;
    const dyc = pt[1] - y1;
    const dxl = x2 - x1;
    const dyl = y2 - y1;
    const cross = dxc * dyl - dyc * dxl;
    if (epsilon !== null) {
        if (Math.abs(cross) > epsilon) {
            return false;
        }
    } else if (cross !== 0) {
        return false;
    }
    if (Math.abs(dxl) === Math.abs(dyl) && Math.abs(dxl) === 0) {
        if (excludeBoundary) {
            return false;
        }
        if (pt[0] === lineSegmentStart[0] && pt[1] === lineSegmentStart[1]) {
            return true;
        } else {
            return false;
        }
    }
    if (!excludeBoundary) {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1;
        }
        return dyl > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1;
    } else if (excludeBoundary === "start") {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1;
        }
        return dyl > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1;
    } else if (excludeBoundary === "end") {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1;
        }
        return dyl > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1;
    } else if (excludeBoundary === "both") {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? x1 < x && x < x2 : x2 < x && x < x1;
        }
        return dyl > 0 ? y1 < y && y < y2 : y2 < y && y < y1;
    }
    return false;
}
var turf_boolean_point_on_line_default = booleanPointOnLine;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/point-in-polygon-hao/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>pointInPolygon)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$point$2d$in$2d$polygon$2d$hao$2f$node_modules$2f$robust$2d$predicates$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/point-in-polygon-hao/node_modules/robust-predicates/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$point$2d$in$2d$polygon$2d$hao$2f$node_modules$2f$robust$2d$predicates$2f$esm$2f$orient2d$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/point-in-polygon-hao/node_modules/robust-predicates/esm/orient2d.js [app-client] (ecmascript)");
;
function pointInPolygon(p, polygon) {
    var i;
    var ii;
    var k = 0;
    var f;
    var u1;
    var v1;
    var u2;
    var v2;
    var currentP;
    var nextP;
    var x = p[0];
    var y = p[1];
    var numContours = polygon.length;
    for(i = 0; i < numContours; i++){
        ii = 0;
        var contour = polygon[i];
        var contourLen = contour.length - 1;
        currentP = contour[0];
        if (currentP[0] !== contour[contourLen][0] && currentP[1] !== contour[contourLen][1]) {
            throw new Error('First and last coordinates in a ring must be the same');
        }
        u1 = currentP[0] - x;
        v1 = currentP[1] - y;
        for(ii; ii < contourLen; ii++){
            nextP = contour[ii + 1];
            u2 = nextP[0] - x;
            v2 = nextP[1] - y;
            if (v1 === 0 && v2 === 0) {
                if (u2 <= 0 && u1 >= 0 || u1 <= 0 && u2 >= 0) {
                    return 0;
                }
            } else if (v2 >= 0 && v1 <= 0 || v2 <= 0 && v1 >= 0) {
                f = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$point$2d$in$2d$polygon$2d$hao$2f$node_modules$2f$robust$2d$predicates$2f$esm$2f$orient2d$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["orient2d"])(u1, u2, v1, v2, 0, 0);
                if (f === 0) {
                    return 0;
                }
                if (f > 0 && v2 > 0 && v1 <= 0 || f < 0 && v2 <= 0 && v1 > 0) {
                    k++;
                }
            }
            currentP = nextP;
            v1 = v2;
            u1 = u2;
        }
    }
    if (k % 2 === 0) {
        return false;
    }
    return true;
}
;
}}),
"[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "booleanPointInPolygon": (()=>booleanPointInPolygon),
    "default": (()=>turf_boolean_point_in_polygon_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$point$2d$in$2d$polygon$2d$hao$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/point-in-polygon-hao/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
;
;
function booleanPointInPolygon(point, polygon, options = {}) {
    if (!point) {
        throw new Error("point is required");
    }
    if (!polygon) {
        throw new Error("polygon is required");
    }
    const pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(point);
    const geom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGeom"])(polygon);
    const type = geom.type;
    const bbox = polygon.bbox;
    let polys = geom.coordinates;
    if (bbox && inBBox(pt, bbox) === false) {
        return false;
    }
    if (type === "Polygon") {
        polys = [
            polys
        ];
    }
    let result = false;
    for(var i = 0; i < polys.length; ++i){
        const polyResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$point$2d$in$2d$polygon$2d$hao$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(pt, polys[i]);
        if (polyResult === 0) return options.ignoreBoundary ? false : true;
        else if (polyResult) result = true;
    }
    return result;
}
function inBBox(pt, bbox) {
    return bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1];
}
var turf_boolean_point_in_polygon_default = booleanPointInPolygon;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/boolean-contains/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "booleanContains": (()=>booleanContains),
    "compareCoords": (()=>compareCoords),
    "default": (()=>turf_boolean_contains_default),
    "doBBoxOverlap": (()=>doBBoxOverlap),
    "getMidpoint": (()=>getMidpoint),
    "isLineInPoly": (()=>isLineInPoly),
    "isLineOnLine": (()=>isLineOnLine),
    "isMultiPointInMultiPoint": (()=>isMultiPointInMultiPoint),
    "isMultiPointInPoly": (()=>isMultiPointInPoly),
    "isMultiPointOnLine": (()=>isMultiPointOnLine),
    "isPointInMultiPoint": (()=>isPointInMultiPoint),
    "isPolyInPoly": (()=>isPolyInPoly),
    "isPolygonInMultiPolygon": (()=>isPolygonInMultiPolygon)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-on-line/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
function booleanContains(feature1, feature2) {
    const geom1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGeom"])(feature1);
    const geom2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGeom"])(feature2);
    const type1 = geom1.type;
    const type2 = geom2.type;
    const coords1 = geom1.coordinates;
    const coords2 = geom2.coordinates;
    switch(type1){
        case "Point":
            switch(type2){
                case "Point":
                    return compareCoords(coords1, coords2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "MultiPoint":
            switch(type2){
                case "Point":
                    return isPointInMultiPoint(geom1, geom2);
                case "MultiPoint":
                    return isMultiPointInMultiPoint(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "LineString":
            switch(type2){
                case "Point":
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(geom2, geom1, {
                        ignoreEndVertices: true
                    });
                case "LineString":
                    return isLineOnLine(geom1, geom2);
                case "MultiPoint":
                    return isMultiPointOnLine(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "Polygon":
            switch(type2){
                case "Point":
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(geom2, geom1, {
                        ignoreBoundary: true
                    });
                case "LineString":
                    return isLineInPoly(geom1, geom2);
                case "Polygon":
                    return isPolyInPoly(geom1, geom2);
                case "MultiPoint":
                    return isMultiPointInPoly(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "MultiPolygon":
            switch(type2){
                case "Polygon":
                    return isPolygonInMultiPolygon(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        default:
            throw new Error("feature1 " + type1 + " geometry not supported");
    }
}
function isPolygonInMultiPolygon(multiPolygon, polygon) {
    return multiPolygon.coordinates.some((coords)=>isPolyInPoly({
            type: "Polygon",
            coordinates: coords
        }, polygon));
}
function isPointInMultiPoint(multiPoint, pt) {
    let i;
    let output = false;
    for(i = 0; i < multiPoint.coordinates.length; i++){
        if (compareCoords(multiPoint.coordinates[i], pt.coordinates)) {
            output = true;
            break;
        }
    }
    return output;
}
function isMultiPointInMultiPoint(multiPoint1, multiPoint2) {
    for (const coord2 of multiPoint2.coordinates){
        let matchFound = false;
        for (const coord1 of multiPoint1.coordinates){
            if (compareCoords(coord2, coord1)) {
                matchFound = true;
                break;
            }
        }
        if (!matchFound) {
            return false;
        }
    }
    return true;
}
function isMultiPointOnLine(lineString, multiPoint) {
    let haveFoundInteriorPoint = false;
    for (const coord of multiPoint.coordinates){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(coord, lineString, {
            ignoreEndVertices: true
        })) {
            haveFoundInteriorPoint = true;
        }
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(coord, lineString)) {
            return false;
        }
    }
    if (haveFoundInteriorPoint) {
        return true;
    }
    return false;
}
function isMultiPointInPoly(polygon, multiPoint) {
    for (const coord of multiPoint.coordinates){
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(coord, polygon, {
            ignoreBoundary: true
        })) {
            return false;
        }
    }
    return true;
}
function isLineOnLine(lineString1, lineString2) {
    let haveFoundInteriorPoint = false;
    for (const coords of lineString2.coordinates){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
            type: "Point",
            coordinates: coords
        }, lineString1, {
            ignoreEndVertices: true
        })) {
            haveFoundInteriorPoint = true;
        }
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
            type: "Point",
            coordinates: coords
        }, lineString1, {
            ignoreEndVertices: false
        })) {
            return false;
        }
    }
    return haveFoundInteriorPoint;
}
function isLineInPoly(polygon, linestring) {
    let output = false;
    let i = 0;
    const polyBbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bbox"])(polygon);
    const lineBbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bbox"])(linestring);
    if (!doBBoxOverlap(polyBbox, lineBbox)) {
        return false;
    }
    for(i; i < linestring.coordinates.length - 1; i++){
        const midPoint = getMidpoint(linestring.coordinates[i], linestring.coordinates[i + 1]);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
            type: "Point",
            coordinates: midPoint
        }, polygon, {
            ignoreBoundary: true
        })) {
            output = true;
            break;
        }
    }
    return output;
}
function isPolyInPoly(feature1, feature2) {
    if (feature1.type === "Feature" && feature1.geometry === null) {
        return false;
    }
    if (feature2.type === "Feature" && feature2.geometry === null) {
        return false;
    }
    const poly1Bbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bbox"])(feature1);
    const poly2Bbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bbox"])(feature2);
    if (!doBBoxOverlap(poly1Bbox, poly2Bbox)) {
        return false;
    }
    const coords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGeom"])(feature2).coordinates;
    for (const ring of coords){
        for (const coord of ring){
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(coord, feature1)) {
                return false;
            }
        }
    }
    return true;
}
function doBBoxOverlap(bbox1, bbox2) {
    if (bbox1[0] > bbox2[0]) {
        return false;
    }
    if (bbox1[2] < bbox2[2]) {
        return false;
    }
    if (bbox1[1] > bbox2[1]) {
        return false;
    }
    if (bbox1[3] < bbox2[3]) {
        return false;
    }
    return true;
}
function compareCoords(pair1, pair2) {
    return pair1[0] === pair2[0] && pair1[1] === pair2[1];
}
function getMidpoint(pair1, pair2) {
    return [
        (pair1[0] + pair2[0]) / 2,
        (pair1[1] + pair2[1]) / 2
    ];
}
var turf_boolean_contains_default = booleanContains;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/sweepline-intersections/dist/sweeplineIntersections.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
class TinyQueue {
    constructor(data = [], compare = defaultCompare){
        this.data = data;
        this.length = this.data.length;
        this.compare = compare;
        if (this.length > 0) {
            for(let i = (this.length >> 1) - 1; i >= 0; i--)this._down(i);
        }
    }
    push(item) {
        this.data.push(item);
        this.length++;
        this._up(this.length - 1);
    }
    pop() {
        if (this.length === 0) return undefined;
        const top = this.data[0];
        const bottom = this.data.pop();
        this.length--;
        if (this.length > 0) {
            this.data[0] = bottom;
            this._down(0);
        }
        return top;
    }
    peek() {
        return this.data[0];
    }
    _up(pos) {
        const { data, compare } = this;
        const item = data[pos];
        while(pos > 0){
            const parent = pos - 1 >> 1;
            const current = data[parent];
            if (compare(item, current) >= 0) break;
            data[pos] = current;
            pos = parent;
        }
        data[pos] = item;
    }
    _down(pos) {
        const { data, compare } = this;
        const halfLength = this.length >> 1;
        const item = data[pos];
        while(pos < halfLength){
            let left = (pos << 1) + 1;
            let best = data[left];
            const right = left + 1;
            if (right < this.length && compare(data[right], best) < 0) {
                left = right;
                best = data[right];
            }
            if (compare(best, item) >= 0) break;
            data[pos] = best;
            pos = left;
        }
        data[pos] = item;
    }
}
function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}
function checkWhichEventIsLeft(e1, e2) {
    if (e1.p.x > e2.p.x) return 1;
    if (e1.p.x < e2.p.x) return -1;
    if (e1.p.y !== e2.p.y) return e1.p.y > e2.p.y ? 1 : -1;
    return 1;
}
function checkWhichSegmentHasRightEndpointFirst(seg1, seg2) {
    if (seg1.rightSweepEvent.p.x > seg2.rightSweepEvent.p.x) return 1;
    if (seg1.rightSweepEvent.p.x < seg2.rightSweepEvent.p.x) return -1;
    if (seg1.rightSweepEvent.p.y !== seg2.rightSweepEvent.p.y) return seg1.rightSweepEvent.p.y < seg2.rightSweepEvent.p.y ? 1 : -1;
    return 1;
}
class Event {
    constructor(p, featureId, ringId, eventId){
        this.p = {
            x: p[0],
            y: p[1]
        };
        this.featureId = featureId;
        this.ringId = ringId;
        this.eventId = eventId;
        this.otherEvent = null;
        this.isLeftEndpoint = null;
    }
    isSamePoint(eventToCheck) {
        return this.p.x === eventToCheck.p.x && this.p.y === eventToCheck.p.y;
    }
}
function fillEventQueue(geojson, eventQueue) {
    if (geojson.type === 'FeatureCollection') {
        const features = geojson.features;
        for(let i = 0; i < features.length; i++){
            processFeature(features[i], eventQueue);
        }
    } else {
        processFeature(geojson, eventQueue);
    }
}
let featureId = 0;
let ringId = 0;
let eventId = 0;
function processFeature(featureOrGeometry, eventQueue) {
    const geom = featureOrGeometry.type === 'Feature' ? featureOrGeometry.geometry : featureOrGeometry;
    let coords = geom.coordinates;
    // standardise the input
    if (geom.type === 'Polygon' || geom.type === 'MultiLineString') coords = [
        coords
    ];
    if (geom.type === 'LineString') coords = [
        [
            coords
        ]
    ];
    for(let i = 0; i < coords.length; i++){
        for(let ii = 0; ii < coords[i].length; ii++){
            let currentP = coords[i][ii][0];
            let nextP = null;
            ringId = ringId + 1;
            for(let iii = 0; iii < coords[i][ii].length - 1; iii++){
                nextP = coords[i][ii][iii + 1];
                const e1 = new Event(currentP, featureId, ringId, eventId);
                const e2 = new Event(nextP, featureId, ringId, eventId + 1);
                e1.otherEvent = e2;
                e2.otherEvent = e1;
                if (checkWhichEventIsLeft(e1, e2) > 0) {
                    e2.isLeftEndpoint = true;
                    e1.isLeftEndpoint = false;
                } else {
                    e1.isLeftEndpoint = true;
                    e2.isLeftEndpoint = false;
                }
                eventQueue.push(e1);
                eventQueue.push(e2);
                currentP = nextP;
                eventId = eventId + 1;
            }
        }
    }
    featureId = featureId + 1;
}
class Segment {
    constructor(event){
        this.leftSweepEvent = event;
        this.rightSweepEvent = event.otherEvent;
    }
}
function testSegmentIntersect(seg1, seg2) {
    if (seg1 === null || seg2 === null) return false;
    if (seg1.leftSweepEvent.ringId === seg2.leftSweepEvent.ringId && (seg1.rightSweepEvent.isSamePoint(seg2.leftSweepEvent) || seg1.rightSweepEvent.isSamePoint(seg2.leftSweepEvent) || seg1.rightSweepEvent.isSamePoint(seg2.rightSweepEvent) || seg1.leftSweepEvent.isSamePoint(seg2.leftSweepEvent) || seg1.leftSweepEvent.isSamePoint(seg2.rightSweepEvent))) return false;
    const x1 = seg1.leftSweepEvent.p.x;
    const y1 = seg1.leftSweepEvent.p.y;
    const x2 = seg1.rightSweepEvent.p.x;
    const y2 = seg1.rightSweepEvent.p.y;
    const x3 = seg2.leftSweepEvent.p.x;
    const y3 = seg2.leftSweepEvent.p.y;
    const x4 = seg2.rightSweepEvent.p.x;
    const y4 = seg2.rightSweepEvent.p.y;
    const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
    const numeA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
    const numeB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
    if (denom === 0) {
        if (numeA === 0 && numeB === 0) return false;
        return false;
    }
    const uA = numeA / denom;
    const uB = numeB / denom;
    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
        const x = x1 + uA * (x2 - x1);
        const y = y1 + uA * (y2 - y1);
        return [
            x,
            y
        ];
    }
    return false;
}
// import {debugEventAndSegments, debugRemovingSegment} from './debug'
function runCheck(eventQueue, ignoreSelfIntersections) {
    ignoreSelfIntersections = ignoreSelfIntersections ? ignoreSelfIntersections : false;
    const intersectionPoints = [];
    const outQueue = new TinyQueue([], checkWhichSegmentHasRightEndpointFirst);
    while(eventQueue.length){
        const event = eventQueue.pop();
        if (event.isLeftEndpoint) {
            // debugEventAndSegments(event.p, outQueue.data)
            const segment = new Segment(event);
            for(let i = 0; i < outQueue.data.length; i++){
                const otherSeg = outQueue.data[i];
                if (ignoreSelfIntersections) {
                    if (otherSeg.leftSweepEvent.featureId === event.featureId) continue;
                }
                const intersection = testSegmentIntersect(segment, otherSeg);
                if (intersection !== false) intersectionPoints.push(intersection);
            }
            outQueue.push(segment);
        } else if (event.isLeftEndpoint === false) {
            outQueue.pop();
        // const seg = outQueue.pop()
        // debugRemovingSegment(event.p, seg)
        }
    }
    return intersectionPoints;
}
function sweeplineIntersections(geojson, ignoreSelfIntersections) {
    const eventQueue = new TinyQueue([], checkWhichEventIsLeft);
    fillEventQueue(geojson, eventQueue);
    return runCheck(eventQueue, ignoreSelfIntersections);
}
const __TURBOPACK__default__export__ = sweeplineIntersections;
}}),
"[project]/node_modules/@turf/line-intersect/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_line_intersect_default),
    "lineIntersect": (()=>lineIntersect)
});
// lib/sweepline-intersections-export.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sweepline$2d$intersections$2f$dist$2f$sweeplineIntersections$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/sweepline-intersections/dist/sweeplineIntersections.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
;
var sweeplineIntersections = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sweepline$2d$intersections$2f$dist$2f$sweeplineIntersections$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
// index.ts
function lineIntersect(line1, line2, options = {}) {
    const { removeDuplicates = true, ignoreSelfIntersections = true } = options;
    let features = [];
    if (line1.type === "FeatureCollection") features = features.concat(line1.features);
    else if (line1.type === "Feature") features.push(line1);
    else if (line1.type === "LineString" || line1.type === "Polygon" || line1.type === "MultiLineString" || line1.type === "MultiPolygon") {
        features.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["feature"])(line1));
    }
    if (line2.type === "FeatureCollection") features = features.concat(line2.features);
    else if (line2.type === "Feature") features.push(line2);
    else if (line2.type === "LineString" || line2.type === "Polygon" || line2.type === "MultiLineString" || line2.type === "MultiPolygon") {
        features.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["feature"])(line2));
    }
    const intersections = sweeplineIntersections((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(features), ignoreSelfIntersections);
    let results = [];
    if (removeDuplicates) {
        const unique = {};
        intersections.forEach((intersection)=>{
            const key = intersection.join(",");
            if (!unique[key]) {
                unique[key] = true;
                results.push(intersection);
            }
        });
    } else {
        results = intersections;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(results.map((r)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])(r)));
}
var turf_line_intersect_default = lineIntersect;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/polygon-to-line/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "coordsToLine": (()=>coordsToLine),
    "default": (()=>turf_polygon_to_line_default),
    "multiPolygonToLine": (()=>multiPolygonToLine),
    "polygonToLine": (()=>polygonToLine),
    "singlePolygonToLine": (()=>singlePolygonToLine)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
;
function polygonToLine(poly, options = {}) {
    const geom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGeom"])(poly);
    if (!options.properties && poly.type === "Feature") {
        options.properties = poly.properties;
    }
    switch(geom.type){
        case "Polygon":
            return singlePolygonToLine(geom, options);
        case "MultiPolygon":
            return multiPolygonToLine(geom, options);
        default:
            throw new Error("invalid poly");
    }
}
function singlePolygonToLine(poly, options = {}) {
    const geom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGeom"])(poly);
    const coords = geom.coordinates;
    const properties = options.properties ? options.properties : poly.type === "Feature" ? poly.properties : {};
    return coordsToLine(coords, properties);
}
function multiPolygonToLine(multiPoly, options = {}) {
    const geom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGeom"])(multiPoly);
    const coords = geom.coordinates;
    const properties = options.properties ? options.properties : multiPoly.type === "Feature" ? multiPoly.properties : {};
    const lines = [];
    coords.forEach((coord)=>{
        lines.push(coordsToLine(coord, properties));
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(lines);
}
function coordsToLine(coords, properties) {
    if (coords.length > 1) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiLineString"])(coords, properties);
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineString"])(coords[0], properties);
}
var turf_polygon_to_line_default = polygonToLine;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/boolean-crosses/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "booleanCrosses": (()=>booleanCrosses),
    "default": (()=>turf_boolean_crosses_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-intersect/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygon$2d$to$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/polygon-to-line/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
;
function booleanCrosses(feature1, feature2) {
    var geom1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGeom"])(feature1);
    var geom2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGeom"])(feature2);
    var type1 = geom1.type;
    var type2 = geom2.type;
    switch(type1){
        case "MultiPoint":
            switch(type2){
                case "LineString":
                    return doMultiPointAndLineStringCross(geom1, geom2);
                case "Polygon":
                    return doesMultiPointCrossPoly(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "LineString":
            switch(type2){
                case "MultiPoint":
                    return doMultiPointAndLineStringCross(geom2, geom1);
                case "LineString":
                    return doLineStringsCross(geom1, geom2);
                case "Polygon":
                    return doLineStringAndPolygonCross(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "Polygon":
            switch(type2){
                case "MultiPoint":
                    return doesMultiPointCrossPoly(geom2, geom1);
                case "LineString":
                    return doLineStringAndPolygonCross(geom2, geom1);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        default:
            throw new Error("feature1 " + type1 + " geometry not supported");
    }
}
function doMultiPointAndLineStringCross(multiPoint, lineString) {
    var foundIntPoint = false;
    var foundExtPoint = false;
    var pointLength = multiPoint.coordinates.length;
    var i = 0;
    while(i < pointLength && !foundIntPoint && !foundExtPoint){
        for(var i2 = 0; i2 < lineString.coordinates.length - 1; i2++){
            var incEndVertices = true;
            if (i2 === 0 || i2 === lineString.coordinates.length - 2) {
                incEndVertices = false;
            }
            if (isPointOnLineSegment(lineString.coordinates[i2], lineString.coordinates[i2 + 1], multiPoint.coordinates[i], incEndVertices)) {
                foundIntPoint = true;
            } else {
                foundExtPoint = true;
            }
        }
        i++;
    }
    return foundIntPoint && foundExtPoint;
}
function doLineStringsCross(lineString1, lineString2) {
    var doLinesIntersect = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineIntersect"])(lineString1, lineString2);
    if (doLinesIntersect.features.length > 0) {
        for(var i = 0; i < lineString1.coordinates.length - 1; i++){
            for(var i2 = 0; i2 < lineString2.coordinates.length - 1; i2++){
                var incEndVertices = true;
                if (i2 === 0 || i2 === lineString2.coordinates.length - 2) {
                    incEndVertices = false;
                }
                if (isPointOnLineSegment(lineString1.coordinates[i], lineString1.coordinates[i + 1], lineString2.coordinates[i2], incEndVertices)) {
                    return true;
                }
            }
        }
    }
    return false;
}
function doLineStringAndPolygonCross(lineString, polygon) {
    const line = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygon$2d$to$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygonToLine"])(polygon);
    const doLinesIntersect = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineIntersect"])(lineString, line);
    if (doLinesIntersect.features.length > 0) {
        return true;
    }
    return false;
}
function doesMultiPointCrossPoly(multiPoint, polygon) {
    var foundIntPoint = false;
    var foundExtPoint = false;
    var pointLength = multiPoint.coordinates.length;
    for(let i = 0; i < pointLength && (!foundIntPoint || !foundExtPoint); i++){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])(multiPoint.coordinates[i]), polygon)) {
            foundIntPoint = true;
        } else {
            foundExtPoint = true;
        }
    }
    return foundExtPoint && foundIntPoint;
}
function isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, incEnd) {
    var dxc = pt[0] - lineSegmentStart[0];
    var dyc = pt[1] - lineSegmentStart[1];
    var dxl = lineSegmentEnd[0] - lineSegmentStart[0];
    var dyl = lineSegmentEnd[1] - lineSegmentStart[1];
    var cross = dxc * dyl - dyc * dxl;
    if (cross !== 0) {
        return false;
    }
    if (incEnd) {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0] : lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];
        }
        return dyl > 0 ? lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1] : lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];
    } else {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? lineSegmentStart[0] < pt[0] && pt[0] < lineSegmentEnd[0] : lineSegmentEnd[0] < pt[0] && pt[0] < lineSegmentStart[0];
        }
        return dyl > 0 ? lineSegmentStart[1] < pt[1] && pt[1] < lineSegmentEnd[1] : lineSegmentEnd[1] < pt[1] && pt[1] < lineSegmentStart[1];
    }
}
var turf_boolean_crosses_default = booleanCrosses;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/boolean-disjoint/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "booleanDisjoint": (()=>booleanDisjoint),
    "default": (()=>turf_boolean_disjoint_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-intersect/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygon$2d$to$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/polygon-to-line/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
function booleanDisjoint(feature1, feature2, { ignoreSelfIntersections = true } = {
    ignoreSelfIntersections: true
}) {
    let bool = true;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["flattenEach"])(feature1, (flatten1)=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["flattenEach"])(feature2, (flatten2)=>{
            if (bool === false) {
                return false;
            }
            bool = disjoint(flatten1.geometry, flatten2.geometry, ignoreSelfIntersections);
        });
    });
    return bool;
}
function disjoint(geom1, geom2, ignoreSelfIntersections) {
    switch(geom1.type){
        case "Point":
            switch(geom2.type){
                case "Point":
                    return !compareCoords(geom1.coordinates, geom2.coordinates);
                case "LineString":
                    return !isPointOnLine(geom2, geom1);
                case "Polygon":
                    return !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(geom1, geom2);
            }
            break;
        case "LineString":
            switch(geom2.type){
                case "Point":
                    return !isPointOnLine(geom1, geom2);
                case "LineString":
                    return !isLineOnLine(geom1, geom2, ignoreSelfIntersections);
                case "Polygon":
                    return !isLineInPoly(geom2, geom1, ignoreSelfIntersections);
            }
            break;
        case "Polygon":
            switch(geom2.type){
                case "Point":
                    return !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(geom2, geom1);
                case "LineString":
                    return !isLineInPoly(geom1, geom2, ignoreSelfIntersections);
                case "Polygon":
                    return !isPolyInPoly(geom2, geom1, ignoreSelfIntersections);
            }
    }
    return false;
}
function isPointOnLine(lineString, pt) {
    for(let i = 0; i < lineString.coordinates.length - 1; i++){
        if (isPointOnLineSegment(lineString.coordinates[i], lineString.coordinates[i + 1], pt.coordinates)) {
            return true;
        }
    }
    return false;
}
function isLineOnLine(lineString1, lineString2, ignoreSelfIntersections) {
    const doLinesIntersect = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineIntersect"])(lineString1, lineString2, {
        ignoreSelfIntersections
    });
    if (doLinesIntersect.features.length > 0) {
        return true;
    }
    return false;
}
function isLineInPoly(polygon, lineString, ignoreSelfIntersections) {
    for (const coord of lineString.coordinates){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(coord, polygon)) {
            return true;
        }
    }
    const doLinesIntersect = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineIntersect"])(lineString, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygon$2d$to$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygonToLine"])(polygon), {
        ignoreSelfIntersections
    });
    if (doLinesIntersect.features.length > 0) {
        return true;
    }
    return false;
}
function isPolyInPoly(feature1, feature2, ignoreSelfIntersections) {
    for (const coord1 of feature1.coordinates[0]){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(coord1, feature2)) {
            return true;
        }
    }
    for (const coord2 of feature2.coordinates[0]){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(coord2, feature1)) {
            return true;
        }
    }
    const doLinesIntersect = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineIntersect"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygon$2d$to$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygonToLine"])(feature1), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygon$2d$to$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygonToLine"])(feature2), {
        ignoreSelfIntersections
    });
    if (doLinesIntersect.features.length > 0) {
        return true;
    }
    return false;
}
function isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt) {
    const dxc = pt[0] - lineSegmentStart[0];
    const dyc = pt[1] - lineSegmentStart[1];
    const dxl = lineSegmentEnd[0] - lineSegmentStart[0];
    const dyl = lineSegmentEnd[1] - lineSegmentStart[1];
    const cross = dxc * dyl - dyc * dxl;
    if (cross !== 0) {
        return false;
    }
    if (Math.abs(dxl) >= Math.abs(dyl)) {
        if (dxl > 0) {
            return lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0];
        } else {
            return lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];
        }
    } else if (dyl > 0) {
        return lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1];
    } else {
        return lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];
    }
}
function compareCoords(pair1, pair2) {
    return pair1[0] === pair2[0] && pair1[1] === pair2[1];
}
var turf_boolean_disjoint_default = booleanDisjoint;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/geojson-equality-ts/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "GeojsonEquality": (()=>GeojsonEquality),
    "default": (()=>geojson_equality_ts_default),
    "geojsonEquality": (()=>geojsonEquality)
});
var __defProp = Object.defineProperty;
var __name = (target, value)=>__defProp(target, "name", {
        value,
        configurable: true
    });
// index.ts
var _GeojsonEquality = class _GeojsonEquality {
    constructor(opts){
        this.direction = false;
        this.compareProperties = true;
        var _a, _b, _c;
        this.precision = 10 ** -((_a = opts == null ? void 0 : opts.precision) != null ? _a : 17);
        this.direction = (_b = opts == null ? void 0 : opts.direction) != null ? _b : false;
        this.compareProperties = (_c = opts == null ? void 0 : opts.compareProperties) != null ? _c : true;
    }
    compare(g1, g2) {
        if (g1.type !== g2.type) {
            return false;
        }
        if (!sameLength(g1, g2)) {
            return false;
        }
        switch(g1.type){
            case "Point":
                return this.compareCoord(g1.coordinates, g2.coordinates);
            case "LineString":
                return this.compareLine(g1.coordinates, g2.coordinates);
            case "Polygon":
                return this.comparePolygon(g1, g2);
            case "GeometryCollection":
                return this.compareGeometryCollection(g1, g2);
            case "Feature":
                return this.compareFeature(g1, g2);
            case "FeatureCollection":
                return this.compareFeatureCollection(g1, g2);
            default:
                if (g1.type.startsWith("Multi")) {
                    const g1s = explode(g1);
                    const g2s = explode(g2);
                    return g1s.every((g1part)=>g2s.some((g2part)=>this.compare(g1part, g2part)));
                }
        }
        return false;
    }
    compareCoord(c1, c2) {
        return c1.length === c2.length && c1.every((c, i)=>Math.abs(c - c2[i]) < this.precision);
    }
    compareLine(path1, path2, ind = 0, isPoly = false) {
        if (!sameLength(path1, path2)) {
            return false;
        }
        const p1 = path1;
        let p2 = path2;
        if (isPoly && !this.compareCoord(p1[0], p2[0])) {
            const startIndex = this.fixStartIndex(p2, p1);
            if (!startIndex) {
                return false;
            } else {
                p2 = startIndex;
            }
        }
        const sameDirection = this.compareCoord(p1[ind], p2[ind]);
        if (this.direction || sameDirection) {
            return this.comparePath(p1, p2);
        } else {
            if (this.compareCoord(p1[ind], p2[p2.length - (1 + ind)])) {
                return this.comparePath(p1.slice().reverse(), p2);
            }
            return false;
        }
    }
    fixStartIndex(sourcePath, targetPath) {
        let correctPath, ind = -1;
        for(let i = 0; i < sourcePath.length; i++){
            if (this.compareCoord(sourcePath[i], targetPath[0])) {
                ind = i;
                break;
            }
        }
        if (ind >= 0) {
            correctPath = [].concat(sourcePath.slice(ind, sourcePath.length), sourcePath.slice(1, ind + 1));
        }
        return correctPath;
    }
    comparePath(p1, p2) {
        return p1.every((c, i)=>this.compareCoord(c, p2[i]));
    }
    comparePolygon(g1, g2) {
        if (this.compareLine(g1.coordinates[0], g2.coordinates[0], 1, true)) {
            const holes1 = g1.coordinates.slice(1, g1.coordinates.length);
            const holes2 = g2.coordinates.slice(1, g2.coordinates.length);
            return holes1.every((h1)=>holes2.some((h2)=>this.compareLine(h1, h2, 1, true)));
        }
        return false;
    }
    compareGeometryCollection(g1, g2) {
        return sameLength(g1.geometries, g2.geometries) && this.compareBBox(g1, g2) && g1.geometries.every((g, i)=>this.compare(g, g2.geometries[i]));
    }
    compareFeature(g1, g2) {
        return g1.id === g2.id && (this.compareProperties ? equal(g1.properties, g2.properties) : true) && this.compareBBox(g1, g2) && this.compare(g1.geometry, g2.geometry);
    }
    compareFeatureCollection(g1, g2) {
        return sameLength(g1.features, g2.features) && this.compareBBox(g1, g2) && g1.features.every((f, i)=>this.compare(f, g2.features[i]));
    }
    compareBBox(g1, g2) {
        return Boolean(!g1.bbox && !g2.bbox) || (g1.bbox && g2.bbox ? this.compareCoord(g1.bbox, g2.bbox) : false);
    }
};
__name(_GeojsonEquality, "GeojsonEquality");
var GeojsonEquality = _GeojsonEquality;
function sameLength(g1, g2) {
    return g1.coordinates ? g1.coordinates.length === g2.coordinates.length : g1.length === g2.length;
}
__name(sameLength, "sameLength");
function explode(g) {
    return g.coordinates.map((part)=>({
            type: g.type.replace("Multi", ""),
            coordinates: part
        }));
}
__name(explode, "explode");
function geojsonEquality(g1, g2, opts) {
    const eq = new GeojsonEquality(opts);
    return eq.compare(g1, g2);
}
__name(geojsonEquality, "geojsonEquality");
function equal(object1, object2) {
    if (object1 === null && object2 === null) {
        return true;
    }
    if (object1 === null || object2 === null) {
        return false;
    }
    const objKeys1 = Object.keys(object1);
    const objKeys2 = Object.keys(object2);
    if (objKeys1.length !== objKeys2.length) return false;
    for (var key of objKeys1){
        const value1 = object1[key];
        const value2 = object2[key];
        const isObjects = isObject(value1) && isObject(value2);
        if (isObjects && !equal(value1, value2) || !isObjects && value1 !== value2) {
            return false;
        }
    }
    return true;
}
__name(equal, "equal");
var isObject = /* @__PURE__ */ __name((object)=>{
    return object != null && typeof object === "object";
}, "isObject");
var geojson_equality_ts_default = GeojsonEquality;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/clean-coords/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "cleanCoords": (()=>cleanCoords),
    "default": (()=>turf_clean_coords_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
;
function cleanCoords(geojson, options = {}) {
    var mutate = typeof options === "object" ? options.mutate : options;
    if (!geojson) throw new Error("geojson is required");
    var type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getType"])(geojson);
    var newCoords = [];
    switch(type){
        case "LineString":
            newCoords = cleanLine(geojson, type);
            break;
        case "MultiLineString":
        case "Polygon":
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(geojson).forEach(function(line) {
                newCoords.push(cleanLine(line, type));
            });
            break;
        case "MultiPolygon":
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(geojson).forEach(function(polygons) {
                var polyPoints = [];
                polygons.forEach(function(ring) {
                    polyPoints.push(cleanLine(ring, type));
                });
                newCoords.push(polyPoints);
            });
            break;
        case "Point":
            return geojson;
        case "MultiPoint":
            var existing = {};
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(geojson).forEach(function(coord) {
                var key = coord.join("-");
                if (!Object.prototype.hasOwnProperty.call(existing, key)) {
                    newCoords.push(coord);
                    existing[key] = true;
                }
            });
            break;
        default:
            throw new Error(type + " geometry not supported");
    }
    if (geojson.coordinates) {
        if (mutate === true) {
            geojson.coordinates = newCoords;
            return geojson;
        }
        return {
            type,
            coordinates: newCoords
        };
    } else {
        if (mutate === true) {
            geojson.geometry.coordinates = newCoords;
            return geojson;
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["feature"])({
            type,
            coordinates: newCoords
        }, geojson.properties, {
            bbox: geojson.bbox,
            id: geojson.id
        });
    }
}
function cleanLine(line, type) {
    var points = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(line);
    if (points.length === 2 && !equals(points[0], points[1])) return points;
    var newPoints = [];
    var secondToLast = points.length - 1;
    var newPointsLength = newPoints.length;
    newPoints.push(points[0]);
    for(var i = 1; i < secondToLast; i++){
        var prevAddedPoint = newPoints[newPoints.length - 1];
        if (points[i][0] === prevAddedPoint[0] && points[i][1] === prevAddedPoint[1]) continue;
        else {
            newPoints.push(points[i]);
            newPointsLength = newPoints.length;
            if (newPointsLength > 2) {
                if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2])) newPoints.splice(newPoints.length - 2, 1);
            }
        }
    }
    newPoints.push(points[points.length - 1]);
    newPointsLength = newPoints.length;
    if ((type === "Polygon" || type === "MultiPolygon") && equals(points[0], points[points.length - 1]) && newPointsLength < 4) {
        throw new Error("invalid polygon");
    }
    if (type === "LineString" && newPointsLength < 3) {
        return newPoints;
    }
    if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2])) newPoints.splice(newPoints.length - 2, 1);
    return newPoints;
}
function equals(pt1, pt2) {
    return pt1[0] === pt2[0] && pt1[1] === pt2[1];
}
function isPointOnLineSegment(start, end, point) {
    var x = point[0], y = point[1];
    var startX = start[0], startY = start[1];
    var endX = end[0], endY = end[1];
    var dxc = x - startX;
    var dyc = y - startY;
    var dxl = endX - startX;
    var dyl = endY - startY;
    var cross = dxc * dyl - dyc * dxl;
    if (cross !== 0) return false;
    else if (Math.abs(dxl) >= Math.abs(dyl)) return dxl > 0 ? startX <= x && x <= endX : endX <= x && x <= startX;
    else return dyl > 0 ? startY <= y && y <= endY : endY <= y && y <= startY;
}
var turf_clean_coords_default = cleanCoords;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/boolean-equal/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "booleanEqual": (()=>booleanEqual),
    "default": (()=>turf_boolean_equal_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$geojson$2d$equality$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/geojson-equality-ts/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clean$2d$coords$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clean-coords/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
function booleanEqual(feature1, feature2, options = {}) {
    let precision = options.precision;
    precision = precision === void 0 || precision === null || isNaN(precision) ? 6 : precision;
    if (typeof precision !== "number" || !(precision >= 0)) {
        throw new Error("precision must be a positive number");
    }
    const type1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGeom"])(feature1).type;
    const type2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGeom"])(feature2).type;
    if (type1 !== type2) return false;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$geojson$2d$equality$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["geojsonEquality"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clean$2d$coords$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cleanCoords"])(feature1), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clean$2d$coords$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cleanCoords"])(feature2), {
        precision
    });
}
var turf_boolean_equal_default = booleanEqual;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/boolean-intersects/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "booleanIntersects": (()=>booleanIntersects),
    "default": (()=>turf_boolean_intersects_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$disjoint$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-disjoint/dist/esm/index.js [app-client] (ecmascript)");
;
;
function booleanIntersects(feature1, feature2, { ignoreSelfIntersections = true } = {}) {
    let bool = false;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["flattenEach"])(feature1, (flatten1)=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["flattenEach"])(feature2, (flatten2)=>{
            if (bool === true) {
                return true;
            }
            bool = !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$disjoint$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanDisjoint"])(flatten1.geometry, flatten2.geometry, {
                ignoreSelfIntersections
            });
        });
    });
    return bool;
}
var turf_boolean_intersects_default = booleanIntersects;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/fast-deep-equal/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
// do not edit .js files directly - edit src/index.jst
module.exports = function equal(a, b) {
    if (a === b) return true;
    if (a && b && typeof a == 'object' && typeof b == 'object') {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
            length = a.length;
            if (length != b.length) return false;
            for(i = length; i-- !== 0;)if (!equal(a[i], b[i])) return false;
            return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for(i = length; i-- !== 0;)if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for(i = length; i-- !== 0;){
            var key = keys[i];
            if (!equal(a[key], b[key])) return false;
        }
        return true;
    }
    // true if both NaN, false otherwise
    return a !== a && b !== b;
};
}}),
"[project]/node_modules/rbush/rbush.min.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
!function(t, i) {
    ("TURBOPACK compile-time truthy", 1) ? module.exports = i() : ("TURBOPACK unreachable", undefined);
}(this, function() {
    "use strict";
    function t(t, r, e, a, h) {
        !function t(n, r, e, a, h) {
            for(; a > e;){
                if (a - e > 600) {
                    var o = a - e + 1, s = r - e + 1, l = Math.log(o), f = .5 * Math.exp(2 * l / 3), u = .5 * Math.sqrt(l * f * (o - f) / o) * (s - o / 2 < 0 ? -1 : 1), m = Math.max(e, Math.floor(r - s * f / o + u)), c = Math.min(a, Math.floor(r + (o - s) * f / o + u));
                    t(n, r, m, c, h);
                }
                var p = n[r], d = e, x = a;
                for(i(n, e, r), h(n[a], p) > 0 && i(n, e, a); d < x;){
                    for(i(n, d, x), d++, x--; h(n[d], p) < 0;)d++;
                    for(; h(n[x], p) > 0;)x--;
                }
                0 === h(n[e], p) ? i(n, e, x) : i(n, ++x, a), x <= r && (e = x + 1), r <= x && (a = x - 1);
            }
        }(t, r, e || 0, a || t.length - 1, h || n);
    }
    function i(t, i, n) {
        var r = t[i];
        t[i] = t[n], t[n] = r;
    }
    function n(t, i) {
        return t < i ? -1 : t > i ? 1 : 0;
    }
    var r = function(t) {
        void 0 === t && (t = 9), this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(.4 * this._maxEntries)), this.clear();
    };
    function e(t, i, n) {
        if (!n) return i.indexOf(t);
        for(var r = 0; r < i.length; r++)if (n(t, i[r])) return r;
        return -1;
    }
    function a(t, i) {
        h(t, 0, t.children.length, i, t);
    }
    function h(t, i, n, r, e) {
        e || (e = p(null)), e.minX = 1 / 0, e.minY = 1 / 0, e.maxX = -1 / 0, e.maxY = -1 / 0;
        for(var a = i; a < n; a++){
            var h = t.children[a];
            o(e, t.leaf ? r(h) : h);
        }
        return e;
    }
    function o(t, i) {
        return t.minX = Math.min(t.minX, i.minX), t.minY = Math.min(t.minY, i.minY), t.maxX = Math.max(t.maxX, i.maxX), t.maxY = Math.max(t.maxY, i.maxY), t;
    }
    function s(t, i) {
        return t.minX - i.minX;
    }
    function l(t, i) {
        return t.minY - i.minY;
    }
    function f(t) {
        return (t.maxX - t.minX) * (t.maxY - t.minY);
    }
    function u(t) {
        return t.maxX - t.minX + (t.maxY - t.minY);
    }
    function m(t, i) {
        return t.minX <= i.minX && t.minY <= i.minY && i.maxX <= t.maxX && i.maxY <= t.maxY;
    }
    function c(t, i) {
        return i.minX <= t.maxX && i.minY <= t.maxY && i.maxX >= t.minX && i.maxY >= t.minY;
    }
    function p(t) {
        return {
            children: t,
            height: 1,
            leaf: !0,
            minX: 1 / 0,
            minY: 1 / 0,
            maxX: -1 / 0,
            maxY: -1 / 0
        };
    }
    function d(i, n, r, e, a) {
        for(var h = [
            n,
            r
        ]; h.length;)if (!((r = h.pop()) - (n = h.pop()) <= e)) {
            var o = n + Math.ceil((r - n) / e / 2) * e;
            t(i, o, n, r, a), h.push(n, o, o, r);
        }
    }
    return r.prototype.all = function() {
        return this._all(this.data, []);
    }, r.prototype.search = function(t) {
        var i = this.data, n = [];
        if (!c(t, i)) return n;
        for(var r = this.toBBox, e = []; i;){
            for(var a = 0; a < i.children.length; a++){
                var h = i.children[a], o = i.leaf ? r(h) : h;
                c(t, o) && (i.leaf ? n.push(h) : m(t, o) ? this._all(h, n) : e.push(h));
            }
            i = e.pop();
        }
        return n;
    }, r.prototype.collides = function(t) {
        var i = this.data;
        if (!c(t, i)) return !1;
        for(var n = []; i;){
            for(var r = 0; r < i.children.length; r++){
                var e = i.children[r], a = i.leaf ? this.toBBox(e) : e;
                if (c(t, a)) {
                    if (i.leaf || m(t, a)) return !0;
                    n.push(e);
                }
            }
            i = n.pop();
        }
        return !1;
    }, r.prototype.load = function(t) {
        if (!t || !t.length) return this;
        if (t.length < this._minEntries) {
            for(var i = 0; i < t.length; i++)this.insert(t[i]);
            return this;
        }
        var n = this._build(t.slice(), 0, t.length - 1, 0);
        if (this.data.children.length) if (this.data.height === n.height) this._splitRoot(this.data, n);
        else {
            if (this.data.height < n.height) {
                var r = this.data;
                this.data = n, n = r;
            }
            this._insert(n, this.data.height - n.height - 1, !0);
        }
        else this.data = n;
        return this;
    }, r.prototype.insert = function(t) {
        return t && this._insert(t, this.data.height - 1), this;
    }, r.prototype.clear = function() {
        return this.data = p([]), this;
    }, r.prototype.remove = function(t, i) {
        if (!t) return this;
        for(var n, r, a, h = this.data, o = this.toBBox(t), s = [], l = []; h || s.length;){
            if (h || (h = s.pop(), r = s[s.length - 1], n = l.pop(), a = !0), h.leaf) {
                var f = e(t, h.children, i);
                if (-1 !== f) return h.children.splice(f, 1), s.push(h), this._condense(s), this;
            }
            a || h.leaf || !m(h, o) ? r ? (n++, h = r.children[n], a = !1) : h = null : (s.push(h), l.push(n), n = 0, r = h, h = h.children[0]);
        }
        return this;
    }, r.prototype.toBBox = function(t) {
        return t;
    }, r.prototype.compareMinX = function(t, i) {
        return t.minX - i.minX;
    }, r.prototype.compareMinY = function(t, i) {
        return t.minY - i.minY;
    }, r.prototype.toJSON = function() {
        return this.data;
    }, r.prototype.fromJSON = function(t) {
        return this.data = t, this;
    }, r.prototype._all = function(t, i) {
        for(var n = []; t;)t.leaf ? i.push.apply(i, t.children) : n.push.apply(n, t.children), t = n.pop();
        return i;
    }, r.prototype._build = function(t, i, n, r) {
        var e, h = n - i + 1, o = this._maxEntries;
        if (h <= o) return a(e = p(t.slice(i, n + 1)), this.toBBox), e;
        r || (r = Math.ceil(Math.log(h) / Math.log(o)), o = Math.ceil(h / Math.pow(o, r - 1))), (e = p([])).leaf = !1, e.height = r;
        var s = Math.ceil(h / o), l = s * Math.ceil(Math.sqrt(o));
        d(t, i, n, l, this.compareMinX);
        for(var f = i; f <= n; f += l){
            var u = Math.min(f + l - 1, n);
            d(t, f, u, s, this.compareMinY);
            for(var m = f; m <= u; m += s){
                var c = Math.min(m + s - 1, u);
                e.children.push(this._build(t, m, c, r - 1));
            }
        }
        return a(e, this.toBBox), e;
    }, r.prototype._chooseSubtree = function(t, i, n, r) {
        for(; r.push(i), !i.leaf && r.length - 1 !== n;){
            for(var e = 1 / 0, a = 1 / 0, h = void 0, o = 0; o < i.children.length; o++){
                var s = i.children[o], l = f(s), u = (m = t, c = s, (Math.max(c.maxX, m.maxX) - Math.min(c.minX, m.minX)) * (Math.max(c.maxY, m.maxY) - Math.min(c.minY, m.minY)) - l);
                u < a ? (a = u, e = l < e ? l : e, h = s) : u === a && l < e && (e = l, h = s);
            }
            i = h || i.children[0];
        }
        var m, c;
        return i;
    }, r.prototype._insert = function(t, i, n) {
        var r = n ? t : this.toBBox(t), e = [], a = this._chooseSubtree(r, this.data, i, e);
        for(a.children.push(t), o(a, r); i >= 0 && e[i].children.length > this._maxEntries;)this._split(e, i), i--;
        this._adjustParentBBoxes(r, e, i);
    }, r.prototype._split = function(t, i) {
        var n = t[i], r = n.children.length, e = this._minEntries;
        this._chooseSplitAxis(n, e, r);
        var h = this._chooseSplitIndex(n, e, r), o = p(n.children.splice(h, n.children.length - h));
        o.height = n.height, o.leaf = n.leaf, a(n, this.toBBox), a(o, this.toBBox), i ? t[i - 1].children.push(o) : this._splitRoot(n, o);
    }, r.prototype._splitRoot = function(t, i) {
        this.data = p([
            t,
            i
        ]), this.data.height = t.height + 1, this.data.leaf = !1, a(this.data, this.toBBox);
    }, r.prototype._chooseSplitIndex = function(t, i, n) {
        for(var r, e, a, o, s, l, u, m = 1 / 0, c = 1 / 0, p = i; p <= n - i; p++){
            var d = h(t, 0, p, this.toBBox), x = h(t, p, n, this.toBBox), v = (e = d, a = x, o = void 0, s = void 0, l = void 0, u = void 0, o = Math.max(e.minX, a.minX), s = Math.max(e.minY, a.minY), l = Math.min(e.maxX, a.maxX), u = Math.min(e.maxY, a.maxY), Math.max(0, l - o) * Math.max(0, u - s)), M = f(d) + f(x);
            v < m ? (m = v, r = p, c = M < c ? M : c) : v === m && M < c && (c = M, r = p);
        }
        return r || n - i;
    }, r.prototype._chooseSplitAxis = function(t, i, n) {
        var r = t.leaf ? this.compareMinX : s, e = t.leaf ? this.compareMinY : l;
        this._allDistMargin(t, i, n, r) < this._allDistMargin(t, i, n, e) && t.children.sort(r);
    }, r.prototype._allDistMargin = function(t, i, n, r) {
        t.children.sort(r);
        for(var e = this.toBBox, a = h(t, 0, i, e), s = h(t, n - i, n, e), l = u(a) + u(s), f = i; f < n - i; f++){
            var m = t.children[f];
            o(a, t.leaf ? e(m) : m), l += u(a);
        }
        for(var c = n - i - 1; c >= i; c--){
            var p = t.children[c];
            o(s, t.leaf ? e(p) : p), l += u(s);
        }
        return l;
    }, r.prototype._adjustParentBBoxes = function(t, i, n) {
        for(var r = n; r >= 0; r--)o(i[r], t);
    }, r.prototype._condense = function(t) {
        for(var i = t.length - 1, n = void 0; i >= 0; i--)0 === t[i].children.length ? i > 0 ? (n = t[i - 1].children).splice(n.indexOf(t[i]), 1) : this.clear() : a(t[i], this.toBBox);
    }, r;
});
}}),
"[project]/node_modules/@turf/geojson-rbush/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.js
__turbopack_esm__({
    "default": (()=>turf_geojson_rbush_default),
    "geojsonRbush": (()=>geojsonRbush)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$rbush$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rbush/rbush.min.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
function geojsonRbush(maxEntries) {
    var tree = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$rbush$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](maxEntries);
    tree.insert = function(feature) {
        if (feature.type !== "Feature") throw new Error("invalid feature");
        feature.bbox = feature.bbox ? feature.bbox : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bbox"])(feature);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$rbush$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].prototype.insert.call(this, feature);
    };
    tree.load = function(features) {
        var load = [];
        if (Array.isArray(features)) {
            features.forEach(function(feature) {
                if (feature.type !== "Feature") throw new Error("invalid features");
                feature.bbox = feature.bbox ? feature.bbox : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bbox"])(feature);
                load.push(feature);
            });
        } else {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"])(features, function(feature) {
                if (feature.type !== "Feature") throw new Error("invalid features");
                feature.bbox = feature.bbox ? feature.bbox : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bbox"])(feature);
                load.push(feature);
            });
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$rbush$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].prototype.load.call(this, load);
    };
    tree.remove = function(feature, equals) {
        if (feature.type !== "Feature") throw new Error("invalid feature");
        feature.bbox = feature.bbox ? feature.bbox : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bbox"])(feature);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$rbush$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].prototype.remove.call(this, feature, equals);
    };
    tree.clear = function() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$rbush$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].prototype.clear.call(this);
    };
    tree.search = function(geojson) {
        var features = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$rbush$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].prototype.search.call(this, this.toBBox(geojson));
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(features);
    };
    tree.collides = function(geojson) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$rbush$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].prototype.collides.call(this, this.toBBox(geojson));
    };
    tree.all = function() {
        var features = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$rbush$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].prototype.all.call(this);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(features);
    };
    tree.toJSON = function() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$rbush$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].prototype.toJSON.call(this);
    };
    tree.fromJSON = function(json) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$rbush$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].prototype.fromJSON.call(this, json);
    };
    tree.toBBox = function(geojson) {
        var bbox;
        if (geojson.bbox) bbox = geojson.bbox;
        else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;
        else if (Array.isArray(geojson) && geojson.length === 6) bbox = [
            geojson[0],
            geojson[1],
            geojson[3],
            geojson[4]
        ];
        else if (geojson.type === "Feature") bbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bbox"])(geojson);
        else if (geojson.type === "FeatureCollection") bbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bbox"])(geojson);
        else throw new Error("invalid geojson");
        return {
            minX: bbox[0],
            minY: bbox[1],
            maxX: bbox[2],
            maxY: bbox[3]
        };
    };
    return tree;
}
var turf_geojson_rbush_default = geojsonRbush;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/line-segment/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_line_segment_default),
    "lineSegment": (()=>lineSegment)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
function lineSegment(geojson) {
    if (!geojson) {
        throw new Error("geojson is required");
    }
    const results = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["flattenEach"])(geojson, (feature)=>{
        lineSegmentFeature(feature, results);
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(results);
}
function lineSegmentFeature(geojson, results) {
    let coords = [];
    const geometry = geojson.geometry;
    if (geometry !== null) {
        switch(geometry.type){
            case "Polygon":
                coords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(geometry);
                break;
            case "LineString":
                coords = [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(geometry)
                ];
        }
        coords.forEach((coord)=>{
            const segments = createSegments(coord, geojson.properties);
            segments.forEach((segment)=>{
                segment.id = results.length;
                results.push(segment);
            });
        });
    }
}
function createSegments(coords, properties) {
    const segments = [];
    coords.reduce((previousCoords, currentCoords)=>{
        const segment = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineString"])([
            previousCoords,
            currentCoords
        ], properties);
        segment.bbox = bbox(previousCoords, currentCoords);
        segments.push(segment);
        return currentCoords;
    });
    return segments;
}
function bbox(coords1, coords2) {
    const x1 = coords1[0];
    const y1 = coords1[1];
    const x2 = coords2[0];
    const y2 = coords2[1];
    const west = x1 < x2 ? x1 : x2;
    const south = y1 < y2 ? y1 : y2;
    const east = x1 > x2 ? x1 : x2;
    const north = y1 > y2 ? y1 : y2;
    return [
        west,
        south,
        east,
        north
    ];
}
var turf_line_segment_default = lineSegment;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/nearest-point-on-line/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>turf_nearest_point_on_line_default),
    "nearestPointOnLine": (()=>nearestPointOnLine)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
// index.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-client] (ecmascript)");
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));
;
;
;
;
function nearestPointOnLine(lines, pt, options = {}) {
    if (!lines || !pt) {
        throw new Error("lines and pt are required arguments");
    }
    const ptPos = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(pt);
    let closestPt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])([
        Infinity,
        Infinity
    ], {
        dist: Infinity,
        index: -1,
        multiFeatureIndex: -1,
        location: -1
    });
    let length = 0;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["flattenEach"])(lines, function(line, _featureIndex, multiFeatureIndex) {
        const coords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(line);
        for(let i = 0; i < coords.length - 1; i++){
            const start = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])(coords[i]);
            start.properties.dist = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(pt, start, options);
            const startPos = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(start);
            const stop = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])(coords[i + 1]);
            stop.properties.dist = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(pt, stop, options);
            const stopPos = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(stop);
            const sectionLength = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(start, stop, options);
            let intersectPos;
            let wasEnd;
            if (startPos[0] === ptPos[0] && startPos[1] === ptPos[1]) {
                [intersectPos, , wasEnd] = [
                    startPos,
                    void 0,
                    false
                ];
            } else if (stopPos[0] === ptPos[0] && stopPos[1] === ptPos[1]) {
                [intersectPos, , wasEnd] = [
                    stopPos,
                    void 0,
                    true
                ];
            } else {
                [intersectPos, , wasEnd] = nearestPointOnSegment(start.geometry.coordinates, stop.geometry.coordinates, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(pt));
            }
            let intersectPt;
            if (intersectPos) {
                intersectPt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])(intersectPos, {
                    dist: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(pt, intersectPos, options),
                    multiFeatureIndex,
                    location: length + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(start, intersectPos, options)
                });
            }
            if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {
                closestPt = __spreadProps(__spreadValues({}, intersectPt), {
                    properties: __spreadProps(__spreadValues({}, intersectPt.properties), {
                        // Legacy behaviour where index progresses to next segment # if we
                        // went with the end point this iteration.
                        index: wasEnd ? i + 1 : i
                    })
                });
            }
            length += sectionLength;
        }
    });
    return closestPt;
}
function dot(v1, v2) {
    const [v1x, v1y, v1z] = v1;
    const [v2x, v2y, v2z] = v2;
    return v1x * v2x + v1y * v2y + v1z * v2z;
}
function cross(v1, v2) {
    const [v1x, v1y, v1z] = v1;
    const [v2x, v2y, v2z] = v2;
    return [
        v1y * v2z - v1z * v2y,
        v1z * v2x - v1x * v2z,
        v1x * v2y - v1y * v2x
    ];
}
function magnitude(v) {
    return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2) + Math.pow(v[2], 2));
}
function angle(v1, v2) {
    const theta = dot(v1, v2) / (magnitude(v1) * magnitude(v2));
    return Math.acos(Math.min(Math.max(theta, -1), 1));
}
function lngLatToVector(a) {
    const lat = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])(a[1]);
    const lng = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])(a[0]);
    return [
        Math.cos(lat) * Math.cos(lng),
        Math.cos(lat) * Math.sin(lng),
        Math.sin(lat)
    ];
}
function vectorToLngLat(v) {
    const [x, y, z] = v;
    const lat = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["radiansToDegrees"])(Math.asin(z));
    const lng = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["radiansToDegrees"])(Math.atan2(y, x));
    return [
        lng,
        lat
    ];
}
function nearestPointOnSegment(posA, posB, posC) {
    const A = lngLatToVector(posA);
    const B = lngLatToVector(posB);
    const C = lngLatToVector(posC);
    const [Cx, Cy, Cz] = C;
    const [D, E, F] = cross(A, B);
    const a = E * Cz - F * Cy;
    const b = F * Cx - D * Cz;
    const c = D * Cy - E * Cx;
    const f = c * E - b * F;
    const g = a * F - c * D;
    const h = b * D - a * E;
    const t = 1 / Math.sqrt(Math.pow(f, 2) + Math.pow(g, 2) + Math.pow(h, 2));
    const I1 = [
        f * t,
        g * t,
        h * t
    ];
    const I2 = [
        -1 * f * t,
        -1 * g * t,
        -1 * h * t
    ];
    const angleAB = angle(A, B);
    const angleAI1 = angle(A, I1);
    const angleBI1 = angle(B, I1);
    const angleAI2 = angle(A, I2);
    const angleBI2 = angle(B, I2);
    let I;
    if (angleAI1 < angleAI2 && angleAI1 < angleBI2 || angleBI1 < angleAI2 && angleBI1 < angleBI2) {
        I = I1;
    } else {
        I = I2;
    }
    if (angle(A, I) > angleAB || angle(B, I) > angleAB) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(vectorToLngLat(I), vectorToLngLat(A)) <= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(vectorToLngLat(I), vectorToLngLat(B))) {
            return [
                vectorToLngLat(A),
                true,
                false
            ];
        } else {
            return [
                vectorToLngLat(B),
                false,
                true
            ];
        }
    }
    return [
        vectorToLngLat(I),
        false,
        false
    ];
}
var turf_nearest_point_on_line_default = nearestPointOnLine;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/line-overlap/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_line_overlap_default),
    "lineOverlap": (()=>lineOverlap)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$deep$2d$equal$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/fast-deep-equal/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$geojson$2d$rbush$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/geojson-rbush/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$segment$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-segment/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/nearest-point-on-line/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-on-line/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
function lineOverlap(line1, line2, options = {}) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    var tolerance = options.tolerance || 0;
    var features = [];
    var tree = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$geojson$2d$rbush$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["geojsonRbush"])();
    const line = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$segment$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineSegment"])(line1);
    tree.load(line);
    var overlapSegment;
    let additionalSegments = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["segmentEach"])(line2, function(segment) {
        var doesOverlaps = false;
        if (!segment) {
            return;
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"])(tree.search(segment), function(match) {
            if (doesOverlaps === false) {
                var coordsSegment = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(segment).sort();
                var coordsMatch = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(match).sort();
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$deep$2d$equal$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(coordsSegment, coordsMatch)) {
                    doesOverlaps = true;
                    if (overlapSegment) {
                        overlapSegment = concatSegment(overlapSegment, segment) || overlapSegment;
                    } else overlapSegment = segment;
                } else if (tolerance === 0 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(coordsSegment[0], match) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(coordsSegment[1], match) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nearestPointOnLine"])(match, coordsSegment[0]).properties.dist <= tolerance && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nearestPointOnLine"])(match, coordsSegment[1]).properties.dist <= tolerance) {
                    doesOverlaps = true;
                    if (overlapSegment) {
                        overlapSegment = concatSegment(overlapSegment, segment) || overlapSegment;
                    } else overlapSegment = segment;
                } else if (tolerance === 0 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(coordsMatch[0], segment) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(coordsMatch[1], segment) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nearestPointOnLine"])(segment, coordsMatch[0]).properties.dist <= tolerance && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nearestPointOnLine"])(segment, coordsMatch[1]).properties.dist <= tolerance) {
                    if (overlapSegment) {
                        const combinedSegment = concatSegment(overlapSegment, match);
                        if (combinedSegment) {
                            overlapSegment = combinedSegment;
                        } else {
                            additionalSegments.push(match);
                        }
                    } else overlapSegment = match;
                }
            }
        });
        if (doesOverlaps === false && overlapSegment) {
            features.push(overlapSegment);
            if (additionalSegments.length) {
                features = features.concat(additionalSegments);
                additionalSegments = [];
            }
            overlapSegment = void 0;
        }
    });
    if (overlapSegment) features.push(overlapSegment);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(features);
}
function concatSegment(line, segment) {
    var coords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(segment);
    var lineCoords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(line);
    var start = lineCoords[0];
    var end = lineCoords[lineCoords.length - 1];
    var geom = line.geometry.coordinates;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$deep$2d$equal$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(coords[0], start)) geom.unshift(coords[1]);
    else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$deep$2d$equal$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(coords[0], end)) geom.push(coords[1]);
    else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$deep$2d$equal$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(coords[1], start)) geom.unshift(coords[0]);
    else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$deep$2d$equal$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(coords[1], end)) geom.push(coords[0]);
    else return;
    return line;
}
var turf_line_overlap_default = lineOverlap;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/boolean-overlap/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "booleanOverlap": (()=>booleanOverlap),
    "default": (()=>turf_boolean_overlap_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$geojson$2d$equality$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/geojson-equality-ts/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$overlap$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-overlap/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-intersect/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
;
function booleanOverlap(feature1, feature2) {
    const geom1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGeom"])(feature1);
    const geom2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGeom"])(feature2);
    const type1 = geom1.type;
    const type2 = geom2.type;
    if (type1 === "MultiPoint" && type2 !== "MultiPoint" || (type1 === "LineString" || type1 === "MultiLineString") && type2 !== "LineString" && type2 !== "MultiLineString" || (type1 === "Polygon" || type1 === "MultiPolygon") && type2 !== "Polygon" && type2 !== "MultiPolygon") {
        throw new Error("features must be of the same type");
    }
    if (type1 === "Point") throw new Error("Point geometry not supported");
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$geojson$2d$equality$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["geojsonEquality"])(feature1, feature2, {
        precision: 6
    })) return false;
    let overlap = 0;
    switch(type1){
        case "MultiPoint":
            for(var i = 0; i < geom1.coordinates.length; i++){
                for(var j = 0; j < geom2.coordinates.length; j++){
                    var coord1 = geom1.coordinates[i];
                    var coord2 = geom2.coordinates[j];
                    if (coord1[0] === coord2[0] && coord1[1] === coord2[1]) {
                        return true;
                    }
                }
            }
            return false;
        case "LineString":
        case "MultiLineString":
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["segmentEach"])(feature1, (segment1)=>{
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["segmentEach"])(feature2, (segment2)=>{
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$overlap$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineOverlap"])(segment1, segment2).features.length) overlap++;
                });
            });
            break;
        case "Polygon":
        case "MultiPolygon":
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["segmentEach"])(feature1, (segment1)=>{
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["segmentEach"])(feature2, (segment2)=>{
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineIntersect"])(segment1, segment2).features.length) overlap++;
                });
            });
            break;
    }
    return overlap > 0;
}
var turf_boolean_overlap_default = booleanOverlap;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/boolean-parallel/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "booleanParallel": (()=>booleanParallel),
    "default": (()=>turf_boolean_parallel_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$segment$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-segment/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clean$2d$coords$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clean-coords/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rhumb-bearing/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
function booleanParallel(line1, line2) {
    if (!line1) throw new Error("line1 is required");
    if (!line2) throw new Error("line2 is required");
    var type1 = getType(line1, "line1");
    if (type1 !== "LineString") throw new Error("line1 must be a LineString");
    var type2 = getType(line2, "line2");
    if (type2 !== "LineString") throw new Error("line2 must be a LineString");
    var segments1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$segment$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineSegment"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clean$2d$coords$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cleanCoords"])(line1)).features;
    var segments2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$segment$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineSegment"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clean$2d$coords$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cleanCoords"])(line2)).features;
    for(var i = 0; i < segments1.length; i++){
        var segment1 = segments1[i].geometry.coordinates;
        if (!segments2[i]) break;
        var segment2 = segments2[i].geometry.coordinates;
        if (!isParallel(segment1, segment2)) return false;
    }
    return true;
}
function isParallel(segment1, segment2) {
    var slope1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bearingToAzimuth"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rhumbBearing"])(segment1[0], segment1[1]));
    var slope2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bearingToAzimuth"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rhumbBearing"])(segment2[0], segment2[1]));
    return slope1 === slope2 || (slope2 - slope1) % 180 === 0;
}
function getType(geojson, name) {
    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;
    if (geojson.type) return geojson.type;
    throw new Error("Invalid GeoJSON object for " + name);
}
var turf_boolean_parallel_default = booleanParallel;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/boolean-touches/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "booleanTouches": (()=>booleanTouches),
    "default": (()=>turf_boolean_touches_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-on-line/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
function booleanTouches(feature1, feature2) {
    var geom1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGeom"])(feature1);
    var geom2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGeom"])(feature2);
    var type1 = geom1.type;
    var type2 = geom2.type;
    switch(type1){
        case "Point":
            switch(type2){
                case "LineString":
                    return isPointOnLineEnd(geom1, geom2);
                case "MultiLineString":
                    var foundTouchingPoint = false;
                    for(var ii = 0; ii < geom2.coordinates.length; ii++){
                        if (isPointOnLineEnd(geom1, {
                            type: "LineString",
                            coordinates: geom2.coordinates[ii]
                        })) foundTouchingPoint = true;
                    }
                    return foundTouchingPoint;
                case "Polygon":
                    for(var i = 0; i < geom2.coordinates.length; i++){
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(geom1, {
                            type: "LineString",
                            coordinates: geom2.coordinates[i]
                        })) return true;
                    }
                    return false;
                case "MultiPolygon":
                    for(var i = 0; i < geom2.coordinates.length; i++){
                        for(var ii = 0; ii < geom2.coordinates[i].length; ii++){
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(geom1, {
                                type: "LineString",
                                coordinates: geom2.coordinates[i][ii]
                            })) return true;
                        }
                    }
                    return false;
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "MultiPoint":
            switch(type2){
                case "LineString":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom1.coordinates.length; i++){
                        if (!foundTouchingPoint) {
                            if (isPointOnLineEnd({
                                type: "Point",
                                coordinates: geom1.coordinates[i]
                            }, geom2)) foundTouchingPoint = true;
                        }
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                            type: "Point",
                            coordinates: geom1.coordinates[i]
                        }, geom2, {
                            ignoreEndVertices: true
                        })) return false;
                    }
                    return foundTouchingPoint;
                case "MultiLineString":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom1.coordinates.length; i++){
                        for(var ii = 0; ii < geom2.coordinates.length; ii++){
                            if (!foundTouchingPoint) {
                                if (isPointOnLineEnd({
                                    type: "Point",
                                    coordinates: geom1.coordinates[i]
                                }, {
                                    type: "LineString",
                                    coordinates: geom2.coordinates[ii]
                                })) foundTouchingPoint = true;
                            }
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                type: "Point",
                                coordinates: geom1.coordinates[i]
                            }, {
                                type: "LineString",
                                coordinates: geom2.coordinates[ii]
                            }, {
                                ignoreEndVertices: true
                            })) return false;
                        }
                    }
                    return foundTouchingPoint;
                case "Polygon":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom1.coordinates.length; i++){
                        if (!foundTouchingPoint) {
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                type: "Point",
                                coordinates: geom1.coordinates[i]
                            }, {
                                type: "LineString",
                                coordinates: geom2.coordinates[0]
                            })) foundTouchingPoint = true;
                        }
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
                            type: "Point",
                            coordinates: geom1.coordinates[i]
                        }, geom2, {
                            ignoreBoundary: true
                        })) return false;
                    }
                    return foundTouchingPoint;
                case "MultiPolygon":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom1.coordinates.length; i++){
                        for(var ii = 0; ii < geom2.coordinates.length; ii++){
                            if (!foundTouchingPoint) {
                                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                    type: "Point",
                                    coordinates: geom1.coordinates[i]
                                }, {
                                    type: "LineString",
                                    coordinates: geom2.coordinates[ii][0]
                                })) foundTouchingPoint = true;
                            }
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
                                type: "Point",
                                coordinates: geom1.coordinates[i]
                            }, {
                                type: "Polygon",
                                coordinates: geom2.coordinates[ii]
                            }, {
                                ignoreBoundary: true
                            })) return false;
                        }
                    }
                    return foundTouchingPoint;
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "LineString":
            switch(type2){
                case "Point":
                    return isPointOnLineEnd(geom2, geom1);
                case "MultiPoint":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom2.coordinates.length; i++){
                        if (!foundTouchingPoint) {
                            if (isPointOnLineEnd({
                                type: "Point",
                                coordinates: geom2.coordinates[i]
                            }, geom1)) foundTouchingPoint = true;
                        }
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                            type: "Point",
                            coordinates: geom2.coordinates[i]
                        }, geom1, {
                            ignoreEndVertices: true
                        })) return false;
                    }
                    return foundTouchingPoint;
                case "LineString":
                    var endMatch = false;
                    if (isPointOnLineEnd({
                        type: "Point",
                        coordinates: geom1.coordinates[0]
                    }, geom2)) endMatch = true;
                    if (isPointOnLineEnd({
                        type: "Point",
                        coordinates: geom1.coordinates[geom1.coordinates.length - 1]
                    }, geom2)) endMatch = true;
                    if (endMatch === false) return false;
                    for(var i = 0; i < geom1.coordinates.length; i++){
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                            type: "Point",
                            coordinates: geom1.coordinates[i]
                        }, geom2, {
                            ignoreEndVertices: true
                        })) return false;
                    }
                    return endMatch;
                case "MultiLineString":
                    var endMatch = false;
                    for(var i = 0; i < geom2.coordinates.length; i++){
                        if (isPointOnLineEnd({
                            type: "Point",
                            coordinates: geom1.coordinates[0]
                        }, {
                            type: "LineString",
                            coordinates: geom2.coordinates[i]
                        })) endMatch = true;
                        if (isPointOnLineEnd({
                            type: "Point",
                            coordinates: geom1.coordinates[geom1.coordinates.length - 1]
                        }, {
                            type: "LineString",
                            coordinates: geom2.coordinates[i]
                        })) endMatch = true;
                        for(var ii = 0; ii < geom1.coordinates[i].length; ii++){
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                type: "Point",
                                coordinates: geom1.coordinates[ii]
                            }, {
                                type: "LineString",
                                coordinates: geom2.coordinates[i]
                            }, {
                                ignoreEndVertices: true
                            })) return false;
                        }
                    }
                    return endMatch;
                case "Polygon":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom1.coordinates.length; i++){
                        if (!foundTouchingPoint) {
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                type: "Point",
                                coordinates: geom1.coordinates[i]
                            }, {
                                type: "LineString",
                                coordinates: geom2.coordinates[0]
                            })) foundTouchingPoint = true;
                        }
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
                            type: "Point",
                            coordinates: geom1.coordinates[i]
                        }, geom2, {
                            ignoreBoundary: true
                        })) return false;
                    }
                    return foundTouchingPoint;
                case "MultiPolygon":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom1.coordinates.length; i++){
                        for(var ii = 0; ii < geom2.coordinates.length; ii++){
                            if (!foundTouchingPoint) {
                                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                    type: "Point",
                                    coordinates: geom1.coordinates[i]
                                }, {
                                    type: "LineString",
                                    coordinates: geom2.coordinates[ii][0]
                                })) foundTouchingPoint = true;
                            }
                        }
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
                            type: "Point",
                            coordinates: geom1.coordinates[i]
                        }, geom2, {
                            ignoreBoundary: true
                        })) return false;
                    }
                    return foundTouchingPoint;
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "MultiLineString":
            switch(type2){
                case "Point":
                    for(var i = 0; i < geom1.coordinates.length; i++){
                        if (isPointOnLineEnd(geom2, {
                            type: "LineString",
                            coordinates: geom1.coordinates[i]
                        })) return true;
                    }
                    return false;
                case "MultiPoint":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom1.coordinates.length; i++){
                        for(var ii = 0; ii < geom2.coordinates.length; ii++){
                            if (!foundTouchingPoint) {
                                if (isPointOnLineEnd({
                                    type: "Point",
                                    coordinates: geom2.coordinates[ii]
                                }, {
                                    type: "LineString",
                                    coordinates: geom1.coordinates[ii]
                                })) foundTouchingPoint = true;
                            }
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                type: "Point",
                                coordinates: geom2.coordinates[ii]
                            }, {
                                type: "LineString",
                                coordinates: geom1.coordinates[ii]
                            }, {
                                ignoreEndVertices: true
                            })) return false;
                        }
                    }
                    return foundTouchingPoint;
                case "LineString":
                    var endMatch = false;
                    for(var i = 0; i < geom1.coordinates.length; i++){
                        if (isPointOnLineEnd({
                            type: "Point",
                            coordinates: geom1.coordinates[i][0]
                        }, geom2)) endMatch = true;
                        if (isPointOnLineEnd({
                            type: "Point",
                            coordinates: geom1.coordinates[i][geom1.coordinates[i].length - 1]
                        }, geom2)) endMatch = true;
                        for(var ii = 0; ii < geom2.coordinates.length; ii++){
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                type: "Point",
                                coordinates: geom2.coordinates[ii]
                            }, {
                                type: "LineString",
                                coordinates: geom1.coordinates[i]
                            }, {
                                ignoreEndVertices: true
                            })) return false;
                        }
                    }
                    return endMatch;
                case "MultiLineString":
                    var endMatch = false;
                    for(var i = 0; i < geom1.coordinates.length; i++){
                        for(var ii = 0; ii < geom2.coordinates.length; ii++){
                            if (isPointOnLineEnd({
                                type: "Point",
                                coordinates: geom1.coordinates[i][0]
                            }, {
                                type: "LineString",
                                coordinates: geom2.coordinates[ii]
                            })) endMatch = true;
                            if (isPointOnLineEnd({
                                type: "Point",
                                coordinates: geom1.coordinates[i][geom1.coordinates[i].length - 1]
                            }, {
                                type: "LineString",
                                coordinates: geom2.coordinates[ii]
                            })) endMatch = true;
                            for(var iii = 0; iii < geom1.coordinates[i].length; iii++){
                                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                    type: "Point",
                                    coordinates: geom1.coordinates[i][iii]
                                }, {
                                    type: "LineString",
                                    coordinates: geom2.coordinates[ii]
                                }, {
                                    ignoreEndVertices: true
                                })) return false;
                            }
                        }
                    }
                    return endMatch;
                case "Polygon":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom1.coordinates.length; i++){
                        for(var ii = 0; ii < geom1.coordinates.length; ii++){
                            if (!foundTouchingPoint) {
                                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                    type: "Point",
                                    coordinates: geom1.coordinates[i][ii]
                                }, {
                                    type: "LineString",
                                    coordinates: geom2.coordinates[0]
                                })) foundTouchingPoint = true;
                            }
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
                                type: "Point",
                                coordinates: geom1.coordinates[i][ii]
                            }, geom2, {
                                ignoreBoundary: true
                            })) return false;
                        }
                    }
                    return foundTouchingPoint;
                case "MultiPolygon":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom2.coordinates[0].length; i++){
                        for(var ii = 0; ii < geom1.coordinates.length; ii++){
                            for(var iii = 0; iii < geom1.coordinates[ii].length; iii++){
                                if (!foundTouchingPoint) {
                                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                        type: "Point",
                                        coordinates: geom1.coordinates[ii][iii]
                                    }, {
                                        type: "LineString",
                                        coordinates: geom2.coordinates[0][i]
                                    })) foundTouchingPoint = true;
                                }
                                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
                                    type: "Point",
                                    coordinates: geom1.coordinates[ii][iii]
                                }, {
                                    type: "Polygon",
                                    coordinates: [
                                        geom2.coordinates[0][i]
                                    ]
                                }, {
                                    ignoreBoundary: true
                                })) return false;
                            }
                        }
                    }
                    return foundTouchingPoint;
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "Polygon":
            switch(type2){
                case "Point":
                    for(var i = 0; i < geom1.coordinates.length; i++){
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(geom2, {
                            type: "LineString",
                            coordinates: geom1.coordinates[i]
                        })) return true;
                    }
                    return false;
                case "MultiPoint":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom2.coordinates.length; i++){
                        if (!foundTouchingPoint) {
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                type: "Point",
                                coordinates: geom2.coordinates[i]
                            }, {
                                type: "LineString",
                                coordinates: geom1.coordinates[0]
                            })) foundTouchingPoint = true;
                        }
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
                            type: "Point",
                            coordinates: geom2.coordinates[i]
                        }, geom1, {
                            ignoreBoundary: true
                        })) return false;
                    }
                    return foundTouchingPoint;
                case "LineString":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom2.coordinates.length; i++){
                        if (!foundTouchingPoint) {
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                type: "Point",
                                coordinates: geom2.coordinates[i]
                            }, {
                                type: "LineString",
                                coordinates: geom1.coordinates[0]
                            })) foundTouchingPoint = true;
                        }
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
                            type: "Point",
                            coordinates: geom2.coordinates[i]
                        }, geom1, {
                            ignoreBoundary: true
                        })) return false;
                    }
                    return foundTouchingPoint;
                case "MultiLineString":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom2.coordinates.length; i++){
                        for(var ii = 0; ii < geom2.coordinates[i].length; ii++){
                            if (!foundTouchingPoint) {
                                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                    type: "Point",
                                    coordinates: geom2.coordinates[i][ii]
                                }, {
                                    type: "LineString",
                                    coordinates: geom1.coordinates[0]
                                })) foundTouchingPoint = true;
                            }
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
                                type: "Point",
                                coordinates: geom2.coordinates[i][ii]
                            }, geom1, {
                                ignoreBoundary: true
                            })) return false;
                        }
                    }
                    return foundTouchingPoint;
                case "Polygon":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom1.coordinates[0].length; i++){
                        if (!foundTouchingPoint) {
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                type: "Point",
                                coordinates: geom1.coordinates[0][i]
                            }, {
                                type: "LineString",
                                coordinates: geom2.coordinates[0]
                            })) foundTouchingPoint = true;
                        }
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
                            type: "Point",
                            coordinates: geom1.coordinates[0][i]
                        }, geom2, {
                            ignoreBoundary: true
                        })) return false;
                    }
                    return foundTouchingPoint;
                case "MultiPolygon":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom2.coordinates[0].length; i++){
                        for(var ii = 0; ii < geom1.coordinates[0].length; ii++){
                            if (!foundTouchingPoint) {
                                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                    type: "Point",
                                    coordinates: geom1.coordinates[0][ii]
                                }, {
                                    type: "LineString",
                                    coordinates: geom2.coordinates[0][i]
                                })) foundTouchingPoint = true;
                            }
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
                                type: "Point",
                                coordinates: geom1.coordinates[0][ii]
                            }, {
                                type: "Polygon",
                                coordinates: geom2.coordinates[0][i]
                            }, {
                                ignoreBoundary: true
                            })) return false;
                        }
                    }
                    return foundTouchingPoint;
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "MultiPolygon":
            switch(type2){
                case "Point":
                    for(var i = 0; i < geom1.coordinates[0].length; i++){
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(geom2, {
                            type: "LineString",
                            coordinates: geom1.coordinates[0][i]
                        })) return true;
                    }
                    return false;
                case "MultiPoint":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom1.coordinates[0].length; i++){
                        for(var ii = 0; ii < geom2.coordinates.length; ii++){
                            if (!foundTouchingPoint) {
                                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                    type: "Point",
                                    coordinates: geom2.coordinates[ii]
                                }, {
                                    type: "LineString",
                                    coordinates: geom1.coordinates[0][i]
                                })) foundTouchingPoint = true;
                            }
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
                                type: "Point",
                                coordinates: geom2.coordinates[ii]
                            }, {
                                type: "Polygon",
                                coordinates: geom1.coordinates[0][i]
                            }, {
                                ignoreBoundary: true
                            })) return false;
                        }
                    }
                    return foundTouchingPoint;
                case "LineString":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom1.coordinates[0].length; i++){
                        for(var ii = 0; ii < geom2.coordinates.length; ii++){
                            if (!foundTouchingPoint) {
                                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                    type: "Point",
                                    coordinates: geom2.coordinates[ii]
                                }, {
                                    type: "LineString",
                                    coordinates: geom1.coordinates[0][i]
                                })) foundTouchingPoint = true;
                            }
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
                                type: "Point",
                                coordinates: geom2.coordinates[ii]
                            }, {
                                type: "Polygon",
                                coordinates: geom1.coordinates[0][i]
                            }, {
                                ignoreBoundary: true
                            })) return false;
                        }
                    }
                    return foundTouchingPoint;
                case "MultiLineString":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom1.coordinates.length; i++){
                        for(var ii = 0; ii < geom2.coordinates.length; ii++){
                            for(var iii = 0; iii < geom2.coordinates[ii].length; iii++){
                                if (!foundTouchingPoint) {
                                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                        type: "Point",
                                        coordinates: geom2.coordinates[ii][iii]
                                    }, {
                                        type: "LineString",
                                        coordinates: geom1.coordinates[i][0]
                                    })) foundTouchingPoint = true;
                                }
                                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
                                    type: "Point",
                                    coordinates: geom2.coordinates[ii][iii]
                                }, {
                                    type: "Polygon",
                                    coordinates: [
                                        geom1.coordinates[i][0]
                                    ]
                                }, {
                                    ignoreBoundary: true
                                })) return false;
                            }
                        }
                    }
                    return foundTouchingPoint;
                case "Polygon":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom1.coordinates[0].length; i++){
                        for(var ii = 0; ii < geom1.coordinates[0][i].length; ii++){
                            if (!foundTouchingPoint) {
                                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                    type: "Point",
                                    coordinates: geom1.coordinates[0][i][ii]
                                }, {
                                    type: "LineString",
                                    coordinates: geom2.coordinates[0]
                                })) foundTouchingPoint = true;
                            }
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
                                type: "Point",
                                coordinates: geom1.coordinates[0][i][ii]
                            }, geom2, {
                                ignoreBoundary: true
                            })) return false;
                        }
                    }
                    return foundTouchingPoint;
                case "MultiPolygon":
                    var foundTouchingPoint = false;
                    for(var i = 0; i < geom1.coordinates[0].length; i++){
                        for(var ii = 0; ii < geom2.coordinates[0].length; ii++){
                            for(var iii = 0; iii < geom1.coordinates[0].length; iii++){
                                if (!foundTouchingPoint) {
                                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])({
                                        type: "Point",
                                        coordinates: geom1.coordinates[0][i][iii]
                                    }, {
                                        type: "LineString",
                                        coordinates: geom2.coordinates[0][ii]
                                    })) foundTouchingPoint = true;
                                }
                                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])({
                                    type: "Point",
                                    coordinates: geom1.coordinates[0][i][iii]
                                }, {
                                    type: "Polygon",
                                    coordinates: geom2.coordinates[0][ii]
                                }, {
                                    ignoreBoundary: true
                                })) return false;
                            }
                        }
                    }
                    return foundTouchingPoint;
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        default:
            throw new Error("feature1 " + type1 + " geometry not supported");
    }
}
function isPointOnLineEnd(point, line) {
    if (compareCoords(line.coordinates[0], point.coordinates)) return true;
    if (compareCoords(line.coordinates[line.coordinates.length - 1], point.coordinates)) return true;
    return false;
}
function compareCoords(pair1, pair2) {
    return pair1[0] === pair2[0] && pair1[1] === pair2[1];
}
var turf_boolean_touches_default = booleanTouches;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/boolean-valid/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "booleanValid": (()=>booleanValid),
    "default": (()=>turf_boolean_valid_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-intersect/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-on-line/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$disjoint$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-disjoint/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$crosses$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-crosses/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
;
;
function booleanValid(feature) {
    if (!feature.type) return false;
    const geom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGeom"])(feature);
    const type = geom.type;
    const coords = geom.coordinates;
    switch(type){
        case "Point":
            return coords.length > 1;
        case "MultiPoint":
            for(var i = 0; i < coords.length; i++){
                if (coords[i].length < 2) return false;
            }
            return true;
        case "LineString":
            if (coords.length < 2) return false;
            for(var i = 0; i < coords.length; i++){
                if (coords[i].length < 2) return false;
            }
            return true;
        case "MultiLineString":
            if (coords.length < 2) return false;
            for(var i = 0; i < coords.length; i++){
                if (coords[i].length < 2) return false;
            }
            return true;
        case "Polygon":
            for(var i = 0; i < geom.coordinates.length; i++){
                if (coords[i].length < 4) return false;
                if (!checkRingsClose(coords[i])) return false;
                if (checkRingsForSpikesPunctures(coords[i])) return false;
                if (i > 0) {
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineIntersect"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])([
                        coords[0]
                    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])([
                        coords[i]
                    ])).features.length > 1) return false;
                }
            }
            return true;
        case "MultiPolygon":
            for(var i = 0; i < geom.coordinates.length; i++){
                var poly = geom.coordinates[i];
                for(var ii = 0; ii < poly.length; ii++){
                    if (poly[ii].length < 4) return false;
                    if (!checkRingsClose(poly[ii])) return false;
                    if (checkRingsForSpikesPunctures(poly[ii])) return false;
                    if (ii === 0) {
                        if (!checkPolygonAgainstOthers(poly, geom.coordinates, i)) return false;
                    }
                    if (ii > 0) {
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineIntersect"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])([
                            poly[0]
                        ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])([
                            poly[ii]
                        ])).features.length > 1) return false;
                    }
                }
            }
            return true;
        default:
            return false;
    }
}
function checkRingsClose(geom) {
    return geom[0][0] === geom[geom.length - 1][0] && geom[0][1] === geom[geom.length - 1][1];
}
function checkRingsForSpikesPunctures(geom) {
    for(var i = 0; i < geom.length - 1; i++){
        var point = geom[i];
        for(var ii = i + 1; ii < geom.length - 2; ii++){
            var seg = [
                geom[ii],
                geom[ii + 1]
            ];
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(point, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineString"])(seg))) return true;
        }
    }
    return false;
}
function checkPolygonAgainstOthers(poly, geom, index) {
    var polyToCheck = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])(poly);
    for(var i = index + 1; i < geom.length; i++){
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$disjoint$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanDisjoint"])(polyToCheck, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])(geom[i]))) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$crosses$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanCrosses"])(polyToCheck, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineString"])(geom[i][0]))) return false;
        }
    }
    return true;
}
var turf_boolean_valid_default = booleanValid;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/boolean-within/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "booleanWithin": (()=>booleanWithin),
    "default": (()=>turf_boolean_within_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-on-line/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
function booleanWithin(feature1, feature2) {
    var geom1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGeom"])(feature1);
    var geom2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGeom"])(feature2);
    var type1 = geom1.type;
    var type2 = geom2.type;
    switch(type1){
        case "Point":
            switch(type2){
                case "MultiPoint":
                    return isPointInMultiPoint(geom1, geom2);
                case "LineString":
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(geom1, geom2, {
                        ignoreEndVertices: true
                    });
                case "Polygon":
                case "MultiPolygon":
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(geom1, geom2, {
                        ignoreBoundary: true
                    });
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "MultiPoint":
            switch(type2){
                case "MultiPoint":
                    return isMultiPointInMultiPoint(geom1, geom2);
                case "LineString":
                    return isMultiPointOnLine(geom1, geom2);
                case "Polygon":
                case "MultiPolygon":
                    return isMultiPointInPoly(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "LineString":
            switch(type2){
                case "LineString":
                    return isLineOnLine(geom1, geom2);
                case "Polygon":
                case "MultiPolygon":
                    return isLineInPoly(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "Polygon":
            switch(type2){
                case "Polygon":
                case "MultiPolygon":
                    return isPolyInPoly(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        default:
            throw new Error("feature1 " + type1 + " geometry not supported");
    }
}
function isPointInMultiPoint(point, multiPoint) {
    var i;
    var output = false;
    for(i = 0; i < multiPoint.coordinates.length; i++){
        if (compareCoords(multiPoint.coordinates[i], point.coordinates)) {
            output = true;
            break;
        }
    }
    return output;
}
function isMultiPointInMultiPoint(multiPoint1, multiPoint2) {
    for(var i = 0; i < multiPoint1.coordinates.length; i++){
        var anyMatch = false;
        for(var i2 = 0; i2 < multiPoint2.coordinates.length; i2++){
            if (compareCoords(multiPoint1.coordinates[i], multiPoint2.coordinates[i2])) {
                anyMatch = true;
            }
        }
        if (!anyMatch) {
            return false;
        }
    }
    return true;
}
function isMultiPointOnLine(multiPoint, lineString) {
    var foundInsidePoint = false;
    for(var i = 0; i < multiPoint.coordinates.length; i++){
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(multiPoint.coordinates[i], lineString)) {
            return false;
        }
        if (!foundInsidePoint) {
            foundInsidePoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(multiPoint.coordinates[i], lineString, {
                ignoreEndVertices: true
            });
        }
    }
    return foundInsidePoint;
}
function isMultiPointInPoly(multiPoint, polygon) {
    var output = true;
    var oneInside = false;
    var isInside = false;
    for(var i = 0; i < multiPoint.coordinates.length; i++){
        isInside = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(multiPoint.coordinates[i], polygon);
        if (!isInside) {
            output = false;
            break;
        }
        if ("TURBOPACK compile-time truthy", 1) {
            isInside = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(multiPoint.coordinates[i], polygon, {
                ignoreBoundary: true
            });
        }
    }
    return output && isInside;
}
function isLineOnLine(lineString1, lineString2) {
    for(var i = 0; i < lineString1.coordinates.length; i++){
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointOnLine"])(lineString1.coordinates[i], lineString2)) {
            return false;
        }
    }
    return true;
}
function isLineInPoly(linestring, polygon) {
    var polyBbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bbox"])(polygon);
    var lineBbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bbox"])(linestring);
    if (!doBBoxOverlap(polyBbox, lineBbox)) {
        return false;
    }
    var foundInsidePoint = false;
    for(var i = 0; i < linestring.coordinates.length; i++){
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(linestring.coordinates[i], polygon)) {
            return false;
        }
        if (!foundInsidePoint) {
            foundInsidePoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(linestring.coordinates[i], polygon, {
                ignoreBoundary: true
            });
        }
        if (!foundInsidePoint && i < linestring.coordinates.length - 1) {
            var midpoint = getMidpoint(linestring.coordinates[i], linestring.coordinates[i + 1]);
            foundInsidePoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(midpoint, polygon, {
                ignoreBoundary: true
            });
        }
    }
    return foundInsidePoint;
}
function isPolyInPoly(geometry1, geometry2) {
    var poly1Bbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bbox"])(geometry1);
    var poly2Bbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bbox"])(geometry2);
    if (!doBBoxOverlap(poly2Bbox, poly1Bbox)) {
        return false;
    }
    for(var i = 0; i < geometry1.coordinates[0].length; i++){
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(geometry1.coordinates[0][i], geometry2)) {
            return false;
        }
    }
    return true;
}
function doBBoxOverlap(bbox1, bbox2) {
    if (bbox1[0] > bbox2[0]) return false;
    if (bbox1[2] < bbox2[2]) return false;
    if (bbox1[1] > bbox2[1]) return false;
    if (bbox1[3] < bbox2[3]) return false;
    return true;
}
function compareCoords(pair1, pair2) {
    return pair1[0] === pair2[0] && pair1[1] === pair2[1];
}
function getMidpoint(pair1, pair2) {
    return [
        (pair1[0] + pair2[0]) / 2,
        (pair1[1] + pair2[1]) / 2
    ];
}
var turf_boolean_within_default = booleanWithin;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/d3-array/src/ascending.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}
}}),
"[project]/node_modules/d3-array/src/bisector.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/ascending.js [app-client] (ecmascript)");
;
function __TURBOPACK__default__export__(compare) {
    if (compare.length === 1) compare = ascendingComparator(compare);
    return {
        left: function(a, x, lo, hi) {
            if (lo == null) lo = 0;
            if (hi == null) hi = a.length;
            while(lo < hi){
                var mid = lo + hi >>> 1;
                if (compare(a[mid], x) < 0) lo = mid + 1;
                else hi = mid;
            }
            return lo;
        },
        right: function(a, x, lo, hi) {
            if (lo == null) lo = 0;
            if (hi == null) hi = a.length;
            while(lo < hi){
                var mid = lo + hi >>> 1;
                if (compare(a[mid], x) > 0) hi = mid;
                else lo = mid + 1;
            }
            return lo;
        }
    };
}
function ascendingComparator(f) {
    return function(d, x) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(f(d), x);
    };
}
}}),
"[project]/node_modules/d3-array/src/bisect.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "bisectLeft": (()=>bisectLeft),
    "bisectRight": (()=>bisectRight),
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/ascending.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/bisector.js [app-client] (ecmascript)");
;
;
var ascendingBisect = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
const __TURBOPACK__default__export__ = bisectRight;
}}),
"[project]/node_modules/d3-array/src/pairs.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__),
    "pair": (()=>pair)
});
function __TURBOPACK__default__export__(array, f) {
    if (f == null) f = pair;
    var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
    while(i < n)pairs[i] = f(p, p = array[++i]);
    return pairs;
}
function pair(a, b) {
    return [
        a,
        b
    ];
}
}}),
"[project]/node_modules/d3-array/src/cross.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$pairs$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/pairs.js [app-client] (ecmascript)");
;
function __TURBOPACK__default__export__(values0, values1, reduce) {
    var n0 = values0.length, n1 = values1.length, values = new Array(n0 * n1), i0, i1, i, value0;
    if (reduce == null) reduce = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$pairs$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pair"];
    for(i0 = i = 0; i0 < n0; ++i0){
        for(value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i){
            values[i] = reduce(value0, values1[i1]);
        }
    }
    return values;
}
}}),
"[project]/node_modules/d3-array/src/descending.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}
}}),
"[project]/node_modules/d3-array/src/number.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(x) {
    return x === null ? NaN : +x;
}
}}),
"[project]/node_modules/d3-array/src/variance.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/number.js [app-client] (ecmascript)");
;
function __TURBOPACK__default__export__(values, valueof) {
    var n = values.length, m = 0, i = -1, mean = 0, value, delta, sum = 0;
    if (valueof == null) {
        while(++i < n){
            if (!isNaN(value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(values[i]))) {
                delta = value - mean;
                mean += delta / ++m;
                sum += delta * (value - mean);
            }
        }
    } else {
        while(++i < n){
            if (!isNaN(value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(valueof(values[i], i, values)))) {
                delta = value - mean;
                mean += delta / ++m;
                sum += delta * (value - mean);
            }
        }
    }
    if (m > 1) return sum / (m - 1);
}
}}),
"[project]/node_modules/d3-array/src/deviation.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$variance$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/variance.js [app-client] (ecmascript)");
;
function __TURBOPACK__default__export__(array, f) {
    var v = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$variance$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(array, f);
    return v ? Math.sqrt(v) : v;
}
}}),
"[project]/node_modules/d3-array/src/extent.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(values, valueof) {
    var n = values.length, i = -1, value, min, max;
    if (valueof == null) {
        while(++i < n){
            if ((value = values[i]) != null && value >= value) {
                min = max = value;
                while(++i < n){
                    if ((value = values[i]) != null) {
                        if (min > value) min = value;
                        if (max < value) max = value;
                    }
                }
            }
        }
    } else {
        while(++i < n){
            if ((value = valueof(values[i], i, values)) != null && value >= value) {
                min = max = value;
                while(++i < n){
                    if ((value = valueof(values[i], i, values)) != null) {
                        if (min > value) min = value;
                        if (max < value) max = value;
                    }
                }
            }
        }
    }
    return [
        min,
        max
    ];
}
}}),
"[project]/node_modules/d3-array/src/array.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "map": (()=>map),
    "slice": (()=>slice)
});
var array = Array.prototype;
var slice = array.slice;
var map = array.map;
}}),
"[project]/node_modules/d3-array/src/constant.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(x) {
    return function() {
        return x;
    };
}
}}),
"[project]/node_modules/d3-array/src/identity.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(x) {
    return x;
}
}}),
"[project]/node_modules/d3-array/src/range.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(start, stop, step) {
    start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
    var i = -1, n = Math.max(0, Math.ceil((stop - start) / step)) | 0, range = new Array(n);
    while(++i < n){
        range[i] = start + i * step;
    }
    return range;
}
}}),
"[project]/node_modules/d3-array/src/ticks.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__),
    "tickIncrement": (()=>tickIncrement),
    "tickStep": (()=>tickStep)
});
var e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
function __TURBOPACK__default__export__(start, stop, count) {
    var reverse, i = -1, n, ticks, step;
    stop = +stop, start = +start, count = +count;
    if (start === stop && count > 0) return [
        start
    ];
    if (reverse = stop < start) n = start, start = stop, stop = n;
    if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];
    if (step > 0) {
        start = Math.ceil(start / step);
        stop = Math.floor(stop / step);
        ticks = new Array(n = Math.ceil(stop - start + 1));
        while(++i < n)ticks[i] = (start + i) * step;
    } else {
        start = Math.floor(start * step);
        stop = Math.ceil(stop * step);
        ticks = new Array(n = Math.ceil(start - stop + 1));
        while(++i < n)ticks[i] = (start - i) / step;
    }
    if (reverse) ticks.reverse();
    return ticks;
}
function tickIncrement(start, stop, count) {
    var step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log(step) / Math.LN10), error = step / Math.pow(10, power);
    return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}
function tickStep(start, stop, count) {
    var step0 = Math.abs(stop - start) / Math.max(0, count), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;
    if (error >= e10) step1 *= 10;
    else if (error >= e5) step1 *= 5;
    else if (error >= e2) step1 *= 2;
    return stop < start ? -step1 : step1;
}
}}),
"[project]/node_modules/d3-array/src/threshold/sturges.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(values) {
    return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
}
}}),
"[project]/node_modules/d3-array/src/histogram.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/bisect.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/constant.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$extent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/extent.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$identity$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/identity.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$range$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/range.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ticks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/ticks.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$threshold$2f$sturges$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/threshold/sturges.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
function __TURBOPACK__default__export__() {
    var value = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$identity$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"], domain = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$extent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"], threshold = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$threshold$2f$sturges$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
    function histogram(data) {
        var i, n = data.length, x, values = new Array(n);
        for(i = 0; i < n; ++i){
            values[i] = value(data[i], i, data);
        }
        var xz = domain(values), x0 = xz[0], x1 = xz[1], tz = threshold(values, x0, x1);
        // Convert number of thresholds into uniform thresholds.
        if (!Array.isArray(tz)) {
            tz = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ticks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["tickStep"])(x0, x1, tz);
            tz = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$range$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive
        }
        // Remove any thresholds outside the domain.
        var m = tz.length;
        while(tz[0] <= x0)tz.shift(), --m;
        while(tz[m - 1] > x1)tz.pop(), --m;
        var bins = new Array(m + 1), bin;
        // Initialize bins.
        for(i = 0; i <= m; ++i){
            bin = bins[i] = [];
            bin.x0 = i > 0 ? tz[i - 1] : x0;
            bin.x1 = i < m ? tz[i] : x1;
        }
        // Assign data to bins by value, ignoring any outside the domain.
        for(i = 0; i < n; ++i){
            x = values[i];
            if (x0 <= x && x <= x1) {
                bins[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(tz, x, 0, m)].push(data[i]);
            }
        }
        return bins;
    }
    histogram.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(_), histogram) : value;
    };
    histogram.domain = function(_) {
        return arguments.length ? (domain = typeof _ === "function" ? _ : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])([
            _[0],
            _[1]
        ]), histogram) : domain;
    };
    histogram.thresholds = function(_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["slice"].call(_)) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(_), histogram) : threshold;
    };
    return histogram;
}
}}),
"[project]/node_modules/d3-array/src/quantile.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/number.js [app-client] (ecmascript)");
;
function __TURBOPACK__default__export__(values, p, valueof) {
    if (valueof == null) valueof = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
    if (!(n = values.length)) return;
    if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
    if (p >= 1) return +valueof(values[n - 1], n - 1, values);
    var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values[i0], i0, values), value1 = +valueof(values[i0 + 1], i0 + 1, values);
    return value0 + (value1 - value0) * (i - i0);
}
}}),
"[project]/node_modules/d3-array/src/threshold/freedmanDiaconis.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/ascending.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/number.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$quantile$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/quantile.js [app-client] (ecmascript)");
;
;
;
;
function __TURBOPACK__default__export__(values, min, max) {
    values = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["map"].call(values, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]).sort(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    return Math.ceil((max - min) / (2 * ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$quantile$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(values, 0.75) - (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$quantile$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(values, 0.25)) * Math.pow(values.length, -1 / 3)));
}
}}),
"[project]/node_modules/d3-array/src/threshold/scott.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$deviation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/deviation.js [app-client] (ecmascript)");
;
function __TURBOPACK__default__export__(values, min, max) {
    return Math.ceil((max - min) / (3.5 * (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$deviation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(values) * Math.pow(values.length, -1 / 3)));
}
}}),
"[project]/node_modules/d3-array/src/max.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(values, valueof) {
    var n = values.length, i = -1, value, max;
    if (valueof == null) {
        while(++i < n){
            if ((value = values[i]) != null && value >= value) {
                max = value;
                while(++i < n){
                    if ((value = values[i]) != null && value > max) {
                        max = value;
                    }
                }
            }
        }
    } else {
        while(++i < n){
            if ((value = valueof(values[i], i, values)) != null && value >= value) {
                max = value;
                while(++i < n){
                    if ((value = valueof(values[i], i, values)) != null && value > max) {
                        max = value;
                    }
                }
            }
        }
    }
    return max;
}
}}),
"[project]/node_modules/d3-array/src/mean.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/number.js [app-client] (ecmascript)");
;
function __TURBOPACK__default__export__(values, valueof) {
    var n = values.length, m = n, i = -1, value, sum = 0;
    if (valueof == null) {
        while(++i < n){
            if (!isNaN(value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(values[i]))) sum += value;
            else --m;
        }
    } else {
        while(++i < n){
            if (!isNaN(value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(valueof(values[i], i, values)))) sum += value;
            else --m;
        }
    }
    if (m) return sum / m;
}
}}),
"[project]/node_modules/d3-array/src/median.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/ascending.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/number.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$quantile$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/quantile.js [app-client] (ecmascript)");
;
;
;
function __TURBOPACK__default__export__(values, valueof) {
    var n = values.length, i = -1, value, numbers = [];
    if (valueof == null) {
        while(++i < n){
            if (!isNaN(value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(values[i]))) {
                numbers.push(value);
            }
        }
    } else {
        while(++i < n){
            if (!isNaN(value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(valueof(values[i], i, values)))) {
                numbers.push(value);
            }
        }
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$quantile$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(numbers.sort(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]), 0.5);
}
}}),
"[project]/node_modules/d3-array/src/merge.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(arrays) {
    var n = arrays.length, m, i = -1, j = 0, merged, array;
    while(++i < n)j += arrays[i].length;
    merged = new Array(j);
    while(--n >= 0){
        array = arrays[n];
        m = array.length;
        while(--m >= 0){
            merged[--j] = array[m];
        }
    }
    return merged;
}
}}),
"[project]/node_modules/d3-array/src/min.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(values, valueof) {
    var n = values.length, i = -1, value, min;
    if (valueof == null) {
        while(++i < n){
            if ((value = values[i]) != null && value >= value) {
                min = value;
                while(++i < n){
                    if ((value = values[i]) != null && min > value) {
                        min = value;
                    }
                }
            }
        }
    } else {
        while(++i < n){
            if ((value = valueof(values[i], i, values)) != null && value >= value) {
                min = value;
                while(++i < n){
                    if ((value = valueof(values[i], i, values)) != null && min > value) {
                        min = value;
                    }
                }
            }
        }
    }
    return min;
}
}}),
"[project]/node_modules/d3-array/src/permute.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(array, indexes) {
    var i = indexes.length, permutes = new Array(i);
    while(i--)permutes[i] = array[indexes[i]];
    return permutes;
}
}}),
"[project]/node_modules/d3-array/src/scan.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/ascending.js [app-client] (ecmascript)");
;
function __TURBOPACK__default__export__(values, compare) {
    if (!(n = values.length)) return;
    var n, i = 0, j = 0, xi, xj = values[j];
    if (compare == null) compare = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
    while(++i < n){
        if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
            xj = xi, j = i;
        }
    }
    if (compare(xj, xj) === 0) return j;
}
}}),
"[project]/node_modules/d3-array/src/shuffle.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(array, i0, i1) {
    var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0), t, i;
    while(m){
        i = Math.random() * m-- | 0;
        t = array[m + i0];
        array[m + i0] = array[i + i0];
        array[i + i0] = t;
    }
    return array;
}
}}),
"[project]/node_modules/d3-array/src/sum.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(values, valueof) {
    var n = values.length, i = -1, value, sum = 0;
    if (valueof == null) {
        while(++i < n){
            if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
        }
    } else {
        while(++i < n){
            if (value = +valueof(values[i], i, values)) sum += value;
        }
    }
    return sum;
}
}}),
"[project]/node_modules/d3-array/src/transpose.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/min.js [app-client] (ecmascript)");
;
function __TURBOPACK__default__export__(matrix) {
    if (!(n = matrix.length)) return [];
    for(var i = -1, m = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(matrix, length), transpose = new Array(m); ++i < m;){
        for(var j = -1, n, row = transpose[i] = new Array(n); ++j < n;){
            row[j] = matrix[j][i];
        }
    }
    return transpose;
}
function length(d) {
    return d.length;
}
}}),
"[project]/node_modules/d3-array/src/zip.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$transpose$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/transpose.js [app-client] (ecmascript)");
;
function __TURBOPACK__default__export__() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$transpose$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(arguments);
}
}}),
"[project]/node_modules/d3-array/src/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({});
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
}}),
"[project]/node_modules/d3-array/src/index.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/bisect.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ascending$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/ascending.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$bisector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/bisector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$cross$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/cross.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$descending$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/descending.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$deviation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/deviation.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$extent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/extent.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$histogram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/histogram.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$threshold$2f$freedmanDiaconis$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/threshold/freedmanDiaconis.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$threshold$2f$scott$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/threshold/scott.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$threshold$2f$sturges$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/threshold/sturges.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/max.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$mean$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/mean.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$median$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/median.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/merge.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/min.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$pairs$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/pairs.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$permute$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/permute.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$quantile$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/quantile.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$range$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/range.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$scan$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/scan.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$shuffle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/shuffle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$sum$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/sum.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$ticks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/ticks.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$transpose$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/transpose.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$variance$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/variance.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$zip$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/zip.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/d3-array/src/index.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/d3-array/src/merge.js [app-client] (ecmascript) <export default as merge>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "merge": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/merge.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/d3-array/src/range.js [app-client] (ecmascript) <export default as range>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "range": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$range$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$array$2f$src$2f$range$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-array/src/range.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/@turf/center/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "center": (()=>center),
    "default": (()=>turf_center_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
;
function center(geojson, options = {}) {
    const ext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bbox"])(geojson);
    const x = (ext[0] + ext[2]) / 2;
    const y = (ext[1] + ext[3]) / 2;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])([
        x,
        y
    ], options.properties, options);
}
var turf_center_default = center;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/buffer/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.js
__turbopack_esm__({
    "buffer": (()=>buffer),
    "default": (()=>turf_buffer_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$jsts$2f$dist$2f$jsts$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/jsts/dist/jsts.min.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$geo$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/d3-geo/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/center/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$geo$2f$src$2f$projection$2f$azimuthalEquidistant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__geoAzimuthalEquidistant$3e$__ = __turbopack_import__("[project]/node_modules/d3-geo/src/projection/azimuthalEquidistant.js [app-client] (ecmascript) <export default as geoAzimuthalEquidistant>");
;
;
;
;
;
var { BufferOp, GeoJSONReader, GeoJSONWriter } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$jsts$2f$dist$2f$jsts$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
function buffer(geojson, radius, options) {
    options = options || {};
    var units = options.units || "kilometers";
    var steps = options.steps || 8;
    if (!geojson) throw new Error("geojson is required");
    if (typeof options !== "object") throw new Error("options must be an object");
    if (typeof steps !== "number") throw new Error("steps must be an number");
    if (radius === void 0) throw new Error("radius is required");
    if (steps <= 0) throw new Error("steps must be greater than 0");
    var results = [];
    switch(geojson.type){
        case "GeometryCollection":
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["geomEach"])(geojson, function(geometry) {
                var buffered = bufferFeature(geometry, radius, units, steps);
                if (buffered) results.push(buffered);
            });
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(results);
        case "FeatureCollection":
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"])(geojson, function(feature2) {
                var multiBuffered = bufferFeature(feature2, radius, units, steps);
                if (multiBuffered) {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"])(multiBuffered, function(buffered) {
                        if (buffered) results.push(buffered);
                    });
                }
            });
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(results);
    }
    return bufferFeature(geojson, radius, units, steps);
}
function bufferFeature(geojson, radius, units, steps) {
    var properties = geojson.properties || {};
    var geometry = geojson.type === "Feature" ? geojson.geometry : geojson;
    if (geometry.type === "GeometryCollection") {
        var results = [];
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["geomEach"])(geojson, function(geometry2) {
            var buffered2 = bufferFeature(geometry2, radius, units, steps);
            if (buffered2) results.push(buffered2);
        });
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(results);
    }
    var projection = defineProjection(geometry);
    var projected = {
        type: geometry.type,
        coordinates: projectCoords(geometry.coordinates, projection)
    };
    var reader = new GeoJSONReader();
    var geom = reader.read(projected);
    var distance = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["radiansToLength"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lengthToRadians"])(radius, units), "meters");
    var buffered = BufferOp.bufferOp(geom, distance, steps);
    var writer = new GeoJSONWriter();
    buffered = writer.write(buffered);
    if (coordsIsNaN(buffered.coordinates)) return void 0;
    var result = {
        type: buffered.type,
        coordinates: unprojectCoords(buffered.coordinates, projection)
    };
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["feature"])(result, properties);
}
function coordsIsNaN(coords) {
    if (Array.isArray(coords[0])) return coordsIsNaN(coords[0]);
    return isNaN(coords[0]);
}
function projectCoords(coords, proj) {
    if (typeof coords[0] !== "object") return proj(coords);
    return coords.map(function(coord) {
        return projectCoords(coord, proj);
    });
}
function unprojectCoords(coords, proj) {
    if (typeof coords[0] !== "object") return proj.invert(coords);
    return coords.map(function(coord) {
        return unprojectCoords(coord, proj);
    });
}
function defineProjection(geojson) {
    var coords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["center"])(geojson).geometry.coordinates;
    var rotation = [
        -coords[0],
        -coords[1]
    ];
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$geo$2f$src$2f$projection$2f$azimuthalEquidistant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__geoAzimuthalEquidistant$3e$__["geoAzimuthalEquidistant"])().rotate(rotation).scale(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["earthRadius"]);
}
var turf_buffer_default = buffer;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/center-mean/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "centerMean": (()=>centerMean),
    "default": (()=>turf_center_mean_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
;
function centerMean(geojson, options = {}) {
    let sumXs = 0;
    let sumYs = 0;
    let sumNs = 0;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["geomEach"])(geojson, function(geom, featureIndex, properties) {
        let weight = options.weight ? properties == null ? void 0 : properties[options.weight] : void 0;
        weight = weight === void 0 || weight === null ? 1 : weight;
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(weight)) throw new Error("weight value must be a number for feature index " + featureIndex);
        weight = Number(weight);
        if (weight > 0) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coordEach"])(geom, function(coord) {
                sumXs += coord[0] * weight;
                sumYs += coord[1] * weight;
                sumNs += weight;
            });
        }
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])([
        sumXs / sumNs,
        sumYs / sumNs
    ], options.properties, options);
}
var turf_center_mean_default = centerMean;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/centroid/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "centroid": (()=>centroid),
    "default": (()=>turf_centroid_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
;
function centroid(geojson, options = {}) {
    let xSum = 0;
    let ySum = 0;
    let len = 0;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coordEach"])(geojson, function(coord) {
        xSum += coord[0];
        ySum += coord[1];
        len++;
    }, true);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])([
        xSum / len,
        ySum / len
    ], options.properties);
}
var turf_centroid_default = centroid;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/center-median/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "centerMedian": (()=>centerMedian),
    "default": (()=>turf_center_median_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2d$mean$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/center-mean/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/centroid/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
;
function centerMedian(features, options = {}) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    var counter = options.counter || 10;
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(counter)) throw new Error("counter must be a number");
    var weightTerm = options.weight;
    var meanCenter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2d$mean$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["centerMean"])(features, {
        weight: options.weight
    });
    var centroids = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])([]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"])(features, function(feature) {
        var _a;
        centroids.features.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["centroid"])(feature, {
            properties: {
                weight: (_a = feature.properties) == null ? void 0 : _a[weightTerm]
            }
        }));
    });
    const properties = {
        tolerance: options.tolerance,
        medianCandidates: []
    };
    return findMedian(meanCenter.geometry.coordinates, [
        0,
        0
    ], centroids, properties, counter);
}
function findMedian(candidateMedian, previousCandidate, centroids, properties, counter) {
    var tolerance = properties.tolerance || 1e-3;
    var candidateXsum = 0;
    var candidateYsum = 0;
    var kSum = 0;
    var centroidCount = 0;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"])(centroids, function(theCentroid) {
        var _a;
        var weightValue = (_a = theCentroid.properties) == null ? void 0 : _a.weight;
        var weight = weightValue === void 0 || weightValue === null ? 1 : weightValue;
        weight = Number(weight);
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(weight)) throw new Error("weight value must be a number");
        if (weight > 0) {
            centroidCount += 1;
            var distanceFromCandidate = weight * (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(theCentroid, candidateMedian);
            if (distanceFromCandidate === 0) distanceFromCandidate = 1;
            var k = weight / distanceFromCandidate;
            candidateXsum += theCentroid.geometry.coordinates[0] * k;
            candidateYsum += theCentroid.geometry.coordinates[1] * k;
            kSum += k;
        }
    });
    if (centroidCount < 1) throw new Error("no features to measure");
    var candidateX = candidateXsum / kSum;
    var candidateY = candidateYsum / kSum;
    if (centroidCount === 1 || counter === 0 || Math.abs(candidateX - previousCandidate[0]) < tolerance && Math.abs(candidateY - previousCandidate[1]) < tolerance) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])([
            candidateX,
            candidateY
        ], {
            medianCandidates: properties.medianCandidates
        });
    } else {
        properties.medianCandidates.push([
            candidateX,
            candidateY
        ]);
        return findMedian([
            candidateX,
            candidateY
        ], candidateMedian, centroids, properties, counter - 1);
    }
}
var turf_center_median_default = centerMedian;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/concaveman/node_modules/tinyqueue/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>TinyQueue)
});
class TinyQueue {
    constructor(data = [], compare = defaultCompare){
        this.data = data;
        this.length = this.data.length;
        this.compare = compare;
        if (this.length > 0) {
            for(let i = (this.length >> 1) - 1; i >= 0; i--)this._down(i);
        }
    }
    push(item) {
        this.data.push(item);
        this.length++;
        this._up(this.length - 1);
    }
    pop() {
        if (this.length === 0) return undefined;
        const top = this.data[0];
        const bottom = this.data.pop();
        this.length--;
        if (this.length > 0) {
            this.data[0] = bottom;
            this._down(0);
        }
        return top;
    }
    peek() {
        return this.data[0];
    }
    _up(pos) {
        const { data, compare } = this;
        const item = data[pos];
        while(pos > 0){
            const parent = pos - 1 >> 1;
            const current = data[parent];
            if (compare(item, current) >= 0) break;
            data[pos] = current;
            pos = parent;
        }
        data[pos] = item;
    }
    _down(pos) {
        const { data, compare } = this;
        const halfLength = this.length >> 1;
        const item = data[pos];
        while(pos < halfLength){
            let left = (pos << 1) + 1;
            let best = data[left];
            const right = left + 1;
            if (right < this.length && compare(data[right], best) < 0) {
                left = right;
                best = data[right];
            }
            if (compare(best, item) >= 0) break;
            data[pos] = best;
            pos = left;
        }
        data[pos] = item;
    }
}
function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}
}}),
"[project]/node_modules/point-in-polygon/flat.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
module.exports = function pointInPolygonFlat(point, vs, start, end) {
    var x = point[0], y = point[1];
    var inside = false;
    if (start === undefined) start = 0;
    if (end === undefined) end = vs.length;
    var len = (end - start) / 2;
    for(var i = 0, j = len - 1; i < len; j = i++){
        var xi = vs[start + i * 2 + 0], yi = vs[start + i * 2 + 1];
        var xj = vs[start + j * 2 + 0], yj = vs[start + j * 2 + 1];
        var intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
        if (intersect) inside = !inside;
    }
    return inside;
};
}}),
"[project]/node_modules/point-in-polygon/nested.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
// ray-casting algorithm based on
// https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html
module.exports = function pointInPolygonNested(point, vs, start, end) {
    var x = point[0], y = point[1];
    var inside = false;
    if (start === undefined) start = 0;
    if (end === undefined) end = vs.length;
    var len = end - start;
    for(var i = 0, j = len - 1; i < len; j = i++){
        var xi = vs[i + start][0], yi = vs[i + start][1];
        var xj = vs[j + start][0], yj = vs[j + start][1];
        var intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
        if (intersect) inside = !inside;
    }
    return inside;
};
}}),
"[project]/node_modules/point-in-polygon/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var pointInPolygonFlat = __turbopack_require__("[project]/node_modules/point-in-polygon/flat.js [app-client] (ecmascript)");
var pointInPolygonNested = __turbopack_require__("[project]/node_modules/point-in-polygon/nested.js [app-client] (ecmascript)");
module.exports = function pointInPolygon(point, vs, start, end) {
    if (vs.length > 0 && Array.isArray(vs[0])) {
        return pointInPolygonNested(point, vs, start, end);
    } else {
        return pointInPolygonFlat(point, vs, start, end);
    }
};
module.exports.nested = pointInPolygonNested;
module.exports.flat = pointInPolygonFlat;
}}),
"[project]/node_modules/concaveman/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
var RBush = __turbopack_require__("[project]/node_modules/rbush/rbush.min.js [app-client] (ecmascript)");
var Queue = __turbopack_require__("[project]/node_modules/concaveman/node_modules/tinyqueue/index.js [app-client] (ecmascript)");
var pointInPolygon = __turbopack_require__("[project]/node_modules/point-in-polygon/index.js [app-client] (ecmascript)");
var orient = __turbopack_require__("[project]/node_modules/robust-predicates/umd/orient2d.min.js [app-client] (ecmascript)").orient2d;
// Fix for require issue in webpack https://github.com/mapbox/concaveman/issues/18
if (Queue.default) {
    Queue = Queue.default;
}
module.exports = concaveman;
module.exports.default = concaveman;
function concaveman(points, concavity, lengthThreshold) {
    // a relative measure of concavity; higher value means simpler hull
    concavity = Math.max(0, concavity === undefined ? 2 : concavity);
    // when a segment goes below this length threshold, it won't be drilled down further
    lengthThreshold = lengthThreshold || 0;
    // start with a convex hull of the points
    var hull = fastConvexHull(points);
    // index the points with an R-tree
    var tree = new RBush(16);
    tree.toBBox = function(a) {
        return {
            minX: a[0],
            minY: a[1],
            maxX: a[0],
            maxY: a[1]
        };
    };
    tree.compareMinX = function(a, b) {
        return a[0] - b[0];
    };
    tree.compareMinY = function(a, b) {
        return a[1] - b[1];
    };
    tree.load(points);
    // turn the convex hull into a linked list and populate the initial edge queue with the nodes
    var queue = [];
    for(var i = 0, last; i < hull.length; i++){
        var p = hull[i];
        tree.remove(p);
        last = insertNode(p, last);
        queue.push(last);
    }
    // index the segments with an R-tree (for intersection checks)
    var segTree = new RBush(16);
    for(i = 0; i < queue.length; i++)segTree.insert(updateBBox(queue[i]));
    var sqConcavity = concavity * concavity;
    var sqLenThreshold = lengthThreshold * lengthThreshold;
    // process edges one by one
    while(queue.length){
        var node = queue.shift();
        var a = node.p;
        var b = node.next.p;
        // skip the edge if it's already short enough
        var sqLen = getSqDist(a, b);
        if (sqLen < sqLenThreshold) continue;
        var maxSqLen = sqLen / sqConcavity;
        // find the best connection point for the current edge to flex inward to
        p = findCandidate(tree, node.prev.p, a, b, node.next.next.p, maxSqLen, segTree);
        // if we found a connection and it satisfies our concavity measure
        if (p && Math.min(getSqDist(p, a), getSqDist(p, b)) <= maxSqLen) {
            // connect the edge endpoints through this point and add 2 new edges to the queue
            queue.push(node);
            queue.push(insertNode(p, node));
            // update point and segment indexes
            tree.remove(p);
            segTree.remove(node);
            segTree.insert(updateBBox(node));
            segTree.insert(updateBBox(node.next));
        }
    }
    // convert the resulting hull linked list to an array of points
    node = last;
    var concave = [];
    do {
        concave.push(node.p);
        node = node.next;
    }while (node !== last)
    concave.push(node.p);
    return concave;
}
function findCandidate(tree, a, b, c, d, maxDist, segTree) {
    var queue = new Queue([], compareDist);
    var node = tree.data;
    // search through the point R-tree with a depth-first search using a priority queue
    // in the order of distance to the edge (b, c)
    while(node){
        for(var i = 0; i < node.children.length; i++){
            var child = node.children[i];
            var dist = node.leaf ? sqSegDist(child, b, c) : sqSegBoxDist(b, c, child);
            if (dist > maxDist) continue; // skip the node if it's farther than we ever need
            queue.push({
                node: child,
                dist: dist
            });
        }
        while(queue.length && !queue.peek().node.children){
            var item = queue.pop();
            var p = item.node;
            // skip all points that are as close to adjacent edges (a,b) and (c,d),
            // and points that would introduce self-intersections when connected
            var d0 = sqSegDist(p, a, b);
            var d1 = sqSegDist(p, c, d);
            if (item.dist < d0 && item.dist < d1 && noIntersections(b, p, segTree) && noIntersections(c, p, segTree)) return p;
        }
        node = queue.pop();
        if (node) node = node.node;
    }
    return null;
}
function compareDist(a, b) {
    return a.dist - b.dist;
}
// square distance from a segment bounding box to the given one
function sqSegBoxDist(a, b, bbox) {
    if (inside(a, bbox) || inside(b, bbox)) return 0;
    var d1 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.minY, bbox.maxX, bbox.minY);
    if (d1 === 0) return 0;
    var d2 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.minY, bbox.minX, bbox.maxY);
    if (d2 === 0) return 0;
    var d3 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.maxX, bbox.minY, bbox.maxX, bbox.maxY);
    if (d3 === 0) return 0;
    var d4 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.maxY, bbox.maxX, bbox.maxY);
    if (d4 === 0) return 0;
    return Math.min(d1, d2, d3, d4);
}
function inside(a, bbox) {
    return a[0] >= bbox.minX && a[0] <= bbox.maxX && a[1] >= bbox.minY && a[1] <= bbox.maxY;
}
// check if the edge (a,b) doesn't intersect any other edges
function noIntersections(a, b, segTree) {
    var minX = Math.min(a[0], b[0]);
    var minY = Math.min(a[1], b[1]);
    var maxX = Math.max(a[0], b[0]);
    var maxY = Math.max(a[1], b[1]);
    var edges = segTree.search({
        minX: minX,
        minY: minY,
        maxX: maxX,
        maxY: maxY
    });
    for(var i = 0; i < edges.length; i++){
        if (intersects(edges[i].p, edges[i].next.p, a, b)) return false;
    }
    return true;
}
function cross(p1, p2, p3) {
    return orient(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
}
// check if the edges (p1,q1) and (p2,q2) intersect
function intersects(p1, q1, p2, q2) {
    return p1 !== q2 && q1 !== p2 && cross(p1, q1, p2) > 0 !== cross(p1, q1, q2) > 0 && cross(p2, q2, p1) > 0 !== cross(p2, q2, q1) > 0;
}
// update the bounding box of a node's edge
function updateBBox(node) {
    var p1 = node.p;
    var p2 = node.next.p;
    node.minX = Math.min(p1[0], p2[0]);
    node.minY = Math.min(p1[1], p2[1]);
    node.maxX = Math.max(p1[0], p2[0]);
    node.maxY = Math.max(p1[1], p2[1]);
    return node;
}
// speed up convex hull by filtering out points inside quadrilateral formed by 4 extreme points
function fastConvexHull(points) {
    var left = points[0];
    var top = points[0];
    var right = points[0];
    var bottom = points[0];
    // find the leftmost, rightmost, topmost and bottommost points
    for(var i = 0; i < points.length; i++){
        var p = points[i];
        if (p[0] < left[0]) left = p;
        if (p[0] > right[0]) right = p;
        if (p[1] < top[1]) top = p;
        if (p[1] > bottom[1]) bottom = p;
    }
    // filter out points that are inside the resulting quadrilateral
    var cull = [
        left,
        top,
        right,
        bottom
    ];
    var filtered = cull.slice();
    for(i = 0; i < points.length; i++){
        if (!pointInPolygon(points[i], cull)) filtered.push(points[i]);
    }
    // get convex hull around the filtered points
    return convexHull(filtered);
}
// create a new node in a doubly linked list
function insertNode(p, prev) {
    var node = {
        p: p,
        prev: null,
        next: null,
        minX: 0,
        minY: 0,
        maxX: 0,
        maxY: 0
    };
    if (!prev) {
        node.prev = node;
        node.next = node;
    } else {
        node.next = prev.next;
        node.prev = prev;
        prev.next.prev = node;
        prev.next = node;
    }
    return node;
}
// square distance between 2 points
function getSqDist(p1, p2) {
    var dx = p1[0] - p2[0], dy = p1[1] - p2[1];
    return dx * dx + dy * dy;
}
// square distance from a point to a segment
function sqSegDist(p, p1, p2) {
    var x = p1[0], y = p1[1], dx = p2[0] - x, dy = p2[1] - y;
    if (dx !== 0 || dy !== 0) {
        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);
        if (t > 1) {
            x = p2[0];
            y = p2[1];
        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }
    dx = p[0] - x;
    dy = p[1] - y;
    return dx * dx + dy * dy;
}
// segment to segment distance, ported from http://geomalgorithms.com/a07-_distance.html by Dan Sunday
function sqSegSegDist(x0, y0, x1, y1, x2, y2, x3, y3) {
    var ux = x1 - x0;
    var uy = y1 - y0;
    var vx = x3 - x2;
    var vy = y3 - y2;
    var wx = x0 - x2;
    var wy = y0 - y2;
    var a = ux * ux + uy * uy;
    var b = ux * vx + uy * vy;
    var c = vx * vx + vy * vy;
    var d = ux * wx + uy * wy;
    var e = vx * wx + vy * wy;
    var D = a * c - b * b;
    var sc, sN, tc, tN;
    var sD = D;
    var tD = D;
    if (D === 0) {
        sN = 0;
        sD = 1;
        tN = e;
        tD = c;
    } else {
        sN = b * e - c * d;
        tN = a * e - b * d;
        if (sN < 0) {
            sN = 0;
            tN = e;
            tD = c;
        } else if (sN > sD) {
            sN = sD;
            tN = e + b;
            tD = c;
        }
    }
    if (tN < 0.0) {
        tN = 0.0;
        if (-d < 0.0) sN = 0.0;
        else if (-d > a) sN = sD;
        else {
            sN = -d;
            sD = a;
        }
    } else if (tN > tD) {
        tN = tD;
        if (-d + b < 0.0) sN = 0;
        else if (-d + b > a) sN = sD;
        else {
            sN = -d + b;
            sD = a;
        }
    }
    sc = sN === 0 ? 0 : sN / sD;
    tc = tN === 0 ? 0 : tN / tD;
    var cx = (1 - sc) * x0 + sc * x1;
    var cy = (1 - sc) * y0 + sc * y1;
    var cx2 = (1 - tc) * x2 + tc * x3;
    var cy2 = (1 - tc) * y2 + tc * y3;
    var dx = cx2 - cx;
    var dy = cy2 - cy;
    return dx * dx + dy * dy;
}
function compareByX(a, b) {
    return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];
}
function convexHull(points) {
    points.sort(compareByX);
    var lower = [];
    for(var i = 0; i < points.length; i++){
        while(lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0){
            lower.pop();
        }
        lower.push(points[i]);
    }
    var upper = [];
    for(var ii = points.length - 1; ii >= 0; ii--){
        while(upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[ii]) <= 0){
            upper.pop();
        }
        upper.push(points[ii]);
    }
    upper.pop();
    lower.pop();
    return lower.concat(upper);
}
}}),
"[project]/node_modules/@turf/convex/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "convex": (()=>convex),
    "default": (()=>turf_convex_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$concaveman$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/concaveman/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
function convex(geojson, options = {}) {
    options.concavity = options.concavity || Infinity;
    const points = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coordEach"])(geojson, (coord)=>{
        points.push([
            coord[0],
            coord[1]
        ]);
    });
    if (!points.length) {
        return null;
    }
    const convexHull = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$concaveman$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(points, options.concavity);
    if (convexHull.length > 3) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])([
            convexHull
        ]);
    }
    return null;
}
var turf_convex_default = convex;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/center-of-mass/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "centerOfMass": (()=>centerOfMass),
    "default": (()=>turf_center_of_mass_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/centroid/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$convex$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/convex/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
;
function centerOfMass(geojson, options = {}) {
    switch((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getType"])(geojson)){
        case "Point":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(geojson), options.properties);
        case "Polygon":
            var coords = [];
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coordEach"])(geojson, function(coord) {
                coords.push(coord);
            });
            var centre = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["centroid"])(geojson, {
                properties: options.properties
            });
            var translation = centre.geometry.coordinates;
            var sx = 0;
            var sy = 0;
            var sArea = 0;
            var i, pi, pj, xi, xj, yi, yj, a;
            var neutralizedPoints = coords.map(function(point2) {
                return [
                    point2[0] - translation[0],
                    point2[1] - translation[1]
                ];
            });
            for(i = 0; i < coords.length - 1; i++){
                pi = neutralizedPoints[i];
                xi = pi[0];
                yi = pi[1];
                pj = neutralizedPoints[i + 1];
                xj = pj[0];
                yj = pj[1];
                a = xi * yj - xj * yi;
                sArea += a;
                sx += (xi + xj) * a;
                sy += (yi + yj) * a;
            }
            if (sArea === 0) {
                return centre;
            } else {
                var area = sArea * 0.5;
                var areaFactor = 1 / (6 * area);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])([
                    translation[0] + areaFactor * sx,
                    translation[1] + areaFactor * sy
                ], options.properties);
            }
        default:
            var hull = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$convex$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convex"])(geojson);
            if (hull) return centerOfMass(hull, {
                properties: options.properties
            });
            else return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["centroid"])(geojson, {
                properties: options.properties
            });
    }
}
var turf_center_of_mass_default = centerOfMass;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/circle/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "circle": (()=>circle),
    "default": (()=>turf_circle_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/destination/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
;
function circle(center, radius, options = {}) {
    const steps = options.steps || 64;
    const properties = options.properties ? options.properties : !Array.isArray(center) && center.type === "Feature" && center.properties ? center.properties : {};
    const coordinates = [];
    for(let i = 0; i < steps; i++){
        coordinates.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["destination"])(center, radius, i * -360 / steps, options).geometry.coordinates);
    }
    coordinates.push(coordinates[0]);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])([
        coordinates
    ], properties);
}
var turf_circle_default = circle;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/clusters/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "applyFilter": (()=>applyFilter),
    "clusterEach": (()=>clusterEach),
    "clusterReduce": (()=>clusterReduce),
    "createBins": (()=>createBins),
    "filterProperties": (()=>filterProperties),
    "getCluster": (()=>getCluster),
    "propertiesContainsFilter": (()=>propertiesContainsFilter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
;
function getCluster(geojson, filter) {
    if (!geojson) throw new Error("geojson is required");
    if (geojson.type !== "FeatureCollection") throw new Error("geojson must be a FeatureCollection");
    if (filter === void 0 || filter === null) throw new Error("filter is required");
    var features = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"])(geojson, function(feature) {
        if (applyFilter(feature.properties, filter)) features.push(feature);
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(features);
}
function clusterEach(geojson, property, callback) {
    if (!geojson) throw new Error("geojson is required");
    if (geojson.type !== "FeatureCollection") throw new Error("geojson must be a FeatureCollection");
    if (property === void 0 || property === null) throw new Error("property is required");
    var bins = createBins(geojson, property);
    var values = Object.keys(bins);
    for(var index = 0; index < values.length; index++){
        var value = values[index];
        var bin = bins[value];
        var features = [];
        for(var i = 0; i < bin.length; i++){
            features.push(geojson.features[bin[i]]);
        }
        callback((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(features), value, index);
    }
}
function clusterReduce(geojson, property, callback, initialValue) {
    var previousValue = initialValue;
    clusterEach(geojson, property, function(cluster, clusterValue, currentIndex) {
        if (currentIndex === 0 && initialValue === void 0) previousValue = cluster;
        else previousValue = callback(previousValue, cluster, clusterValue, currentIndex);
    });
    return previousValue;
}
function createBins(geojson, property) {
    var bins = {};
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"])(geojson, function(feature, i) {
        var properties = feature.properties || {};
        if (Object.prototype.hasOwnProperty.call(properties, String(property))) {
            var value = properties[property];
            if (Object.prototype.hasOwnProperty.call(bins, value)) bins[value].push(i);
            else bins[value] = [
                i
            ];
        }
    });
    return bins;
}
function applyFilter(properties, filter) {
    if (properties === void 0) return false;
    var filterType = typeof filter;
    if (filterType === "number" || filterType === "string") return Object.prototype.hasOwnProperty.call(properties, filter);
    else if (Array.isArray(filter)) {
        for(var i = 0; i < filter.length; i++){
            if (!applyFilter(properties, filter[i])) return false;
        }
        return true;
    } else {
        return propertiesContainsFilter(properties, filter);
    }
}
function propertiesContainsFilter(properties, filter) {
    var keys = Object.keys(filter);
    for(var i = 0; i < keys.length; i++){
        var key = keys[i];
        if (properties[key] !== filter[key]) return false;
    }
    return true;
}
function filterProperties(properties, keys) {
    if (!keys) return {};
    if (!keys.length) return {};
    var newProperties = {};
    for(var i = 0; i < keys.length; i++){
        var key = keys[i];
        if (Object.prototype.hasOwnProperty.call(properties, key)) newProperties[key] = properties[key];
    }
    return newProperties;
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/clone/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "clone": (()=>clone),
    "cloneProperties": (()=>cloneProperties),
    "default": (()=>turf_clone_default)
});
function clone(geojson) {
    if (!geojson) {
        throw new Error("geojson is required");
    }
    switch(geojson.type){
        case "Feature":
            return cloneFeature(geojson);
        case "FeatureCollection":
            return cloneFeatureCollection(geojson);
        case "Point":
        case "LineString":
        case "Polygon":
        case "MultiPoint":
        case "MultiLineString":
        case "MultiPolygon":
        case "GeometryCollection":
            return cloneGeometry(geojson);
        default:
            throw new Error("unknown GeoJSON type");
    }
}
function cloneFeature(geojson) {
    const cloned = {
        type: "Feature"
    };
    Object.keys(geojson).forEach((key)=>{
        switch(key){
            case "type":
            case "properties":
            case "geometry":
                return;
            default:
                cloned[key] = geojson[key];
        }
    });
    cloned.properties = cloneProperties(geojson.properties);
    if (geojson.geometry == null) {
        cloned.geometry = null;
    } else {
        cloned.geometry = cloneGeometry(geojson.geometry);
    }
    return cloned;
}
function cloneProperties(properties) {
    const cloned = {};
    if (!properties) {
        return cloned;
    }
    Object.keys(properties).forEach((key)=>{
        const value = properties[key];
        if (typeof value === "object") {
            if (value === null) {
                cloned[key] = null;
            } else if (Array.isArray(value)) {
                cloned[key] = value.map((item)=>{
                    return item;
                });
            } else {
                cloned[key] = cloneProperties(value);
            }
        } else {
            cloned[key] = value;
        }
    });
    return cloned;
}
function cloneFeatureCollection(geojson) {
    const cloned = {
        type: "FeatureCollection"
    };
    Object.keys(geojson).forEach((key)=>{
        switch(key){
            case "type":
            case "features":
                return;
            default:
                cloned[key] = geojson[key];
        }
    });
    cloned.features = geojson.features.map((feature)=>{
        return cloneFeature(feature);
    });
    return cloned;
}
function cloneGeometry(geometry) {
    const geom = {
        type: geometry.type
    };
    if (geometry.bbox) {
        geom.bbox = geometry.bbox;
    }
    if (geometry.type === "GeometryCollection") {
        geom.geometries = geometry.geometries.map((g)=>{
            return cloneGeometry(g);
        });
        return geom;
    }
    geom.coordinates = deepSlice(geometry.coordinates);
    return geom;
}
function deepSlice(coords) {
    const cloned = coords;
    if (typeof cloned[0] !== "object") {
        return cloned.slice();
    }
    return cloned.map((coord)=>{
        return deepSlice(coord);
    });
}
var turf_clone_default = clone;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/clusters-dbscan/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "clustersDbscan": (()=>clustersDbscan),
    "default": (()=>turf_clusters_dbscan_default)
});
// lib/rbush-export.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$rbush$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rbush/rbush.min.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
var rbush = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$rbush$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
// index.ts
function clustersDbscan(points, maxDistance, options = {}) {
    if (options.mutate !== true) points = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(points);
    const minPoints = options.minPoints || 3;
    const latDistanceInDegrees = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lengthToDegrees"])(maxDistance, options.units);
    var tree = new rbush(points.features.length);
    var visited = points.features.map((_)=>false);
    var assigned = points.features.map((_)=>false);
    var isnoise = points.features.map((_)=>false);
    var clusterIds = points.features.map((_)=>-1);
    tree.load(points.features.map((point, index)=>{
        var [x, y] = point.geometry.coordinates;
        return {
            minX: x,
            minY: y,
            maxX: x,
            maxY: y,
            index
        };
    }));
    const regionQuery = (index)=>{
        const point = points.features[index];
        const [x, y] = point.geometry.coordinates;
        const minY = Math.max(y - latDistanceInDegrees, -90);
        const maxY = Math.min(y + latDistanceInDegrees, 90);
        const lonDistanceInDegrees = function() {
            if (minY < 0 && maxY > 0) {
                return latDistanceInDegrees;
            }
            if (Math.abs(minY) < Math.abs(maxY)) {
                return latDistanceInDegrees / Math.cos((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])(maxY));
            } else {
                return latDistanceInDegrees / Math.cos((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])(minY));
            }
        }();
        const minX = Math.max(x - lonDistanceInDegrees, -360);
        const maxX = Math.min(x + lonDistanceInDegrees, 360);
        const bbox = {
            minX,
            minY,
            maxX,
            maxY
        };
        return tree.search(bbox).filter((neighbor)=>{
            const neighborIndex = neighbor.index;
            const neighborPoint = points.features[neighborIndex];
            const distanceInKm = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(point, neighborPoint, {
                units: "kilometers"
            });
            return distanceInKm <= maxDistance;
        });
    };
    const expandCluster = (clusteredId, neighbors)=>{
        for(var i = 0; i < neighbors.length; i++){
            var neighbor = neighbors[i];
            const neighborIndex = neighbor.index;
            if (!visited[neighborIndex]) {
                visited[neighborIndex] = true;
                const nextNeighbors = regionQuery(neighborIndex);
                if (nextNeighbors.length >= minPoints) {
                    neighbors.push(...nextNeighbors);
                }
            }
            if (!assigned[neighborIndex]) {
                assigned[neighborIndex] = true;
                clusterIds[neighborIndex] = clusteredId;
            }
        }
    };
    var nextClusteredId = 0;
    points.features.forEach((_, index)=>{
        if (visited[index]) return;
        const neighbors = regionQuery(index);
        if (neighbors.length >= minPoints) {
            const clusteredId = nextClusteredId;
            nextClusteredId++;
            visited[index] = true;
            expandCluster(clusteredId, neighbors);
        } else {
            isnoise[index] = true;
        }
    });
    points.features.forEach((_, index)=>{
        var clusterPoint = points.features[index];
        if (!clusterPoint.properties) {
            clusterPoint.properties = {};
        }
        if (clusterIds[index] >= 0) {
            clusterPoint.properties.dbscan = isnoise[index] ? "edge" : "core";
            clusterPoint.properties.cluster = clusterIds[index];
        } else {
            clusterPoint.properties.dbscan = "noise";
        }
    });
    return points;
}
var turf_clusters_dbscan_default = clustersDbscan;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/skmeans/dist/node/distance.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
module.exports = {
    /**
  * Euclidean distance
  */ eudist: function eudist(v1, v2, sqrt) {
        var len = v1.length;
        var sum = 0;
        for(var i = 0; i < len; i++){
            var d = (v1[i] || 0) - (v2[i] || 0);
            sum += d * d;
        }
        // Square root not really needed
        return sqrt ? Math.sqrt(sum) : sum;
    },
    mandist: function mandist(v1, v2, sqrt) {
        var len = v1.length;
        var sum = 0;
        for(var i = 0; i < len; i++){
            sum += Math.abs((v1[i] || 0) - (v2[i] || 0));
        }
        // Square root not really needed
        return sqrt ? Math.sqrt(sum) : sum;
    },
    /**
  * Unidimensional distance
  */ dist: function dist(v1, v2, sqrt) {
        var d = Math.abs(v1 - v2);
        return sqrt ? d : d * d;
    }
}; //# sourceMappingURL=distance.js.map
}}),
"[project]/node_modules/skmeans/dist/node/kinit.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
var Distance = __turbopack_require__("[project]/node_modules/skmeans/dist/node/distance.js [app-client] (ecmascript)"), eudist = Distance.eudist, dist = Distance.dist;
module.exports = {
    kmrand: function kmrand(data, k) {
        var map = {}, ks = [], t = k << 2;
        var len = data.length;
        var multi = data[0].length > 0;
        while(ks.length < k && t-- > 0){
            var d = data[Math.floor(Math.random() * len)];
            var key = multi ? d.join("_") : "" + d;
            if (!map[key]) {
                map[key] = true;
                ks.push(d);
            }
        }
        if (ks.length < k) throw new Error("Error initializating clusters");
        else return ks;
    },
    /**
  * K-means++ initial centroid selection
  */ kmpp: function kmpp(data, k) {
        var distance = data[0].length ? eudist : dist;
        var ks = [], len = data.length;
        var multi = data[0].length > 0;
        var map = {};
        // First random centroid
        var c = data[Math.floor(Math.random() * len)];
        var key = multi ? c.join("_") : "" + c;
        ks.push(c);
        map[key] = true;
        // Retrieve next centroids
        while(ks.length < k){
            // Min Distances between current centroids and data points
            var dists = [], lk = ks.length;
            var dsum = 0, prs = [];
            for(var i = 0; i < len; i++){
                var min = Infinity;
                for(var j = 0; j < lk; j++){
                    var _dist = distance(data[i], ks[j]);
                    if (_dist <= min) min = _dist;
                }
                dists[i] = min;
            }
            // Sum all min distances
            for(var _i = 0; _i < len; _i++){
                dsum += dists[_i];
            }
            // Probabilities and cummulative prob (cumsum)
            for(var _i2 = 0; _i2 < len; _i2++){
                prs[_i2] = {
                    i: _i2,
                    v: data[_i2],
                    pr: dists[_i2] / dsum,
                    cs: 0
                };
            }
            // Sort Probabilities
            prs.sort(function(a, b) {
                return a.pr - b.pr;
            });
            // Cummulative Probabilities
            prs[0].cs = prs[0].pr;
            for(var _i3 = 1; _i3 < len; _i3++){
                prs[_i3].cs = prs[_i3 - 1].cs + prs[_i3].pr;
            }
            // Randomize
            var rnd = Math.random();
            // Gets only the items whose cumsum >= rnd
            var idx = 0;
            while(idx < len - 1 && prs[idx++].cs < rnd){}
            ks.push(prs[idx - 1].v);
        /*
   let done = false;
   while(!done) {
   	// this is our new centroid
   	c = prs[idx-1].v
   	key = multi? c.join("_") : `${c}`;
   	if(!map[key]) {
   		map[key] = true;
   		ks.push(c);
   		done = true;
   	}
   	else {
   		idx++;
   	}
   }
   */ }
        return ks;
    }
}; //# sourceMappingURL=kinit.js.map
}}),
"[project]/node_modules/skmeans/dist/node/main.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
/*jshint esversion: 6 */ var Distance = __turbopack_require__("[project]/node_modules/skmeans/dist/node/distance.js [app-client] (ecmascript)"), ClusterInit = __turbopack_require__("[project]/node_modules/skmeans/dist/node/kinit.js [app-client] (ecmascript)"), eudist = Distance.eudist, mandist = Distance.mandist, dist = Distance.dist, kmrand = ClusterInit.kmrand, kmpp = ClusterInit.kmpp;
var MAX = 10000;
/**
 * Inits an array with values
 */ function init(len, val, v) {
    v = v || [];
    for(var i = 0; i < len; i++){
        v[i] = val;
    }
    return v;
}
function skmeans(data, k, initial, maxit) {
    var ks = [], old = [], idxs = [], dist = [];
    var conv = false, it = maxit || MAX;
    var len = data.length, vlen = data[0].length, multi = vlen > 0;
    var count = [];
    if (!initial) {
        var _idxs = {};
        while(ks.length < k){
            var idx = Math.floor(Math.random() * len);
            if (!_idxs[idx]) {
                _idxs[idx] = true;
                ks.push(data[idx]);
            }
        }
    } else if (initial == "kmrand") {
        ks = kmrand(data, k);
    } else if (initial == "kmpp") {
        ks = kmpp(data, k);
    } else {
        ks = initial;
    }
    do {
        // Reset k count
        init(k, 0, count);
        // For each value in data, find the nearest centroid
        for(var i = 0; i < len; i++){
            var min = Infinity, _idx = 0;
            for(var j = 0; j < k; j++){
                // Multidimensional or unidimensional
                var dist = multi ? eudist(data[i], ks[j]) : Math.abs(data[i] - ks[j]);
                if (dist <= min) {
                    min = dist;
                    _idx = j;
                }
            }
            idxs[i] = _idx; // Index of the selected centroid for that value
            count[_idx]++; // Number of values for this centroid
        }
        // Recalculate centroids
        var sum = [], old = [], dif = 0;
        for(var _j = 0; _j < k; _j++){
            // Multidimensional or unidimensional
            sum[_j] = multi ? init(vlen, 0, sum[_j]) : 0;
            old[_j] = ks[_j];
        }
        // If multidimensional
        if (multi) {
            for(var _j2 = 0; _j2 < k; _j2++){
                ks[_j2] = [];
            } // Sum values and count for each centroid
            for(var _i = 0; _i < len; _i++){
                var _idx2 = idxs[_i], // Centroid for that item
                vsum = sum[_idx2], // Sum values for this centroid
                vect = data[_i]; // Current vector
                // Accumulate value on the centroid for current vector
                for(var h = 0; h < vlen; h++){
                    vsum[h] += vect[h];
                }
            }
            // Calculate the average for each centroid
            conv = true;
            for(var _j3 = 0; _j3 < k; _j3++){
                var ksj = ks[_j3], // Current centroid
                sumj = sum[_j3], // Accumulated centroid values
                oldj = old[_j3], // Old centroid value
                cj = count[_j3]; // Number of elements for this centroid
                // New average
                for(var _h = 0; _h < vlen; _h++){
                    ksj[_h] = sumj[_h] / cj || 0; // New centroid
                }
                // Find if centroids have moved
                if (conv) {
                    for(var _h2 = 0; _h2 < vlen; _h2++){
                        if (oldj[_h2] != ksj[_h2]) {
                            conv = false;
                            break;
                        }
                    }
                }
            }
        } else {
            // Sum values and count for each centroid
            for(var _i2 = 0; _i2 < len; _i2++){
                var _idx3 = idxs[_i2];
                sum[_idx3] += data[_i2];
            }
            // Calculate the average for each centroid
            for(var _j4 = 0; _j4 < k; _j4++){
                ks[_j4] = sum[_j4] / count[_j4] || 0; // New centroid
            }
            // Find if centroids have moved
            conv = true;
            for(var _j5 = 0; _j5 < k; _j5++){
                if (old[_j5] != ks[_j5]) {
                    conv = false;
                    break;
                }
            }
        }
        conv = conv || --it <= 0;
    }while (!conv)
    return {
        it: MAX - it,
        k: k,
        idxs: idxs,
        centroids: ks
    };
}
module.exports = skmeans; //# sourceMappingURL=main.js.map
}}),
"[project]/node_modules/@turf/clusters-kmeans/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "clustersKmeans": (()=>clustersKmeans),
    "default": (()=>turf_clusters_kmeans_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$skmeans$2f$dist$2f$node$2f$main$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/skmeans/dist/node/main.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
function clustersKmeans(points, options = {}) {
    var count = points.features.length;
    options.numberOfClusters = options.numberOfClusters || Math.round(Math.sqrt(count / 2));
    if (options.numberOfClusters > count) options.numberOfClusters = count;
    if (options.mutate !== true) points = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(points);
    var data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coordAll"])(points);
    var initialCentroids = data.slice(0, options.numberOfClusters);
    var skmeansResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$skmeans$2f$dist$2f$node$2f$main$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(data, options.numberOfClusters, initialCentroids);
    var centroids = {};
    skmeansResult.centroids.forEach(function(coord, idx) {
        centroids[idx] = coord;
    });
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"])(points, function(point, index) {
        var clusterId = skmeansResult.idxs[index];
        point.properties.cluster = clusterId;
        point.properties.centroid = centroids[clusterId];
    });
    return points;
}
var turf_clusters_kmeans_default = clustersKmeans;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/collect/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "collect": (()=>collect),
    "default": (()=>turf_collect_default)
});
// lib/rbush-export.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$rbush$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rbush/rbush.min.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
var rbush = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$rbush$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
// index.ts
function collect(polygons, points, inProperty, outProperty) {
    var rtree = new rbush(6);
    var treeItems = points.features.map(function(item) {
        var _a;
        return {
            minX: item.geometry.coordinates[0],
            minY: item.geometry.coordinates[1],
            maxX: item.geometry.coordinates[0],
            maxY: item.geometry.coordinates[1],
            property: (_a = item.properties) == null ? void 0 : _a[inProperty]
        };
    });
    rtree.load(treeItems);
    polygons.features.forEach(function(poly) {
        if (!poly.properties) {
            poly.properties = {};
        }
        var bbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bbox"])(poly);
        var potentialPoints = rtree.search({
            minX: bbox[0],
            minY: bbox[1],
            maxX: bbox[2],
            maxY: bbox[3]
        });
        var values = [];
        potentialPoints.forEach(function(pt) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])([
                pt.minX,
                pt.minY
            ], poly)) {
                values.push(pt.property);
            }
        });
        poly.properties[outProperty] = values;
    });
    return polygons;
}
var turf_collect_default = collect;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/combine/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "combine": (()=>combine),
    "default": (()=>turf_combine_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
;
function combine(fc) {
    var groups = {
        MultiPoint: {
            coordinates: [],
            properties: []
        },
        MultiLineString: {
            coordinates: [],
            properties: []
        },
        MultiPolygon: {
            coordinates: [],
            properties: []
        }
    };
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"])(fc, (feature2)=>{
        var _a;
        switch((_a = feature2.geometry) == null ? void 0 : _a.type){
            case "Point":
                groups.MultiPoint.coordinates.push(feature2.geometry.coordinates);
                groups.MultiPoint.properties.push(feature2.properties);
                break;
            case "MultiPoint":
                groups.MultiPoint.coordinates.push(...feature2.geometry.coordinates);
                groups.MultiPoint.properties.push(feature2.properties);
                break;
            case "LineString":
                groups.MultiLineString.coordinates.push(feature2.geometry.coordinates);
                groups.MultiLineString.properties.push(feature2.properties);
                break;
            case "MultiLineString":
                groups.MultiLineString.coordinates.push(...feature2.geometry.coordinates);
                groups.MultiLineString.properties.push(feature2.properties);
                break;
            case "Polygon":
                groups.MultiPolygon.coordinates.push(feature2.geometry.coordinates);
                groups.MultiPolygon.properties.push(feature2.properties);
                break;
            case "MultiPolygon":
                groups.MultiPolygon.coordinates.push(...feature2.geometry.coordinates);
                groups.MultiPolygon.properties.push(feature2.properties);
                break;
            default:
                break;
        }
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(Object.keys(groups).filter(function(key) {
        return groups[key].coordinates.length;
    }).sort().map(function(key) {
        var geometry = {
            type: key,
            coordinates: groups[key].coordinates
        };
        var properties = {
            collectedProperties: groups[key].properties
        };
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["feature"])(geometry, properties);
    }));
}
var turf_combine_default = combine;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/topojson-client/src/identity.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(x) {
    return x;
}
}}),
"[project]/node_modules/topojson-client/src/transform.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$identity$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-client/src/identity.js [app-client] (ecmascript)");
;
function __TURBOPACK__default__export__(transform) {
    if (transform == null) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$identity$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
    var x0, y0, kx = transform.scale[0], ky = transform.scale[1], dx = transform.translate[0], dy = transform.translate[1];
    return function(input, i) {
        if (!i) x0 = y0 = 0;
        var j = 2, n = input.length, output = new Array(n);
        output[0] = (x0 += input[0]) * kx + dx;
        output[1] = (y0 += input[1]) * ky + dy;
        while(j < n)output[j] = input[j], ++j;
        return output;
    };
}
}}),
"[project]/node_modules/topojson-client/src/bbox.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-client/src/transform.js [app-client] (ecmascript)");
;
function __TURBOPACK__default__export__(topology) {
    var t = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(topology.transform), key, x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;
    function bboxPoint(p) {
        p = t(p);
        if (p[0] < x0) x0 = p[0];
        if (p[0] > x1) x1 = p[0];
        if (p[1] < y0) y0 = p[1];
        if (p[1] > y1) y1 = p[1];
    }
    function bboxGeometry(o) {
        switch(o.type){
            case "GeometryCollection":
                o.geometries.forEach(bboxGeometry);
                break;
            case "Point":
                bboxPoint(o.coordinates);
                break;
            case "MultiPoint":
                o.coordinates.forEach(bboxPoint);
                break;
        }
    }
    topology.arcs.forEach(function(arc) {
        var i = -1, n = arc.length, p;
        while(++i < n){
            p = t(arc[i], i);
            if (p[0] < x0) x0 = p[0];
            if (p[0] > x1) x1 = p[0];
            if (p[1] < y0) y0 = p[1];
            if (p[1] > y1) y1 = p[1];
        }
    });
    for(key in topology.objects){
        bboxGeometry(topology.objects[key]);
    }
    return [
        x0,
        y0,
        x1,
        y1
    ];
}
}}),
"[project]/node_modules/topojson-client/src/reverse.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(array, n) {
    var t, j = array.length, i = j - n;
    while(i < --j)t = array[i], array[i++] = array[j], array[j] = t;
}
}}),
"[project]/node_modules/topojson-client/src/feature.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__),
    "object": (()=>object)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$reverse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-client/src/reverse.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-client/src/transform.js [app-client] (ecmascript)");
;
;
function __TURBOPACK__default__export__(topology, o) {
    if (typeof o === "string") o = topology.objects[o];
    return o.type === "GeometryCollection" ? {
        type: "FeatureCollection",
        features: o.geometries.map(function(o) {
            return feature(topology, o);
        })
    } : feature(topology, o);
}
function feature(topology, o) {
    var id = o.id, bbox = o.bbox, properties = o.properties == null ? {} : o.properties, geometry = object(topology, o);
    return id == null && bbox == null ? {
        type: "Feature",
        properties: properties,
        geometry: geometry
    } : bbox == null ? {
        type: "Feature",
        id: id,
        properties: properties,
        geometry: geometry
    } : {
        type: "Feature",
        id: id,
        bbox: bbox,
        properties: properties,
        geometry: geometry
    };
}
function object(topology, o) {
    var transformPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(topology.transform), arcs = topology.arcs;
    function arc(i, points) {
        if (points.length) points.pop();
        for(var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k){
            points.push(transformPoint(a[k], k));
        }
        if (i < 0) (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$reverse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(points, n);
    }
    function point(p) {
        return transformPoint(p);
    }
    function line(arcs) {
        var points = [];
        for(var i = 0, n = arcs.length; i < n; ++i)arc(arcs[i], points);
        if (points.length < 2) points.push(points[0]); // This should never happen per the specification.
        return points;
    }
    function ring(arcs) {
        var points = line(arcs);
        while(points.length < 4)points.push(points[0]); // This may happen if an arc has only two points.
        return points;
    }
    function polygon(arcs) {
        return arcs.map(ring);
    }
    function geometry(o) {
        var type = o.type, coordinates;
        switch(type){
            case "GeometryCollection":
                return {
                    type: type,
                    geometries: o.geometries.map(geometry)
                };
            case "Point":
                coordinates = point(o.coordinates);
                break;
            case "MultiPoint":
                coordinates = o.coordinates.map(point);
                break;
            case "LineString":
                coordinates = line(o.arcs);
                break;
            case "MultiLineString":
                coordinates = o.arcs.map(line);
                break;
            case "Polygon":
                coordinates = polygon(o.arcs);
                break;
            case "MultiPolygon":
                coordinates = o.arcs.map(polygon);
                break;
            default:
                return null;
        }
        return {
            type: type,
            coordinates: coordinates
        };
    }
    return geometry(o);
}
}}),
"[project]/node_modules/topojson-client/src/stitch.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(topology, arcs) {
    var stitchedArcs = {}, fragmentByStart = {}, fragmentByEnd = {}, fragments = [], emptyIndex = -1;
    // Stitch empty arcs first, since they may be subsumed by other arcs.
    arcs.forEach(function(i, j) {
        var arc = topology.arcs[i < 0 ? ~i : i], t;
        if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
            t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
        }
    });
    arcs.forEach(function(i) {
        var e = ends(i), start = e[0], end = e[1], f, g;
        if (f = fragmentByEnd[start]) {
            delete fragmentByEnd[f.end];
            f.push(i);
            f.end = end;
            if (g = fragmentByStart[end]) {
                delete fragmentByStart[g.start];
                var fg = g === f ? f : f.concat(g);
                fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
            } else {
                fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
            }
        } else if (f = fragmentByStart[end]) {
            delete fragmentByStart[f.start];
            f.unshift(i);
            f.start = start;
            if (g = fragmentByEnd[start]) {
                delete fragmentByEnd[g.end];
                var gf = g === f ? f : g.concat(f);
                fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
            } else {
                fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
            }
        } else {
            f = [
                i
            ];
            fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
        }
    });
    function ends(i) {
        var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
        if (topology.transform) p1 = [
            0,
            0
        ], arc.forEach(function(dp) {
            p1[0] += dp[0], p1[1] += dp[1];
        });
        else p1 = arc[arc.length - 1];
        return i < 0 ? [
            p1,
            p0
        ] : [
            p0,
            p1
        ];
    }
    function flush(fragmentByEnd, fragmentByStart) {
        for(var k in fragmentByEnd){
            var f = fragmentByEnd[k];
            delete fragmentByStart[f.start];
            delete f.start;
            delete f.end;
            f.forEach(function(i) {
                stitchedArcs[i < 0 ? ~i : i] = 1;
            });
            fragments.push(f);
        }
    }
    flush(fragmentByEnd, fragmentByStart);
    flush(fragmentByStart, fragmentByEnd);
    arcs.forEach(function(i) {
        if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([
            i
        ]);
    });
    return fragments;
}
}}),
"[project]/node_modules/topojson-client/src/mesh.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__),
    "meshArcs": (()=>meshArcs)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$feature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-client/src/feature.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$stitch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-client/src/stitch.js [app-client] (ecmascript)");
;
;
function __TURBOPACK__default__export__(topology) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$feature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["object"])(topology, meshArcs.apply(this, arguments));
}
function meshArcs(topology, object, filter) {
    var arcs, i, n;
    if (arguments.length > 1) arcs = extractArcs(topology, object, filter);
    else for(i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i)arcs[i] = i;
    return {
        type: "MultiLineString",
        arcs: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$stitch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(topology, arcs)
    };
}
function extractArcs(topology, object, filter) {
    var arcs = [], geomsByArc = [], geom;
    function extract0(i) {
        var j = i < 0 ? ~i : i;
        (geomsByArc[j] || (geomsByArc[j] = [])).push({
            i: i,
            g: geom
        });
    }
    function extract1(arcs) {
        arcs.forEach(extract0);
    }
    function extract2(arcs) {
        arcs.forEach(extract1);
    }
    function extract3(arcs) {
        arcs.forEach(extract2);
    }
    function geometry(o) {
        switch(geom = o, o.type){
            case "GeometryCollection":
                o.geometries.forEach(geometry);
                break;
            case "LineString":
                extract1(o.arcs);
                break;
            case "MultiLineString":
            case "Polygon":
                extract2(o.arcs);
                break;
            case "MultiPolygon":
                extract3(o.arcs);
                break;
        }
    }
    geometry(object);
    geomsByArc.forEach(filter == null ? function(geoms) {
        arcs.push(geoms[0].i);
    } : function(geoms) {
        if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i);
    });
    return arcs;
}
}}),
"[project]/node_modules/topojson-client/src/merge.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__),
    "mergeArcs": (()=>mergeArcs)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$feature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-client/src/feature.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$stitch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-client/src/stitch.js [app-client] (ecmascript)");
;
;
function planarRingArea(ring) {
    var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;
    while(++i < n)a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];
    return Math.abs(area); // Note: doubled area!
}
function __TURBOPACK__default__export__(topology) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$feature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["object"])(topology, mergeArcs.apply(this, arguments));
}
function mergeArcs(topology, objects) {
    var polygonsByArc = {}, polygons = [], groups = [];
    objects.forEach(geometry);
    function geometry(o) {
        switch(o.type){
            case "GeometryCollection":
                o.geometries.forEach(geometry);
                break;
            case "Polygon":
                extract(o.arcs);
                break;
            case "MultiPolygon":
                o.arcs.forEach(extract);
                break;
        }
    }
    function extract(polygon) {
        polygon.forEach(function(ring) {
            ring.forEach(function(arc) {
                (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
            });
        });
        polygons.push(polygon);
    }
    function area(ring) {
        return planarRingArea((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$feature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["object"])(topology, {
            type: "Polygon",
            arcs: [
                ring
            ]
        }).coordinates[0]);
    }
    polygons.forEach(function(polygon) {
        if (!polygon._) {
            var group = [], neighbors = [
                polygon
            ];
            polygon._ = 1;
            groups.push(group);
            while(polygon = neighbors.pop()){
                group.push(polygon);
                polygon.forEach(function(ring) {
                    ring.forEach(function(arc) {
                        polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {
                            if (!polygon._) {
                                polygon._ = 1;
                                neighbors.push(polygon);
                            }
                        });
                    });
                });
            }
        }
    });
    polygons.forEach(function(polygon) {
        delete polygon._;
    });
    return {
        type: "MultiPolygon",
        arcs: groups.map(function(polygons) {
            var arcs = [], n;
            // Extract the exterior (unique) arcs.
            polygons.forEach(function(polygon) {
                polygon.forEach(function(ring) {
                    ring.forEach(function(arc) {
                        if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
                            arcs.push(arc);
                        }
                    });
                });
            });
            // Stitch the arcs into one or more rings.
            arcs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$stitch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(topology, arcs);
            // If more than one ring is returned,
            // at most one of these rings can be the exterior;
            // choose the one with the greatest absolute area.
            if ((n = arcs.length) > 1) {
                for(var i = 1, k = area(arcs[0]), ki, t; i < n; ++i){
                    if ((ki = area(arcs[i])) > k) {
                        t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;
                    }
                }
            }
            return arcs;
        }).filter(function(arcs) {
            return arcs.length > 0;
        })
    };
}
}}),
"[project]/node_modules/topojson-client/src/bisect.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(a, x) {
    var lo = 0, hi = a.length;
    while(lo < hi){
        var mid = lo + hi >>> 1;
        if (a[mid] < x) lo = mid + 1;
        else hi = mid;
    }
    return lo;
}
}}),
"[project]/node_modules/topojson-client/src/neighbors.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$bisect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-client/src/bisect.js [app-client] (ecmascript)");
;
function __TURBOPACK__default__export__(objects) {
    var indexesByArc = {}, neighbors = objects.map(function() {
        return [];
    });
    function line(arcs, i) {
        arcs.forEach(function(a) {
            if (a < 0) a = ~a;
            var o = indexesByArc[a];
            if (o) o.push(i);
            else indexesByArc[a] = [
                i
            ];
        });
    }
    function polygon(arcs, i) {
        arcs.forEach(function(arc) {
            line(arc, i);
        });
    }
    function geometry(o, i) {
        if (o.type === "GeometryCollection") o.geometries.forEach(function(o) {
            geometry(o, i);
        });
        else if (o.type in geometryType) geometryType[o.type](o.arcs, i);
    }
    var geometryType = {
        LineString: line,
        MultiLineString: polygon,
        Polygon: polygon,
        MultiPolygon: function(arcs, i) {
            arcs.forEach(function(arc) {
                polygon(arc, i);
            });
        }
    };
    objects.forEach(geometry);
    for(var i in indexesByArc){
        for(var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j){
            for(var k = j + 1; k < m; ++k){
                var ij = indexes[j], ik = indexes[k], n;
                if ((n = neighbors[ij])[i = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$bisect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(n, ik)] !== ik) n.splice(i, 0, ik);
                if ((n = neighbors[ik])[i = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$bisect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(n, ij)] !== ij) n.splice(i, 0, ij);
            }
        }
    }
    return neighbors;
}
}}),
"[project]/node_modules/topojson-client/src/untransform.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$identity$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-client/src/identity.js [app-client] (ecmascript)");
;
function __TURBOPACK__default__export__(transform) {
    if (transform == null) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$identity$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
    var x0, y0, kx = transform.scale[0], ky = transform.scale[1], dx = transform.translate[0], dy = transform.translate[1];
    return function(input, i) {
        if (!i) x0 = y0 = 0;
        var j = 2, n = input.length, output = new Array(n), x1 = Math.round((input[0] - dx) / kx), y1 = Math.round((input[1] - dy) / ky);
        output[0] = x1 - x0, x0 = x1;
        output[1] = y1 - y0, y0 = y1;
        while(j < n)output[j] = input[j], ++j;
        return output;
    };
}
}}),
"[project]/node_modules/topojson-client/src/quantize.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$bbox$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-client/src/bbox.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$untransform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-client/src/untransform.js [app-client] (ecmascript)");
;
;
function __TURBOPACK__default__export__(topology, transform) {
    if (topology.transform) throw new Error("already quantized");
    if (!transform || !transform.scale) {
        if (!((n = Math.floor(transform)) >= 2)) throw new Error("n must be 2");
        box = topology.bbox || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$bbox$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(topology);
        var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;
        transform = {
            scale: [
                x1 - x0 ? (x1 - x0) / (n - 1) : 1,
                y1 - y0 ? (y1 - y0) / (n - 1) : 1
            ],
            translate: [
                x0,
                y0
            ]
        };
    } else {
        box = topology.bbox;
    }
    var t = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$untransform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(transform), box, key, inputs = topology.objects, outputs = {};
    function quantizePoint(point) {
        return t(point);
    }
    function quantizeGeometry(input) {
        var output;
        switch(input.type){
            case "GeometryCollection":
                output = {
                    type: "GeometryCollection",
                    geometries: input.geometries.map(quantizeGeometry)
                };
                break;
            case "Point":
                output = {
                    type: "Point",
                    coordinates: quantizePoint(input.coordinates)
                };
                break;
            case "MultiPoint":
                output = {
                    type: "MultiPoint",
                    coordinates: input.coordinates.map(quantizePoint)
                };
                break;
            default:
                return input;
        }
        if (input.id != null) output.id = input.id;
        if (input.bbox != null) output.bbox = input.bbox;
        if (input.properties != null) output.properties = input.properties;
        return output;
    }
    function quantizeArc(input) {
        var i = 0, j = 1, n = input.length, p, output = new Array(n); // pessimistic
        output[0] = t(input[0], 0);
        while(++i < n)if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points
        if (j === 1) output[j++] = [
            0,
            0
        ]; // an arc must have at least two points
        output.length = j;
        return output;
    }
    for(key in inputs)outputs[key] = quantizeGeometry(inputs[key]);
    return {
        type: "Topology",
        bbox: box,
        transform: transform,
        objects: outputs,
        arcs: topology.arcs.map(quantizeArc)
    };
}
}}),
"[project]/node_modules/topojson-client/src/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({});
;
;
;
;
;
;
;
;
}}),
"[project]/node_modules/topojson-client/src/index.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$bbox$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-client/src/bbox.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$feature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-client/src/feature.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-client/src/mesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-client/src/merge.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$neighbors$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-client/src/neighbors.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$quantize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-client/src/quantize.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-client/src/transform.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$untransform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-client/src/untransform.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/topojson-client/src/index.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/topojson-client/src/merge.js [app-client] (ecmascript) <export default as merge>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "merge": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-client/src/merge.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/topojson-server/src/object.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "hasOwnProperty": (()=>hasOwnProperty)
});
var hasOwnProperty = Object.prototype.hasOwnProperty;
}}),
"[project]/node_modules/topojson-server/src/bounds.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-server/src/object.js [app-client] (ecmascript)");
;
function __TURBOPACK__default__export__(objects) {
    var x0 = Infinity, y0 = Infinity, x1 = -Infinity, y1 = -Infinity;
    function boundGeometry(geometry) {
        if (geometry != null && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"].call(boundGeometryType, geometry.type)) boundGeometryType[geometry.type](geometry);
    }
    var boundGeometryType = {
        GeometryCollection: function(o) {
            o.geometries.forEach(boundGeometry);
        },
        Point: function(o) {
            boundPoint(o.coordinates);
        },
        MultiPoint: function(o) {
            o.coordinates.forEach(boundPoint);
        },
        LineString: function(o) {
            boundLine(o.arcs);
        },
        MultiLineString: function(o) {
            o.arcs.forEach(boundLine);
        },
        Polygon: function(o) {
            o.arcs.forEach(boundLine);
        },
        MultiPolygon: function(o) {
            o.arcs.forEach(boundMultiLine);
        }
    };
    function boundPoint(coordinates) {
        var x = coordinates[0], y = coordinates[1];
        if (x < x0) x0 = x;
        if (x > x1) x1 = x;
        if (y < y0) y0 = y;
        if (y > y1) y1 = y;
    }
    function boundLine(coordinates) {
        coordinates.forEach(boundPoint);
    }
    function boundMultiLine(coordinates) {
        coordinates.forEach(boundLine);
    }
    for(var key in objects){
        boundGeometry(objects[key]);
    }
    return x1 >= x0 && y1 >= y0 ? [
        x0,
        y0,
        x1,
        y1
    ] : undefined;
}
}}),
"[project]/node_modules/topojson-server/src/hash/hashset.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(size, hash, equal, type, empty) {
    if (arguments.length === 3) {
        type = Array;
        empty = null;
    }
    var store = new type(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))), mask = size - 1;
    for(var i = 0; i < size; ++i){
        store[i] = empty;
    }
    function add(value) {
        var index = hash(value) & mask, match = store[index], collisions = 0;
        while(match != empty){
            if (equal(match, value)) return true;
            if (++collisions >= size) throw new Error("full hashset");
            match = store[index = index + 1 & mask];
        }
        store[index] = value;
        return true;
    }
    function has(value) {
        var index = hash(value) & mask, match = store[index], collisions = 0;
        while(match != empty){
            if (equal(match, value)) return true;
            if (++collisions >= size) break;
            match = store[index = index + 1 & mask];
        }
        return false;
    }
    function values() {
        var values = [];
        for(var i = 0, n = store.length; i < n; ++i){
            var match = store[i];
            if (match != empty) values.push(match);
        }
        return values;
    }
    return {
        add: add,
        has: has,
        values: values
    };
}
}}),
"[project]/node_modules/topojson-server/src/hash/hashmap.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(size, hash, equal, keyType, keyEmpty, valueType) {
    if (arguments.length === 3) {
        keyType = valueType = Array;
        keyEmpty = null;
    }
    var keystore = new keyType(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))), valstore = new valueType(size), mask = size - 1;
    for(var i = 0; i < size; ++i){
        keystore[i] = keyEmpty;
    }
    function set(key, value) {
        var index = hash(key) & mask, matchKey = keystore[index], collisions = 0;
        while(matchKey != keyEmpty){
            if (equal(matchKey, key)) return valstore[index] = value;
            if (++collisions >= size) throw new Error("full hashmap");
            matchKey = keystore[index = index + 1 & mask];
        }
        keystore[index] = key;
        valstore[index] = value;
        return value;
    }
    function maybeSet(key, value) {
        var index = hash(key) & mask, matchKey = keystore[index], collisions = 0;
        while(matchKey != keyEmpty){
            if (equal(matchKey, key)) return valstore[index];
            if (++collisions >= size) throw new Error("full hashmap");
            matchKey = keystore[index = index + 1 & mask];
        }
        keystore[index] = key;
        valstore[index] = value;
        return value;
    }
    function get(key, missingValue) {
        var index = hash(key) & mask, matchKey = keystore[index], collisions = 0;
        while(matchKey != keyEmpty){
            if (equal(matchKey, key)) return valstore[index];
            if (++collisions >= size) break;
            matchKey = keystore[index = index + 1 & mask];
        }
        return missingValue;
    }
    function keys() {
        var keys = [];
        for(var i = 0, n = keystore.length; i < n; ++i){
            var matchKey = keystore[i];
            if (matchKey != keyEmpty) keys.push(matchKey);
        }
        return keys;
    }
    return {
        set: set,
        maybeSet: maybeSet,
        get: get,
        keys: keys
    };
}
}}),
"[project]/node_modules/topojson-server/src/hash/point-equal.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(pointA, pointB) {
    return pointA[0] === pointB[0] && pointA[1] === pointB[1];
}
}}),
"[project]/node_modules/topojson-server/src/hash/point-hash.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// TODO if quantized, use simpler Int32 hashing?
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var buffer = new ArrayBuffer(16), floats = new Float64Array(buffer), uints = new Uint32Array(buffer);
function __TURBOPACK__default__export__(point) {
    floats[0] = point[0];
    floats[1] = point[1];
    var hash = uints[0] ^ uints[1];
    hash = hash << 5 ^ hash >> 7 ^ uints[2] ^ uints[3];
    return hash & 0x7fffffff;
}
}}),
"[project]/node_modules/topojson-server/src/join.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$hash$2f$hashset$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-server/src/hash/hashset.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$hash$2f$hashmap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-server/src/hash/hashmap.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$hash$2f$point$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-server/src/hash/point-equal.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$hash$2f$point$2d$hash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-server/src/hash/point-hash.js [app-client] (ecmascript)");
;
;
;
;
function __TURBOPACK__default__export__(topology) {
    var coordinates = topology.coordinates, lines = topology.lines, rings = topology.rings, indexes = index(), visitedByIndex = new Int32Array(coordinates.length), leftByIndex = new Int32Array(coordinates.length), rightByIndex = new Int32Array(coordinates.length), junctionByIndex = new Int8Array(coordinates.length), junctionCount = 0, i, n, previousIndex, currentIndex, nextIndex;
    for(i = 0, n = coordinates.length; i < n; ++i){
        visitedByIndex[i] = leftByIndex[i] = rightByIndex[i] = -1;
    }
    for(i = 0, n = lines.length; i < n; ++i){
        var line = lines[i], lineStart = line[0], lineEnd = line[1];
        currentIndex = indexes[lineStart];
        nextIndex = indexes[++lineStart];
        ++junctionCount, junctionByIndex[currentIndex] = 1; // start
        while(++lineStart <= lineEnd){
            sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[lineStart]);
        }
        ++junctionCount, junctionByIndex[nextIndex] = 1; // end
    }
    for(i = 0, n = coordinates.length; i < n; ++i){
        visitedByIndex[i] = -1;
    }
    for(i = 0, n = rings.length; i < n; ++i){
        var ring = rings[i], ringStart = ring[0] + 1, ringEnd = ring[1];
        previousIndex = indexes[ringEnd - 1];
        currentIndex = indexes[ringStart - 1];
        nextIndex = indexes[ringStart];
        sequence(i, previousIndex, currentIndex, nextIndex);
        while(++ringStart <= ringEnd){
            sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[ringStart]);
        }
    }
    function sequence(i, previousIndex, currentIndex, nextIndex) {
        if (visitedByIndex[currentIndex] === i) return; // ignore self-intersection
        visitedByIndex[currentIndex] = i;
        var leftIndex = leftByIndex[currentIndex];
        if (leftIndex >= 0) {
            var rightIndex = rightByIndex[currentIndex];
            if ((leftIndex !== previousIndex || rightIndex !== nextIndex) && (leftIndex !== nextIndex || rightIndex !== previousIndex)) {
                ++junctionCount, junctionByIndex[currentIndex] = 1;
            }
        } else {
            leftByIndex[currentIndex] = previousIndex;
            rightByIndex[currentIndex] = nextIndex;
        }
    }
    function index() {
        var indexByPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$hash$2f$hashmap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(coordinates.length * 1.4, hashIndex, equalIndex, Int32Array, -1, Int32Array), indexes = new Int32Array(coordinates.length);
        for(var i = 0, n = coordinates.length; i < n; ++i){
            indexes[i] = indexByPoint.maybeSet(i, i);
        }
        return indexes;
    }
    function hashIndex(i) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$hash$2f$point$2d$hash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(coordinates[i]);
    }
    function equalIndex(i, j) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$hash$2f$point$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(coordinates[i], coordinates[j]);
    }
    visitedByIndex = leftByIndex = rightByIndex = null;
    var junctionByPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$hash$2f$hashset$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(junctionCount * 1.4, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$hash$2f$point$2d$hash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$hash$2f$point$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]), j;
    // Convert back to a standard hashset by point for caller convenience.
    for(i = 0, n = coordinates.length; i < n; ++i){
        if (junctionByIndex[j = indexes[i]]) {
            junctionByPoint.add(coordinates[j]);
        }
    }
    return junctionByPoint;
}
}}),
"[project]/node_modules/topojson-server/src/cut.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$join$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-server/src/join.js [app-client] (ecmascript)");
;
function __TURBOPACK__default__export__(topology) {
    var junctions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$join$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(topology), coordinates = topology.coordinates, lines = topology.lines, rings = topology.rings, next, i, n;
    for(i = 0, n = lines.length; i < n; ++i){
        var line = lines[i], lineMid = line[0], lineEnd = line[1];
        while(++lineMid < lineEnd){
            if (junctions.has(coordinates[lineMid])) {
                next = {
                    0: lineMid,
                    1: line[1]
                };
                line[1] = lineMid;
                line = line.next = next;
            }
        }
    }
    for(i = 0, n = rings.length; i < n; ++i){
        var ring = rings[i], ringStart = ring[0], ringMid = ringStart, ringEnd = ring[1], ringFixed = junctions.has(coordinates[ringStart]);
        while(++ringMid < ringEnd){
            if (junctions.has(coordinates[ringMid])) {
                if (ringFixed) {
                    next = {
                        0: ringMid,
                        1: ring[1]
                    };
                    ring[1] = ringMid;
                    ring = ring.next = next;
                } else {
                    rotateArray(coordinates, ringStart, ringEnd, ringEnd - ringMid);
                    coordinates[ringEnd] = coordinates[ringStart];
                    ringFixed = true;
                    ringMid = ringStart; // restart; we may have skipped junctions
                }
            }
        }
    }
    return topology;
}
function rotateArray(array, start, end, offset) {
    reverse(array, start, end);
    reverse(array, start, start + offset);
    reverse(array, start + offset, end);
}
function reverse(array, start, end) {
    for(var mid = start + (end-- - start >> 1), t; start < mid; ++start, --end){
        t = array[start], array[start] = array[end], array[end] = t;
    }
}
}}),
"[project]/node_modules/topojson-server/src/dedup.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$hash$2f$hashmap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-server/src/hash/hashmap.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$hash$2f$point$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-server/src/hash/point-equal.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$hash$2f$point$2d$hash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-server/src/hash/point-hash.js [app-client] (ecmascript)");
;
;
;
function __TURBOPACK__default__export__(topology) {
    var coordinates = topology.coordinates, lines = topology.lines, line, rings = topology.rings, ring, arcCount = lines.length + rings.length, i, n;
    delete topology.lines;
    delete topology.rings;
    // Count the number of (non-unique) arcs to initialize the hashmap safely.
    for(i = 0, n = lines.length; i < n; ++i){
        line = lines[i];
        while(line = line.next)++arcCount;
    }
    for(i = 0, n = rings.length; i < n; ++i){
        ring = rings[i];
        while(ring = ring.next)++arcCount;
    }
    var arcsByEnd = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$hash$2f$hashmap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(arcCount * 2 * 1.4, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$hash$2f$point$2d$hash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$hash$2f$point$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]), arcs = topology.arcs = [];
    for(i = 0, n = lines.length; i < n; ++i){
        line = lines[i];
        do {
            dedupLine(line);
        }while (line = line.next)
    }
    for(i = 0, n = rings.length; i < n; ++i){
        ring = rings[i];
        if (ring.next) {
            do {
                dedupLine(ring);
            }while (ring = ring.next)
        } else {
            dedupRing(ring);
        }
    }
    function dedupLine(arc) {
        var startPoint, endPoint, startArcs, startArc, endArcs, endArc, i, n;
        // Does this arc match an existing arc in order?
        if (startArcs = arcsByEnd.get(startPoint = coordinates[arc[0]])) {
            for(i = 0, n = startArcs.length; i < n; ++i){
                startArc = startArcs[i];
                if (equalLine(startArc, arc)) {
                    arc[0] = startArc[0];
                    arc[1] = startArc[1];
                    return;
                }
            }
        }
        // Does this arc match an existing arc in reverse order?
        if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[1]])) {
            for(i = 0, n = endArcs.length; i < n; ++i){
                endArc = endArcs[i];
                if (reverseEqualLine(endArc, arc)) {
                    arc[1] = endArc[0];
                    arc[0] = endArc[1];
                    return;
                }
            }
        }
        if (startArcs) startArcs.push(arc);
        else arcsByEnd.set(startPoint, [
            arc
        ]);
        if (endArcs) endArcs.push(arc);
        else arcsByEnd.set(endPoint, [
            arc
        ]);
        arcs.push(arc);
    }
    function dedupRing(arc) {
        var endPoint, endArcs, endArc, i, n;
        // Does this arc match an existing line in order, or reverse order?
        // Rings are closed, so their start point and end point is the same.
        if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0]])) {
            for(i = 0, n = endArcs.length; i < n; ++i){
                endArc = endArcs[i];
                if (equalRing(endArc, arc)) {
                    arc[0] = endArc[0];
                    arc[1] = endArc[1];
                    return;
                }
                if (reverseEqualRing(endArc, arc)) {
                    arc[0] = endArc[1];
                    arc[1] = endArc[0];
                    return;
                }
            }
        }
        // Otherwise, does this arc match an existing ring in order, or reverse order?
        if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0] + findMinimumOffset(arc)])) {
            for(i = 0, n = endArcs.length; i < n; ++i){
                endArc = endArcs[i];
                if (equalRing(endArc, arc)) {
                    arc[0] = endArc[0];
                    arc[1] = endArc[1];
                    return;
                }
                if (reverseEqualRing(endArc, arc)) {
                    arc[0] = endArc[1];
                    arc[1] = endArc[0];
                    return;
                }
            }
        }
        if (endArcs) endArcs.push(arc);
        else arcsByEnd.set(endPoint, [
            arc
        ]);
        arcs.push(arc);
    }
    function equalLine(arcA, arcB) {
        var ia = arcA[0], ib = arcB[0], ja = arcA[1], jb = arcB[1];
        if (ia - ja !== ib - jb) return false;
        for(; ia <= ja; ++ia, ++ib)if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$hash$2f$point$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(coordinates[ia], coordinates[ib])) return false;
        return true;
    }
    function reverseEqualLine(arcA, arcB) {
        var ia = arcA[0], ib = arcB[0], ja = arcA[1], jb = arcB[1];
        if (ia - ja !== ib - jb) return false;
        for(; ia <= ja; ++ia, --jb)if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$hash$2f$point$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(coordinates[ia], coordinates[jb])) return false;
        return true;
    }
    function equalRing(arcA, arcB) {
        var ia = arcA[0], ib = arcB[0], ja = arcA[1], jb = arcB[1], n = ja - ia;
        if (n !== jb - ib) return false;
        var ka = findMinimumOffset(arcA), kb = findMinimumOffset(arcB);
        for(var i = 0; i < n; ++i){
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$hash$2f$point$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(coordinates[ia + (i + ka) % n], coordinates[ib + (i + kb) % n])) return false;
        }
        return true;
    }
    function reverseEqualRing(arcA, arcB) {
        var ia = arcA[0], ib = arcB[0], ja = arcA[1], jb = arcB[1], n = ja - ia;
        if (n !== jb - ib) return false;
        var ka = findMinimumOffset(arcA), kb = n - findMinimumOffset(arcB);
        for(var i = 0; i < n; ++i){
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$hash$2f$point$2d$equal$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(coordinates[ia + (i + ka) % n], coordinates[jb - (i + kb) % n])) return false;
        }
        return true;
    }
    // Rings are rotated to a consistent, but arbitrary, start point.
    // This is necessary to detect when a ring and a rotated copy are dupes.
    function findMinimumOffset(arc) {
        var start = arc[0], end = arc[1], mid = start, minimum = mid, minimumPoint = coordinates[mid];
        while(++mid < end){
            var point = coordinates[mid];
            if (point[0] < minimumPoint[0] || point[0] === minimumPoint[0] && point[1] < minimumPoint[1]) {
                minimum = mid;
                minimumPoint = point;
            }
        }
        return minimum - start;
    }
    return topology;
}
}}),
"[project]/node_modules/topojson-server/src/delta.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// Given an array of arcs in absolute (but already quantized!) coordinates,
// converts to fixed-point delta encoding.
// This is a destructive operation that modifies the given arcs!
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(arcs) {
    var i = -1, n = arcs.length;
    while(++i < n){
        var arc = arcs[i], j = 0, k = 1, m = arc.length, point = arc[0], x0 = point[0], y0 = point[1], x1, y1;
        while(++j < m){
            point = arc[j], x1 = point[0], y1 = point[1];
            if (x1 !== x0 || y1 !== y0) arc[k++] = [
                x1 - x0,
                y1 - y0
            ], x0 = x1, y0 = y1;
        }
        if (k === 1) arc[k++] = [
            0,
            0
        ]; // Each arc must be an array of two or more positions.
        arc.length = k;
    }
    return arcs;
}
}}),
"[project]/node_modules/topojson-server/src/extract.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-server/src/object.js [app-client] (ecmascript)");
;
function __TURBOPACK__default__export__(objects) {
    var index = -1, lines = [], rings = [], coordinates = [];
    function extractGeometry(geometry) {
        if (geometry && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"].call(extractGeometryType, geometry.type)) extractGeometryType[geometry.type](geometry);
    }
    var extractGeometryType = {
        GeometryCollection: function(o) {
            o.geometries.forEach(extractGeometry);
        },
        LineString: function(o) {
            o.arcs = extractLine(o.arcs);
        },
        MultiLineString: function(o) {
            o.arcs = o.arcs.map(extractLine);
        },
        Polygon: function(o) {
            o.arcs = o.arcs.map(extractRing);
        },
        MultiPolygon: function(o) {
            o.arcs = o.arcs.map(extractMultiRing);
        }
    };
    function extractLine(line) {
        for(var i = 0, n = line.length; i < n; ++i)coordinates[++index] = line[i];
        var arc = {
            0: index - n + 1,
            1: index
        };
        lines.push(arc);
        return arc;
    }
    function extractRing(ring) {
        for(var i = 0, n = ring.length; i < n; ++i)coordinates[++index] = ring[i];
        var arc = {
            0: index - n + 1,
            1: index
        };
        rings.push(arc);
        return arc;
    }
    function extractMultiRing(rings) {
        return rings.map(extractRing);
    }
    for(var key in objects){
        extractGeometry(objects[key]);
    }
    return {
        type: "Topology",
        coordinates: coordinates,
        lines: lines,
        rings: rings,
        objects: objects
    };
}
}}),
"[project]/node_modules/topojson-server/src/geometry.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// Given a hash of GeoJSON objects, returns a hash of GeoJSON geometry objects.
// Any null input geometry objects are represented as {type: null} in the output.
// Any feature.{id,properties,bbox} are transferred to the output geometry object.
// Each output geometry object is a shallow copy of the input (e.g., properties, coordinates)!
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(inputs) {
    var outputs = {}, key;
    for(key in inputs)outputs[key] = geomifyObject(inputs[key]);
    return outputs;
}
function geomifyObject(input) {
    return input == null ? {
        type: null
    } : (input.type === "FeatureCollection" ? geomifyFeatureCollection : input.type === "Feature" ? geomifyFeature : geomifyGeometry)(input);
}
function geomifyFeatureCollection(input) {
    var output = {
        type: "GeometryCollection",
        geometries: input.features.map(geomifyFeature)
    };
    if (input.bbox != null) output.bbox = input.bbox;
    return output;
}
function geomifyFeature(input) {
    var output = geomifyGeometry(input.geometry), key; // eslint-disable-line no-unused-vars
    if (input.id != null) output.id = input.id;
    if (input.bbox != null) output.bbox = input.bbox;
    for(key in input.properties){
        output.properties = input.properties;
        break;
    }
    return output;
}
function geomifyGeometry(input) {
    if (input == null) return {
        type: null
    };
    var output = input.type === "GeometryCollection" ? {
        type: "GeometryCollection",
        geometries: input.geometries.map(geomifyGeometry)
    } : input.type === "Point" || input.type === "MultiPoint" ? {
        type: input.type,
        coordinates: input.coordinates
    } : {
        type: input.type,
        arcs: input.coordinates
    }; // TODO Check for unknown types?
    if (input.bbox != null) output.bbox = input.bbox;
    return output;
}
}}),
"[project]/node_modules/topojson-server/src/prequantize.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-server/src/object.js [app-client] (ecmascript)");
;
function __TURBOPACK__default__export__(objects, bbox, n) {
    var x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3], kx = x1 - x0 ? (n - 1) / (x1 - x0) : 1, ky = y1 - y0 ? (n - 1) / (y1 - y0) : 1;
    function quantizePoint(input) {
        return [
            Math.round((input[0] - x0) * kx),
            Math.round((input[1] - y0) * ky)
        ];
    }
    function quantizePoints(input, m) {
        var i = -1, j = 0, n = input.length, output = new Array(n), pi, px, py, x, y;
        while(++i < n){
            pi = input[i];
            x = Math.round((pi[0] - x0) * kx);
            y = Math.round((pi[1] - y0) * ky);
            if (x !== px || y !== py) output[j++] = [
                px = x,
                py = y
            ]; // non-coincident points
        }
        output.length = j;
        while(j < m)j = output.push([
            output[0][0],
            output[0][1]
        ]);
        return output;
    }
    function quantizeLine(input) {
        return quantizePoints(input, 2);
    }
    function quantizeRing(input) {
        return quantizePoints(input, 4);
    }
    function quantizePolygon(input) {
        return input.map(quantizeRing);
    }
    function quantizeGeometry(o) {
        if (o != null && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"].call(quantizeGeometryType, o.type)) quantizeGeometryType[o.type](o);
    }
    var quantizeGeometryType = {
        GeometryCollection: function(o) {
            o.geometries.forEach(quantizeGeometry);
        },
        Point: function(o) {
            o.coordinates = quantizePoint(o.coordinates);
        },
        MultiPoint: function(o) {
            o.coordinates = o.coordinates.map(quantizePoint);
        },
        LineString: function(o) {
            o.arcs = quantizeLine(o.arcs);
        },
        MultiLineString: function(o) {
            o.arcs = o.arcs.map(quantizeLine);
        },
        Polygon: function(o) {
            o.arcs = quantizePolygon(o.arcs);
        },
        MultiPolygon: function(o) {
            o.arcs = o.arcs.map(quantizePolygon);
        }
    };
    for(var key in objects){
        quantizeGeometry(objects[key]);
    }
    return {
        scale: [
            1 / kx,
            1 / ky
        ],
        translate: [
            x0,
            y0
        ]
    };
}
}}),
"[project]/node_modules/topojson-server/src/topology.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$bounds$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-server/src/bounds.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$cut$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-server/src/cut.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$dedup$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-server/src/dedup.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$delta$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-server/src/delta.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$extract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-server/src/extract.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-server/src/geometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$hash$2f$hashmap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-server/src/hash/hashmap.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-server/src/object.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$prequantize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-server/src/prequantize.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
function __TURBOPACK__default__export__(objects, quantization) {
    var bbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$bounds$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(objects = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(objects)), transform = quantization > 0 && bbox && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$prequantize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(objects, bbox, quantization), topology = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$dedup$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$cut$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$extract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(objects))), coordinates = topology.coordinates, indexByArc = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$hash$2f$hashmap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(topology.arcs.length * 1.4, hashArc, equalArc);
    objects = topology.objects; // for garbage collection
    topology.bbox = bbox;
    topology.arcs = topology.arcs.map(function(arc, i) {
        indexByArc.set(arc, i);
        return coordinates.slice(arc[0], arc[1] + 1);
    });
    delete topology.coordinates;
    coordinates = null;
    function indexGeometry(geometry) {
        if (geometry && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"].call(indexGeometryType, geometry.type)) indexGeometryType[geometry.type](geometry);
    }
    var indexGeometryType = {
        GeometryCollection: function(o) {
            o.geometries.forEach(indexGeometry);
        },
        LineString: function(o) {
            o.arcs = indexArcs(o.arcs);
        },
        MultiLineString: function(o) {
            o.arcs = o.arcs.map(indexArcs);
        },
        Polygon: function(o) {
            o.arcs = o.arcs.map(indexArcs);
        },
        MultiPolygon: function(o) {
            o.arcs = o.arcs.map(indexMultiArcs);
        }
    };
    function indexArcs(arc) {
        var indexes = [];
        do {
            var index = indexByArc.get(arc);
            indexes.push(arc[0] < arc[1] ? index : ~index);
        }while (arc = arc.next)
        return indexes;
    }
    function indexMultiArcs(arcs) {
        return arcs.map(indexArcs);
    }
    for(var key in objects){
        indexGeometry(objects[key]);
    }
    if (transform) {
        topology.transform = transform;
        topology.arcs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$delta$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(topology.arcs);
    }
    return topology;
}
function hashArc(arc) {
    var i = arc[0], j = arc[1], t;
    if (j < i) t = i, i = j, j = t;
    return i + 31 * j;
}
function equalArc(arcA, arcB) {
    var ia = arcA[0], ja = arcA[1], ib = arcB[0], jb = arcB[1], t;
    if (ja < ia) t = ia, ia = ja, ja = t;
    if (jb < ib) t = ib, ib = jb, jb = t;
    return ia === ib && ja === jb;
}
}}),
"[project]/node_modules/topojson-server/src/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({});
;
}}),
"[project]/node_modules/topojson-server/src/index.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$topology$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-server/src/topology.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/topojson-server/src/index.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/topojson-server/src/topology.js [app-client] (ecmascript) <export default as topology>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "topology": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$topology$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$topology$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/topojson-server/src/topology.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/@turf/tin/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_tin_default),
    "tin": (()=>tin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
function tin(points, z) {
    let isPointZ = false;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(triangulate(points.features.map((p)=>{
        const point = {
            x: p.geometry.coordinates[0],
            y: p.geometry.coordinates[1]
        };
        if (z) {
            point.z = p.properties[z];
        } else if (p.geometry.coordinates.length === 3) {
            isPointZ = true;
            point.z = p.geometry.coordinates[2];
        }
        return point;
    })).map((triangle)=>{
        const a = [
            triangle.a.x,
            triangle.a.y
        ];
        const b = [
            triangle.b.x,
            triangle.b.y
        ];
        const c = [
            triangle.c.x,
            triangle.c.y
        ];
        let properties = {};
        if (isPointZ) {
            a.push(triangle.a.z);
            b.push(triangle.b.z);
            c.push(triangle.c.z);
        } else {
            properties = {
                a: triangle.a.z,
                b: triangle.b.z,
                c: triangle.c.z
            };
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])([
            [
                a,
                b,
                c,
                a
            ]
        ], properties);
    }));
}
var Triangle = class {
    constructor(a, b, c){
        this.a = a;
        this.b = b;
        this.c = c;
        const A = b.x - a.x;
        const B = b.y - a.y;
        const C = c.x - a.x;
        const D = c.y - a.y;
        const E = A * (a.x + b.x) + B * (a.y + b.y);
        const F = C * (a.x + c.x) + D * (a.y + c.y);
        const G = 2 * (A * (c.y - b.y) - B * (c.x - b.x));
        let dx;
        let dy;
        this.x = (D * E - B * F) / G;
        this.y = (A * F - C * E) / G;
        dx = this.x - a.x;
        dy = this.y - a.y;
        this.r = dx * dx + dy * dy;
    }
};
function byX(a, b) {
    return b.x - a.x;
}
function dedup(edges) {
    let j = edges.length;
    let a;
    let b;
    let i;
    let m;
    let n;
    outer: while(j){
        b = edges[--j];
        a = edges[--j];
        i = j;
        while(i){
            n = edges[--i];
            m = edges[--i];
            if (a === m && b === n || a === n && b === m) {
                edges.splice(j, 2);
                edges.splice(i, 2);
                j -= 2;
                continue outer;
            }
        }
    }
}
function triangulate(vertices) {
    if (vertices.length < 3) {
        return [];
    }
    vertices.sort(byX);
    let i = vertices.length - 1;
    const xmin = vertices[i].x;
    const xmax = vertices[0].x;
    let ymin = vertices[i].y;
    let ymax = ymin;
    const epsilon = 1e-12;
    let a;
    let b;
    let c;
    let A;
    let B;
    let G;
    while(i--){
        if (vertices[i].y < ymin) {
            ymin = vertices[i].y;
        }
        if (vertices[i].y > ymax) {
            ymax = vertices[i].y;
        }
    }
    let dx = xmax - xmin;
    let dy = ymax - ymin;
    const dmax = dx > dy ? dx : dy;
    const xmid = (xmax + xmin) * 0.5;
    const ymid = (ymax + ymin) * 0.5;
    const open = [
        new Triangle({
            __sentinel: true,
            x: xmid - 20 * dmax,
            y: ymid - dmax
        }, {
            __sentinel: true,
            x: xmid,
            y: ymid + 20 * dmax
        }, {
            __sentinel: true,
            x: xmid + 20 * dmax,
            y: ymid - dmax
        })
    ];
    const closed = [];
    const edges = [];
    let j;
    i = vertices.length;
    while(i--){
        edges.length = 0;
        j = open.length;
        while(j--){
            dx = vertices[i].x - open[j].x;
            if (dx > 0 && dx * dx > open[j].r) {
                closed.push(open[j]);
                open.splice(j, 1);
                continue;
            }
            dy = vertices[i].y - open[j].y;
            if (dx * dx + dy * dy > open[j].r) {
                continue;
            }
            edges.push(open[j].a, open[j].b, open[j].b, open[j].c, open[j].c, open[j].a);
            open.splice(j, 1);
        }
        dedup(edges);
        j = edges.length;
        while(j){
            b = edges[--j];
            a = edges[--j];
            c = vertices[i];
            A = b.x - a.x;
            B = b.y - a.y;
            G = 2 * (A * (c.y - b.y) - B * (c.x - b.x));
            if (Math.abs(G) > epsilon) {
                open.push(new Triangle(a, b, c));
            }
        }
    }
    Array.prototype.push.apply(closed, open);
    i = closed.length;
    while(i--){
        if (closed[i].a.__sentinel || closed[i].b.__sentinel || closed[i].c.__sentinel) {
            closed.splice(i, 1);
        }
    }
    return closed;
}
var turf_tin_default = tin;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/concave/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "concave": (()=>concave),
    "default": (()=>turf_concave_default)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/topojson-client/src/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/topojson-server/src/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
// lib/turf-line-dissolve.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$topology$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__topology$3e$__ = __turbopack_import__("[project]/node_modules/topojson-server/src/topology.js [app-client] (ecmascript) <export default as topology>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__merge$3e$__ = __turbopack_import__("[project]/node_modules/topojson-client/src/merge.js [app-client] (ecmascript) <export default as merge>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$tin$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/tin/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
function lineDissolve(geojson, options = {}) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(options)) {
        throw new Error("options is invalid");
    }
    const mutate = options.mutate;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getType"])(geojson) !== "FeatureCollection") {
        throw new Error("geojson must be a FeatureCollection");
    }
    if (!geojson.features.length) {
        throw new Error("geojson is empty");
    }
    if (mutate === false || mutate === void 0) {
        geojson = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(geojson);
    }
    const result = [];
    const lastLine = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineReduce"])(geojson, (previousLine, currentLine)=>{
        const merged = mergeLineStrings(previousLine, currentLine);
        if (merged) {
            return merged;
        } else {
            result.push(previousLine);
            return currentLine;
        }
    });
    if (lastLine) {
        result.push(lastLine);
    }
    if (!result.length) {
        return null;
    } else if (result.length === 1) {
        return result[0];
    } else {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiLineString"])(result.map((line)=>{
            return line.coordinates;
        }));
    }
}
function coordId(coord) {
    return coord[0].toString() + "," + coord[1].toString();
}
function mergeLineStrings(a, b) {
    const coords1 = a.geometry.coordinates;
    const coords2 = b.geometry.coordinates;
    const s1 = coordId(coords1[0]);
    const e1 = coordId(coords1[coords1.length - 1]);
    const s2 = coordId(coords2[0]);
    const e2 = coordId(coords2[coords2.length - 1]);
    let coords;
    if (s1 === e2) {
        coords = coords2.concat(coords1.slice(1));
    } else if (s2 === e1) {
        coords = coords1.concat(coords2.slice(1));
    } else if (s1 === s2) {
        coords = coords1.slice(1).reverse().concat(coords2);
    } else if (e1 === e2) {
        coords = coords1.concat(coords2.reverse().slice(1));
    } else {
        return null;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineString"])(coords);
}
;
;
;
;
;
;
function polygonDissolve(geojson, options = {}) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getType"])(geojson) !== "FeatureCollection") {
        throw new Error("geojson must be a FeatureCollection");
    }
    if (!geojson.features.length) {
        throw new Error("geojson is empty");
    }
    if (options.mutate === false || options.mutate === void 0) {
        geojson = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(geojson);
    }
    const geoms = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["flattenEach"])(geojson, (feature2)=>{
        geoms.push(feature2.geometry);
    });
    const topo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$server$2f$src$2f$topology$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__topology$3e$__["topology"])({
        geoms: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["geometryCollection"])(geoms).geometry
    });
    const merged = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$topojson$2d$client$2f$src$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__merge$3e$__["merge"])(topo, topo.objects.geoms.geometries);
    return merged;
}
// lib/turf-dissolve.ts
function dissolve(geojson, options = {}) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(options)) {
        throw new Error("options is invalid");
    }
    const mutate = options.mutate;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getType"])(geojson) !== "FeatureCollection") {
        throw new Error("geojson must be a FeatureCollection");
    }
    if (!geojson.features.length) {
        throw new Error("geojson is empty");
    }
    if (mutate === false || mutate === void 0) {
        geojson = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(geojson);
    }
    const type = getHomogenousType(geojson);
    if (!type) {
        throw new Error("geojson must be homogenous");
    }
    const data = geojson;
    switch(type){
        case "LineString":
            return lineDissolve(data, options);
        case "Polygon":
            return polygonDissolve(data, options);
        default:
            throw new Error(type + " is not supported");
    }
}
function getHomogenousType(geojson) {
    const types = {};
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["flattenEach"])(geojson, (feature2)=>{
        types[feature2.geometry.type] = true;
    });
    const keys = Object.keys(types);
    if (keys.length === 1) {
        return keys[0];
    }
    return null;
}
// index.ts
function concave(points, options = {}) {
    const maxEdge = options.maxEdge || Infinity;
    const cleaned = removeDuplicates(points);
    const tinPolys = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$tin$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["tin"])(cleaned);
    tinPolys.features = tinPolys.features.filter((triangle)=>{
        const pt1 = triangle.geometry.coordinates[0][0];
        const pt2 = triangle.geometry.coordinates[0][1];
        const pt3 = triangle.geometry.coordinates[0][2];
        const dist1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(pt1, pt2, options);
        const dist2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(pt2, pt3, options);
        const dist3 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(pt1, pt3, options);
        return dist1 <= maxEdge && dist2 <= maxEdge && dist3 <= maxEdge;
    });
    if (tinPolys.features.length < 1) {
        return null;
    }
    const dissolved = dissolve(tinPolys);
    if (dissolved.coordinates.length === 1) {
        dissolved.coordinates = dissolved.coordinates[0];
        dissolved.type = "Polygon";
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["feature"])(dissolved);
}
function removeDuplicates(points) {
    const cleaned = [];
    const existing = {};
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"])(points, (pt)=>{
        if (!pt.geometry) {
            return;
        }
        const key = pt.geometry.coordinates.join("-");
        if (!Object.prototype.hasOwnProperty.call(existing, key)) {
            cleaned.push(pt);
            existing[key] = true;
        }
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(cleaned);
}
var turf_concave_default = concave;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/bignumber.js/bignumber.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
 *      bignumber.js v9.1.2
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */ __turbopack_esm__({
    "BigNumber": (()=>BigNumber),
    "default": (()=>__TURBOPACK__default__export__)
});
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = '[BigNumber Error] ', tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ', BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 0x1fffffffffffff, // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
POWS_TEN = [
    1,
    10,
    100,
    1e3,
    1e4,
    1e5,
    1e6,
    1e7,
    1e8,
    1e9,
    1e10,
    1e11,
    1e12,
    1e13
], SQRT_BASE = 1e7, // EDITABLE
// The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
// the arguments to toExponential, toFixed, toFormat, and toPrecision.
MAX = 1E9; // 0 to MAX_INT32
/*
 * Create and return a BigNumber constructor.
 */ function clone(configObject) {
    var div, convertBase, parseNumeric, P = BigNumber.prototype = {
        constructor: BigNumber,
        toString: null,
        valueOf: null
    }, ONE = new BigNumber(1), //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------
    // The default values below must be integers within the inclusive ranges stated.
    // The values can also be changed at run-time using BigNumber.set.
    // The maximum number of decimal places for operations involving division.
    DECIMAL_PLACES = 20, // The rounding mode used when rounding to the above decimal places, and when using
    // toExponential, toFixed, toFormat and toPrecision, and round (default value).
    // UP         0 Away from zero.
    // DOWN       1 Towards zero.
    // CEIL       2 Towards +Infinity.
    // FLOOR      3 Towards -Infinity.
    // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
    // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
    // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
    // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
    // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
    ROUNDING_MODE = 4, // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]
    // The exponent value at and beneath which toString returns exponential notation.
    // Number type: -7
    TO_EXP_NEG = -7, // The exponent value at and above which toString returns exponential notation.
    // Number type: 21
    TO_EXP_POS = 21, // RANGE : [MIN_EXP, MAX_EXP]
    // The minimum exponent value, beneath which underflow to zero occurs.
    // Number type: -324  (5e-324)
    MIN_EXP = -1e7, // The maximum exponent value, above which overflow to Infinity occurs.
    // Number type:  308  (1.7976931348623157e+308)
    // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
    MAX_EXP = 1e7, // Whether to use cryptographically-secure random number generation, if available.
    CRYPTO = false, // The modulo mode used when calculating the modulus: a mod n.
    // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
    // The remainder (r) is calculated as: r = a - n * q.
    //
    // UP        0 The remainder is positive if the dividend is negative, else is negative.
    // DOWN      1 The remainder has the same sign as the dividend.
    //             This modulo mode is commonly known as 'truncated division' and is
    //             equivalent to (a % n) in JavaScript.
    // FLOOR     3 The remainder has the same sign as the divisor (Python %).
    // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
    // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
    //             The remainder is always positive.
    //
    // The truncated division, floored division, Euclidian division and IEEE 754 remainder
    // modes are commonly used for the modulus operation.
    // Although the other rounding modes can also be used, they may not give useful results.
    MODULO_MODE = 1, // The maximum number of significant digits of the result of the exponentiatedBy operation.
    // If POW_PRECISION is 0, there will be unlimited significant digits.
    POW_PRECISION = 0, // The format specification used by the BigNumber.prototype.toFormat method.
    FORMAT = {
        prefix: '',
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ',',
        decimalSeparator: '.',
        fractionGroupSize: 0,
        fractionGroupSeparator: '\xA0',
        suffix: ''
    }, // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
    // '-', '.', whitespace, or repeated character.
    // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
    ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz', alphabetHasNormalDecimalDigits = true;
    //------------------------------------------------------------------------------------------
    // CONSTRUCTOR
    /*
   * The BigNumber constructor and exported function.
   * Create and return a new instance of a BigNumber object.
   *
   * v {number|string|BigNumber} A numeric value.
   * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
   */ function BigNumber(v, b) {
        var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
        // Enable constructor call without `new`.
        if (!(x instanceof BigNumber)) return new BigNumber(v, b);
        if (b == null) {
            if (v && v._isBigNumber === true) {
                x.s = v.s;
                if (!v.c || v.e > MAX_EXP) {
                    x.c = x.e = null;
                } else if (v.e < MIN_EXP) {
                    x.c = [
                        x.e = 0
                    ];
                } else {
                    x.e = v.e;
                    x.c = v.c.slice();
                }
                return;
            }
            if ((isNum = typeof v == 'number') && v * 0 == 0) {
                // Use `1 / n` to handle minus zero also.
                x.s = 1 / v < 0 ? (v = -v, -1) : 1;
                // Fast path for integers, where n < 2147483648 (2**31).
                if (v === ~~v) {
                    for(e = 0, i = v; i >= 10; i /= 10, e++);
                    if (e > MAX_EXP) {
                        x.c = x.e = null;
                    } else {
                        x.e = e;
                        x.c = [
                            v
                        ];
                    }
                    return;
                }
                str = String(v);
            } else {
                if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);
                x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            // Decimal point?
            if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
            // Exponential form?
            if ((i = str.search(/e/i)) > 0) {
                // Determine exponent.
                if (e < 0) e = i;
                e += +str.slice(i + 1);
                str = str.substring(0, i);
            } else if (e < 0) {
                // Integer.
                e = str.length;
            }
        } else {
            // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
            intCheck(b, 2, ALPHABET.length, 'Base');
            // Allow exponential notation to be used with base 10 argument, while
            // also rounding to DECIMAL_PLACES as with other bases.
            if (b == 10 && alphabetHasNormalDecimalDigits) {
                x = new BigNumber(v);
                return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }
            str = String(v);
            if (isNum = typeof v == 'number') {
                // Avoid potential interpretation of Infinity and NaN as base 44+ values.
                if (v * 0 != 0) return parseNumeric(x, str, isNum, b);
                x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
                // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
                if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
                    throw Error(tooManyDigits + v);
                }
            } else {
                x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet = ALPHABET.slice(0, b);
            e = i = 0;
            // Check that str is a valid base b number.
            // Don't use RegExp, so alphabet can contain special characters.
            for(len = str.length; i < len; i++){
                if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                    if (c == '.') {
                        // If '.' is not the first character and it has not be found before.
                        if (i > e) {
                            e = len;
                            continue;
                        }
                    } else if (!caseChanged) {
                        // Allow e.g. hexadecimal 'FF' as well as 'ff'.
                        if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                            caseChanged = true;
                            i = -1;
                            e = 0;
                            continue;
                        }
                    }
                    return parseNumeric(x, String(v), isNum, b);
                }
            }
            // Prevent later check for length on converted number.
            isNum = false;
            str = convertBase(str, b, 10, x.s);
            // Decimal point?
            if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
            else e = str.length;
        }
        // Determine leading zeros.
        for(i = 0; str.charCodeAt(i) === 48; i++);
        // Determine trailing zeros.
        for(len = str.length; str.charCodeAt(--len) === 48;);
        if (str = str.slice(i, ++len)) {
            len -= i;
            // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
            if (isNum && BigNumber.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
                throw Error(tooManyDigits + x.s * v);
            }
            // Overflow?
            if ((e = e - i - 1) > MAX_EXP) {
                // Infinity.
                x.c = x.e = null;
            // Underflow?
            } else if (e < MIN_EXP) {
                // Zero.
                x.c = [
                    x.e = 0
                ];
            } else {
                x.e = e;
                x.c = [];
                // Transform base
                // e is the base 10 exponent.
                // i is where to slice str to get the first element of the coefficient array.
                i = (e + 1) % LOG_BASE;
                if (e < 0) i += LOG_BASE; // i < 1
                if (i < len) {
                    if (i) x.c.push(+str.slice(0, i));
                    for(len -= LOG_BASE; i < len;){
                        x.c.push(+str.slice(i, i += LOG_BASE));
                    }
                    i = LOG_BASE - (str = str.slice(i)).length;
                } else {
                    i -= len;
                }
                for(; i--; str += '0');
                x.c.push(+str);
            }
        } else {
            // Zero.
            x.c = [
                x.e = 0
            ];
        }
    }
    // CONSTRUCTOR PROPERTIES
    BigNumber.clone = clone;
    BigNumber.ROUND_UP = 0;
    BigNumber.ROUND_DOWN = 1;
    BigNumber.ROUND_CEIL = 2;
    BigNumber.ROUND_FLOOR = 3;
    BigNumber.ROUND_HALF_UP = 4;
    BigNumber.ROUND_HALF_DOWN = 5;
    BigNumber.ROUND_HALF_EVEN = 6;
    BigNumber.ROUND_HALF_CEIL = 7;
    BigNumber.ROUND_HALF_FLOOR = 8;
    BigNumber.EUCLID = 9;
    /*
   * Configure infrequently-changing library-wide settings.
   *
   * Accept an object with the following optional properties (if the value of a property is
   * a number, it must be an integer within the inclusive range stated):
   *
   *   DECIMAL_PLACES   {number}           0 to MAX
   *   ROUNDING_MODE    {number}           0 to 8
   *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
   *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
   *   CRYPTO           {boolean}          true or false
   *   MODULO_MODE      {number}           0 to 9
   *   POW_PRECISION       {number}           0 to MAX
   *   ALPHABET         {string}           A string of two or more unique characters which does
   *                                       not contain '.'.
   *   FORMAT           {object}           An object with some of the following properties:
   *     prefix                 {string}
   *     groupSize              {number}
   *     secondaryGroupSize     {number}
   *     groupSeparator         {string}
   *     decimalSeparator       {string}
   *     fractionGroupSize      {number}
   *     fractionGroupSeparator {string}
   *     suffix                 {string}
   *
   * (The values assigned to the above FORMAT object properties are not checked for validity.)
   *
   * E.g.
   * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
   *
   * Ignore properties/parameters set to null or undefined, except for ALPHABET.
   *
   * Return an object with the properties current values.
   */ BigNumber.config = BigNumber.set = function(obj) {
        var p, v;
        if (obj != null) {
            if (typeof obj == 'object') {
                // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
                // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
                if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
                    v = obj[p];
                    intCheck(v, 0, MAX, p);
                    DECIMAL_PLACES = v;
                }
                // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
                // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
                if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
                    v = obj[p];
                    intCheck(v, 0, 8, p);
                    ROUNDING_MODE = v;
                }
                // EXPONENTIAL_AT {number|number[]}
                // Integer, -MAX to MAX inclusive or
                // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
                // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
                if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
                    v = obj[p];
                    if (v && v.pop) {
                        intCheck(v[0], -MAX, 0, p);
                        intCheck(v[1], 0, MAX, p);
                        TO_EXP_NEG = v[0];
                        TO_EXP_POS = v[1];
                    } else {
                        intCheck(v, -MAX, MAX, p);
                        TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                    }
                }
                // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
                // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
                // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
                if (obj.hasOwnProperty(p = 'RANGE')) {
                    v = obj[p];
                    if (v && v.pop) {
                        intCheck(v[0], -MAX, -1, p);
                        intCheck(v[1], 1, MAX, p);
                        MIN_EXP = v[0];
                        MAX_EXP = v[1];
                    } else {
                        intCheck(v, -MAX, MAX, p);
                        if (v) {
                            MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                        } else {
                            throw Error(bignumberError + p + ' cannot be zero: ' + v);
                        }
                    }
                }
                // CRYPTO {boolean} true or false.
                // '[BigNumber Error] CRYPTO not true or false: {v}'
                // '[BigNumber Error] crypto unavailable'
                if (obj.hasOwnProperty(p = 'CRYPTO')) {
                    v = obj[p];
                    if (v === !!v) {
                        if (v) {
                            if (typeof crypto != 'undefined' && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                                CRYPTO = v;
                            } else {
                                CRYPTO = !v;
                                throw Error(bignumberError + 'crypto unavailable');
                            }
                        } else {
                            CRYPTO = v;
                        }
                    } else {
                        throw Error(bignumberError + p + ' not true or false: ' + v);
                    }
                }
                // MODULO_MODE {number} Integer, 0 to 9 inclusive.
                // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
                if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
                    v = obj[p];
                    intCheck(v, 0, 9, p);
                    MODULO_MODE = v;
                }
                // POW_PRECISION {number} Integer, 0 to MAX inclusive.
                // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
                if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
                    v = obj[p];
                    intCheck(v, 0, MAX, p);
                    POW_PRECISION = v;
                }
                // FORMAT {object}
                // '[BigNumber Error] FORMAT not an object: {v}'
                if (obj.hasOwnProperty(p = 'FORMAT')) {
                    v = obj[p];
                    if (typeof v == 'object') FORMAT = v;
                    else throw Error(bignumberError + p + ' not an object: ' + v);
                }
                // ALPHABET {string}
                // '[BigNumber Error] ALPHABET invalid: {v}'
                if (obj.hasOwnProperty(p = 'ALPHABET')) {
                    v = obj[p];
                    // Disallow if less than two characters,
                    // or if it contains '+', '-', '.', whitespace, or a repeated character.
                    if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                        alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';
                        ALPHABET = v;
                    } else {
                        throw Error(bignumberError + p + ' invalid: ' + v);
                    }
                }
            } else {
                // '[BigNumber Error] Object expected: {v}'
                throw Error(bignumberError + 'Object expected: ' + obj);
            }
        }
        return {
            DECIMAL_PLACES: DECIMAL_PLACES,
            ROUNDING_MODE: ROUNDING_MODE,
            EXPONENTIAL_AT: [
                TO_EXP_NEG,
                TO_EXP_POS
            ],
            RANGE: [
                MIN_EXP,
                MAX_EXP
            ],
            CRYPTO: CRYPTO,
            MODULO_MODE: MODULO_MODE,
            POW_PRECISION: POW_PRECISION,
            FORMAT: FORMAT,
            ALPHABET: ALPHABET
        };
    };
    /*
   * Return true if v is a BigNumber instance, otherwise return false.
   *
   * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
   *
   * v {any}
   *
   * '[BigNumber Error] Invalid BigNumber: {v}'
   */ BigNumber.isBigNumber = function(v) {
        if (!v || v._isBigNumber !== true) return false;
        if (!BigNumber.DEBUG) return true;
        var i, n, c = v.c, e = v.e, s = v.s;
        out: if (({}).toString.call(c) == '[object Array]') {
            if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
                // If the first element is zero, the BigNumber value must be zero.
                if (c[0] === 0) {
                    if (e === 0 && c.length === 1) return true;
                    break out;
                }
                // Calculate number of digits that c[0] should have, based on the exponent.
                i = (e + 1) % LOG_BASE;
                if (i < 1) i += LOG_BASE;
                // Calculate number of digits of c[0].
                //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
                if (String(c[0]).length == i) {
                    for(i = 0; i < c.length; i++){
                        n = c[i];
                        if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
                    }
                    // Last element cannot be zero, unless it is the only element.
                    if (n !== 0) return true;
                }
            }
        // Infinity/NaN
        } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
            return true;
        }
        throw Error(bignumberError + 'Invalid BigNumber: ' + v);
    };
    /*
   * Return a new BigNumber whose value is the maximum of the arguments.
   *
   * arguments {number|string|BigNumber}
   */ BigNumber.maximum = BigNumber.max = function() {
        return maxOrMin(arguments, -1);
    };
    /*
   * Return a new BigNumber whose value is the minimum of the arguments.
   *
   * arguments {number|string|BigNumber}
   */ BigNumber.minimum = BigNumber.min = function() {
        return maxOrMin(arguments, 1);
    };
    /*
   * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
   * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
   * zeros are produced).
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
   * '[BigNumber Error] crypto unavailable'
   */ BigNumber.random = function() {
        var pow2_53 = 0x20000000000000;
        // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
        // Check if Math.random() produces more than 32 bits of randomness.
        // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
        // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
        var random53bitInt = Math.random() * pow2_53 & 0x1fffff ? function() {
            return mathfloor(Math.random() * pow2_53);
        } : function() {
            return (Math.random() * 0x40000000 | 0) * 0x800000 + (Math.random() * 0x800000 | 0);
        };
        return function(dp) {
            var a, b, e, k, v, i = 0, c = [], rand = new BigNumber(ONE);
            if (dp == null) dp = DECIMAL_PLACES;
            else intCheck(dp, 0, MAX);
            k = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
                // Browsers supporting crypto.getRandomValues.
                if (crypto.getRandomValues) {
                    a = crypto.getRandomValues(new Uint32Array(k *= 2));
                    for(; i < k;){
                        // 53 bits:
                        // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
                        // 11111 11111111 11111111 11111111 11100000 00000000 00000000
                        // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
                        //                                     11111 11111111 11111111
                        // 0x20000 is 2^21.
                        v = a[i] * 0x20000 + (a[i + 1] >>> 11);
                        // Rejection sampling:
                        // 0 <= v < 9007199254740992
                        // Probability that v >= 9e15, is
                        // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
                        if (v >= 9e15) {
                            b = crypto.getRandomValues(new Uint32Array(2));
                            a[i] = b[0];
                            a[i + 1] = b[1];
                        } else {
                            // 0 <= v <= 8999999999999999
                            // 0 <= (v % 1e14) <= 99999999999999
                            c.push(v % 1e14);
                            i += 2;
                        }
                    }
                    i = k / 2;
                // Node.js supporting crypto.randomBytes.
                } else if (crypto.randomBytes) {
                    // buffer
                    a = crypto.randomBytes(k *= 7);
                    for(; i < k;){
                        // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
                        // 0x100000000 is 2^32, 0x1000000 is 2^24
                        // 11111 11111111 11111111 11111111 11111111 11111111 11111111
                        // 0 <= v < 9007199254740992
                        v = (a[i] & 31) * 0x1000000000000 + a[i + 1] * 0x10000000000 + a[i + 2] * 0x100000000 + a[i + 3] * 0x1000000 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                        if (v >= 9e15) {
                            crypto.randomBytes(7).copy(a, i);
                        } else {
                            // 0 <= (v % 1e14) <= 99999999999999
                            c.push(v % 1e14);
                            i += 7;
                        }
                    }
                    i = k / 7;
                } else {
                    CRYPTO = false;
                    throw Error(bignumberError + 'crypto unavailable');
                }
            }
            // Use Math.random.
            if (!CRYPTO) {
                for(; i < k;){
                    v = random53bitInt();
                    if (v < 9e15) c[i++] = v % 1e14;
                }
            }
            k = c[--i];
            dp %= LOG_BASE;
            // Convert trailing digits to zeros according to dp.
            if (k && dp) {
                v = POWS_TEN[LOG_BASE - dp];
                c[i] = mathfloor(k / v) * v;
            }
            // Remove trailing elements which are zero.
            for(; c[i] === 0; c.pop(), i--);
            // Zero?
            if (i < 0) {
                c = [
                    e = 0
                ];
            } else {
                // Remove leading elements which are zero and adjust exponent accordingly.
                for(e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);
                // Count the digits of the first element of c to determine leading zeros, and...
                for(i = 1, v = c[0]; v >= 10; v /= 10, i++);
                // adjust the exponent accordingly.
                if (i < LOG_BASE) e -= LOG_BASE - i;
            }
            rand.e = e;
            rand.c = c;
            return rand;
        };
    }();
    /*
   * Return a BigNumber whose value is the sum of the arguments.
   *
   * arguments {number|string|BigNumber}
   */ BigNumber.sum = function() {
        var i = 1, args = arguments, sum = new BigNumber(args[0]);
        for(; i < args.length;)sum = sum.plus(args[i++]);
        return sum;
    };
    // PRIVATE FUNCTIONS
    // Called by BigNumber and BigNumber.prototype.toString.
    convertBase = function() {
        var decimal = '0123456789';
        /*
     * Convert string of baseIn to an array of numbers of baseOut.
     * Eg. toBaseOut('255', 10, 16) returns [15, 15].
     * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
     */ function toBaseOut(str, baseIn, baseOut, alphabet) {
            var j, arr = [
                0
            ], arrL, i = 0, len = str.length;
            for(; i < len;){
                for(arrL = arr.length; arrL--; arr[arrL] *= baseIn);
                arr[0] += alphabet.indexOf(str.charAt(i++));
                for(j = 0; j < arr.length; j++){
                    if (arr[j] > baseOut - 1) {
                        if (arr[j + 1] == null) arr[j + 1] = 0;
                        arr[j + 1] += arr[j] / baseOut | 0;
                        arr[j] %= baseOut;
                    }
                }
            }
            return arr.reverse();
        }
        // Convert a numeric string of baseIn to a numeric string of baseOut.
        // If the caller is toString, we are converting from base 10 to baseOut.
        // If the caller is BigNumber, we are converting from baseIn to base 10.
        return function(str, baseIn, baseOut, sign, callerIsToString) {
            var alphabet, d, e, k, r, x, xc, y, i = str.indexOf('.'), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            // Non-integer.
            if (i >= 0) {
                k = POW_PRECISION;
                // Unlimited precision.
                POW_PRECISION = 0;
                str = str.replace('.', '');
                y = new BigNumber(baseIn);
                x = y.pow(str.length - i);
                POW_PRECISION = k;
                // Convert str as if an integer, then restore the fraction part by dividing the
                // result by its base raised to a power.
                y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'), 10, baseOut, decimal);
                y.e = y.c.length;
            }
            // Convert the number as integer.
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
            // xc now represents str as an integer and converted to baseOut. e is the exponent.
            e = k = xc.length;
            // Remove trailing zeros.
            for(; xc[--k] == 0; xc.pop());
            // Zero?
            if (!xc[0]) return alphabet.charAt(0);
            // Does str represent an integer? If so, no need for the division.
            if (i < 0) {
                --e;
            } else {
                x.c = xc;
                x.e = e;
                // The sign is needed for correct rounding.
                x.s = sign;
                x = div(x, y, dp, rm, baseOut);
                xc = x.c;
                r = x.r;
                e = x.e;
            }
            // xc now represents str converted to baseOut.
            // THe index of the rounding digit.
            d = e + dp + 1;
            // The rounding digit: the digit to the right of the digit that may be rounded up.
            i = xc[d];
            // Look at the rounding digits and mode to determine whether to round up.
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;
            r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
            // If the index of the rounding digit is not greater than zero, or xc represents
            // zero, then the result of the base conversion is zero or, if rounding up, a value
            // such as 0.00001.
            if (d < 1 || !xc[0]) {
                // 1^-dp or 0
                str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
            } else {
                // Truncate xc to the required number of decimal places.
                xc.length = d;
                // Round up?
                if (r) {
                    // Rounding up may mean the previous digit has to be rounded up and so on.
                    for(--baseOut; ++xc[--d] > baseOut;){
                        xc[d] = 0;
                        if (!d) {
                            ++e;
                            xc = [
                                1
                            ].concat(xc);
                        }
                    }
                }
                // Determine trailing zeros.
                for(k = xc.length; !xc[--k];);
                // E.g. [4, 11, 15] becomes 4bf.
                for(i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));
                // Add leading zeros, decimal point and trailing zeros as required.
                str = toFixedPoint(str, e, alphabet.charAt(0));
            }
            // The caller will add the sign.
            return str;
        };
    }();
    // Perform division in the specified base. Called by div and convertBase.
    div = function() {
        // Assume non-zero x and k.
        function multiply(x, k, base) {
            var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
            for(x = x.slice(); i--;){
                xlo = x[i] % SQRT_BASE;
                xhi = x[i] / SQRT_BASE | 0;
                m = khi * xlo + xhi * klo;
                temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
                carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
                x[i] = temp % base;
            }
            if (carry) x = [
                carry
            ].concat(x);
            return x;
        }
        function compare(a, b, aL, bL) {
            var i, cmp;
            if (aL != bL) {
                cmp = aL > bL ? 1 : -1;
            } else {
                for(i = cmp = 0; i < aL; i++){
                    if (a[i] != b[i]) {
                        cmp = a[i] > b[i] ? 1 : -1;
                        break;
                    }
                }
            }
            return cmp;
        }
        function subtract(a, b, aL, base) {
            var i = 0;
            // Subtract b from a.
            for(; aL--;){
                a[aL] -= i;
                i = a[aL] < b[aL] ? 1 : 0;
                a[aL] = i * base + a[aL] - b[aL];
            }
            // Remove leading zeros.
            for(; !a[0] && a.length > 1; a.splice(0, 1));
        }
        // x: dividend, y: divisor.
        return function(x, y, dp, rm, base) {
            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
            // Either NaN, Infinity or 0?
            if (!xc || !xc[0] || !yc || !yc[0]) {
                return new BigNumber(// Return NaN if either NaN, or both Infinity or 0.
                !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                xc && xc[0] == 0 || !yc ? s * 0 : s / 0);
            }
            q = new BigNumber(s);
            qc = q.c = [];
            e = x.e - y.e;
            s = dp + e + 1;
            if (!base) {
                base = BASE;
                e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
                s = s / LOG_BASE | 0;
            }
            // Result exponent may be one less then the current value of e.
            // The coefficients of the BigNumbers from convertBase may have trailing zeros.
            for(i = 0; yc[i] == (xc[i] || 0); i++);
            if (yc[i] > (xc[i] || 0)) e--;
            if (s < 0) {
                qc.push(1);
                more = true;
            } else {
                xL = xc.length;
                yL = yc.length;
                i = 0;
                s += 2;
                // Normalise xc and yc so highest order digit of yc is >= base / 2.
                n = mathfloor(base / (yc[0] + 1));
                // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
                // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
                if (n > 1) {
                    yc = multiply(yc, n, base);
                    xc = multiply(xc, n, base);
                    yL = yc.length;
                    xL = xc.length;
                }
                xi = yL;
                rem = xc.slice(0, yL);
                remL = rem.length;
                // Add zeros to make remainder as long as divisor.
                for(; remL < yL; rem[remL++] = 0);
                yz = yc.slice();
                yz = [
                    0
                ].concat(yz);
                yc0 = yc[0];
                if (yc[1] >= base / 2) yc0++;
                // Not necessary, but to prevent trial digit n > base, when using base 3.
                // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;
                do {
                    n = 0;
                    // Compare divisor and remainder.
                    cmp = compare(yc, rem, yL, remL);
                    // If divisor < remainder.
                    if (cmp < 0) {
                        // Calculate trial digit, n.
                        rem0 = rem[0];
                        if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
                        // n is how many times the divisor goes into the current remainder.
                        n = mathfloor(rem0 / yc0);
                        //  Algorithm:
                        //  product = divisor multiplied by trial digit (n).
                        //  Compare product and remainder.
                        //  If product is greater than remainder:
                        //    Subtract divisor from product, decrement trial digit.
                        //  Subtract product from remainder.
                        //  If product was less than remainder at the last compare:
                        //    Compare new remainder and divisor.
                        //    If remainder is greater than divisor:
                        //      Subtract divisor from remainder, increment trial digit.
                        if (n > 1) {
                            // n may be > base only when base is 3.
                            if (n >= base) n = base - 1;
                            // product = divisor * trial digit.
                            prod = multiply(yc, n, base);
                            prodL = prod.length;
                            remL = rem.length;
                            // Compare product and remainder.
                            // If product > remainder then trial digit n too high.
                            // n is 1 too high about 5% of the time, and is not known to have
                            // ever been more than 1 too high.
                            while(compare(prod, rem, prodL, remL) == 1){
                                n--;
                                // Subtract divisor from product.
                                subtract(prod, yL < prodL ? yz : yc, prodL, base);
                                prodL = prod.length;
                                cmp = 1;
                            }
                        } else {
                            // n is 0 or 1, cmp is -1.
                            // If n is 0, there is no need to compare yc and rem again below,
                            // so change cmp to 1 to avoid it.
                            // If n is 1, leave cmp as -1, so yc and rem are compared again.
                            if (n == 0) {
                                // divisor < remainder, so n must be at least 1.
                                cmp = n = 1;
                            }
                            // product = divisor
                            prod = yc.slice();
                            prodL = prod.length;
                        }
                        if (prodL < remL) prod = [
                            0
                        ].concat(prod);
                        // Subtract product from remainder.
                        subtract(rem, prod, remL, base);
                        remL = rem.length;
                        // If product was < remainder.
                        if (cmp == -1) {
                            // Compare divisor and new remainder.
                            // If divisor < new remainder, subtract divisor from remainder.
                            // Trial digit n too low.
                            // n is 1 too low about 5% of the time, and very rarely 2 too low.
                            while(compare(yc, rem, yL, remL) < 1){
                                n++;
                                // Subtract divisor from remainder.
                                subtract(rem, yL < remL ? yz : yc, remL, base);
                                remL = rem.length;
                            }
                        }
                    } else if (cmp === 0) {
                        n++;
                        rem = [
                            0
                        ];
                    } // else cmp === 1 and n will be 0
                    // Add the next digit, n, to the result array.
                    qc[i++] = n;
                    // Update the remainder.
                    if (rem[0]) {
                        rem[remL++] = xc[xi] || 0;
                    } else {
                        rem = [
                            xc[xi]
                        ];
                        remL = 1;
                    }
                }while ((xi++ < xL || rem[0] != null) && s--)
                more = rem[0] != null;
                // Leading zero?
                if (!qc[0]) qc.splice(0, 1);
            }
            if (base == BASE) {
                // To calculate q.e, first get the number of digits of qc[0].
                for(i = 1, s = qc[0]; s >= 10; s /= 10, i++);
                round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
            // Caller is convertBase.
            } else {
                q.e = e;
                q.r = +more;
            }
            return q;
        };
    }();
    /*
   * Return a string representing the value of BigNumber n in fixed-point or exponential
   * notation rounded to the specified decimal places or significant digits.
   *
   * n: a BigNumber.
   * i: the index of the last digit required (i.e. the digit that may be rounded up).
   * rm: the rounding mode.
   * id: 1 (toExponential) or 2 (toPrecision).
   */ function format(n, i, rm, id) {
        var c0, e, ne, len, str;
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);
        if (!n.c) return n.toString();
        c0 = n.c[0];
        ne = n.e;
        if (i == null) {
            str = coeffToString(n.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, '0');
        } else {
            n = round(new BigNumber(n), i, rm);
            // n.e may have changed if the value was rounded up.
            e = n.e;
            str = coeffToString(n.c);
            len = str.length;
            // toPrecision returns exponential notation if the number of significant digits
            // specified is less than the number of digits necessary to represent the integer
            // part of the value in fixed-point notation.
            // Exponential notation.
            if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
                // Append zeros?
                for(; len < i; str += '0', len++);
                str = toExponential(str, e);
            // Fixed-point notation.
            } else {
                i -= ne;
                str = toFixedPoint(str, e, '0');
                // Append zeros?
                if (e + 1 > len) {
                    if (--i > 0) for(str += '.'; i--; str += '0');
                } else {
                    i += e - len;
                    if (i > 0) {
                        if (e + 1 == len) str += '.';
                        for(; i--; str += '0');
                    }
                }
            }
        }
        return n.s < 0 && c0 ? '-' + str : str;
    }
    // Handle BigNumber.max and BigNumber.min.
    // If any number is NaN, return NaN.
    function maxOrMin(args, n) {
        var k, y, i = 1, x = new BigNumber(args[0]);
        for(; i < args.length; i++){
            y = new BigNumber(args[i]);
            if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
                x = y;
            }
        }
        return x;
    }
    /*
   * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
   * Called by minus, plus and times.
   */ function normalise(n, c, e) {
        var i = 1, j = c.length;
        // Remove trailing zeros.
        for(; !c[--j]; c.pop());
        // Calculate the base 10 exponent. First get the number of digits of c[0].
        for(j = c[0]; j >= 10; j /= 10, i++);
        // Overflow?
        if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
            // Infinity.
            n.c = n.e = null;
        // Underflow?
        } else if (e < MIN_EXP) {
            // Zero.
            n.c = [
                n.e = 0
            ];
        } else {
            n.e = e;
            n.c = c;
        }
        return n;
    }
    // Handle values that fail the validity test in BigNumber.
    parseNumeric = function() {
        var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function(x, str, isNum, b) {
            var base, s = isNum ? str : str.replace(whitespaceOrPlus, '');
            // No exception on Infinity or NaN.
            if (isInfinityOrNaN.test(s)) {
                x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
            } else {
                if (!isNum) {
                    // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
                    s = s.replace(basePrefix, function(m, p1, p2) {
                        base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
                        return !b || b == base ? p1 : m;
                    });
                    if (b) {
                        base = b;
                        // E.g. '1.' to '1', '.1' to '0.1'
                        s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
                    }
                    if (str != s) return new BigNumber(s, base);
                }
                // '[BigNumber Error] Not a number: {n}'
                // '[BigNumber Error] Not a base {b} number: {n}'
                if (BigNumber.DEBUG) {
                    throw Error(bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
                }
                // NaN
                x.s = null;
            }
            x.c = x.e = null;
        };
    }();
    /*
   * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
   * If r is truthy, it is known that there are more digits after the rounding digit.
   */ function round(x, sd, rm, r) {
        var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
        // if x is not Infinity or NaN...
        if (xc) {
            // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
            // n is a base 1e14 number, the value of the element of array x.c containing rd.
            // ni is the index of n within x.c.
            // d is the number of digits of n.
            // i is the index of rd within n including leading zeros.
            // j is the actual index of rd within n (if < 0, rd is a leading zero).
            out: {
                // Get the number of digits of the first element of xc.
                for(d = 1, k = xc[0]; k >= 10; k /= 10, d++);
                i = sd - d;
                // If the rounding digit is in the first element of xc...
                if (i < 0) {
                    i += LOG_BASE;
                    j = sd;
                    n = xc[ni = 0];
                    // Get the rounding digit at index j of n.
                    rd = mathfloor(n / pows10[d - j - 1] % 10);
                } else {
                    ni = mathceil((i + 1) / LOG_BASE);
                    if (ni >= xc.length) {
                        if (r) {
                            // Needed by sqrt.
                            for(; xc.length <= ni; xc.push(0));
                            n = rd = 0;
                            d = 1;
                            i %= LOG_BASE;
                            j = i - LOG_BASE + 1;
                        } else {
                            break out;
                        }
                    } else {
                        n = k = xc[ni];
                        // Get the number of digits of n.
                        for(d = 1; k >= 10; k /= 10, d++);
                        // Get the index of rd within n.
                        i %= LOG_BASE;
                        // Get the index of rd within n, adjusted for leading zeros.
                        // The number of leading zeros of n is given by LOG_BASE - d.
                        j = i - LOG_BASE + d;
                        // Get the rounding digit at index j of n.
                        rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
                    }
                }
                r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
                // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
                // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
                xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
                r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
                (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
                if (sd < 1 || !xc[0]) {
                    xc.length = 0;
                    if (r) {
                        // Convert sd to decimal places.
                        sd -= x.e + 1;
                        // 1, 0.1, 0.01, 0.001, 0.0001 etc.
                        xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                        x.e = -sd || 0;
                    } else {
                        // Zero.
                        xc[0] = x.e = 0;
                    }
                    return x;
                }
                // Remove excess digits.
                if (i == 0) {
                    xc.length = ni;
                    k = 1;
                    ni--;
                } else {
                    xc.length = ni + 1;
                    k = pows10[LOG_BASE - i];
                    // E.g. 56700 becomes 56000 if 7 is the rounding digit.
                    // j > 0 means i > number of leading zeros of n.
                    xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
                }
                // Round up?
                if (r) {
                    for(;;){
                        // If the digit to be rounded up is in the first element of xc...
                        if (ni == 0) {
                            // i will be the length of xc[0] before k is added.
                            for(i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                            j = xc[0] += k;
                            for(k = 1; j >= 10; j /= 10, k++);
                            // if i != k the length has increased.
                            if (i != k) {
                                x.e++;
                                if (xc[0] == BASE) xc[0] = 1;
                            }
                            break;
                        } else {
                            xc[ni] += k;
                            if (xc[ni] != BASE) break;
                            xc[ni--] = 0;
                            k = 1;
                        }
                    }
                }
                // Remove trailing zeros.
                for(i = xc.length; xc[--i] === 0; xc.pop());
            }
            // Overflow? Infinity.
            if (x.e > MAX_EXP) {
                x.c = x.e = null;
            // Underflow? Zero.
            } else if (x.e < MIN_EXP) {
                x.c = [
                    x.e = 0
                ];
            }
        }
        return x;
    }
    function valueOf(n) {
        var str, e = n.e;
        if (e === null) return n.toString();
        str = coeffToString(n.c);
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, '0');
        return n.s < 0 ? '-' + str : str;
    }
    // PROTOTYPE/INSTANCE METHODS
    /*
   * Return a new BigNumber whose value is the absolute value of this BigNumber.
   */ P.absoluteValue = P.abs = function() {
        var x = new BigNumber(this);
        if (x.s < 0) x.s = 1;
        return x;
    };
    /*
   * Return
   *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
   *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
   *   0 if they have the same value,
   *   or null if the value of either is NaN.
   */ P.comparedTo = function(y, b) {
        return compare(this, new BigNumber(y, b));
    };
    /*
   * If dp is undefined or null or true or false, return the number of decimal places of the
   * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
   *
   * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
   * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
   * ROUNDING_MODE if rm is omitted.
   *
   * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
   */ P.decimalPlaces = P.dp = function(dp, rm) {
        var c, n, v, x = this;
        if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber(x), dp + x.e + 1, rm);
        }
        if (!(c = x.c)) return null;
        n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
        // Subtract the number of trailing zeros of the last number.
        if (v = c[v]) for(; v % 10 == 0; v /= 10, n--);
        if (n < 0) n = 0;
        return n;
    };
    /*
   *  n / 0 = I
   *  n / N = N
   *  n / I = 0
   *  0 / n = 0
   *  0 / 0 = N
   *  0 / N = N
   *  0 / I = 0
   *  N / n = N
   *  N / 0 = N
   *  N / N = N
   *  N / I = N
   *  I / n = I
   *  I / 0 = I
   *  I / N = N
   *  I / I = N
   *
   * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
   * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
   */ P.dividedBy = P.div = function(y, b) {
        return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };
    /*
   * Return a new BigNumber whose value is the integer part of dividing the value of this
   * BigNumber by the value of BigNumber(y, b).
   */ P.dividedToIntegerBy = P.idiv = function(y, b) {
        return div(this, new BigNumber(y, b), 0, 1);
    };
    /*
   * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
   *
   * If m is present, return the result modulo m.
   * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
   * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
   *
   * The modular power operation works efficiently when x, n, and m are integers, otherwise it
   * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
   *
   * n {number|string|BigNumber} The exponent. An integer.
   * [m] {number|string|BigNumber} The modulus.
   *
   * '[BigNumber Error] Exponent not an integer: {n}'
   */ P.exponentiatedBy = P.pow = function(n, m) {
        var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
        n = new BigNumber(n);
        // Allow NaN and Infinity, but not other non-integers.
        if (n.c && !n.isInteger()) {
            throw Error(bignumberError + 'Exponent not an integer: ' + valueOf(n));
        }
        if (m != null) m = new BigNumber(m);
        // Exponent of MAX_SAFE_INTEGER is 15.
        nIsBig = n.e > 14;
        // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.
        if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
            // The sign of the result of pow when x is negative depends on the evenness of n.
            // If +n overflows to Infinity, the evenness of n would be not be known.
            y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
            return m ? y.mod(m) : y;
        }
        nIsNeg = n.s < 0;
        if (m) {
            // x % m returns NaN if abs(m) is zero, or m is NaN.
            if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);
            isModExp = !nIsNeg && x.isInteger() && m.isInteger();
            if (isModExp) x = x.mod(m);
        // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.
        // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.
        } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
            // If x is negative and n is odd, k = -0, else k = 0.
            k = x.s < 0 && isOdd(n) ? -0 : 0;
            // If x >= 1, k = Infinity.
            if (x.e > -1) k = 1 / k;
            // If n is negative return 0, else return Infinity.
            return new BigNumber(nIsNeg ? 1 / k : k);
        } else if (POW_PRECISION) {
            // Truncating each coefficient array to a length of k after each multiplication
            // equates to truncating significant digits to POW_PRECISION + [28, 41],
            // i.e. there will be a minimum of 28 guard digits retained.
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
        }
        if (nIsBig) {
            half = new BigNumber(0.5);
            if (nIsNeg) n.s = 1;
            nIsOdd = isOdd(n);
        } else {
            i = Math.abs(+valueOf(n));
            nIsOdd = i % 2;
        }
        y = new BigNumber(ONE);
        // Performs 54 loop iterations for n of 9007199254740991.
        for(;;){
            if (nIsOdd) {
                y = y.times(x);
                if (!y.c) break;
                if (k) {
                    if (y.c.length > k) y.c.length = k;
                } else if (isModExp) {
                    y = y.mod(m); //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
                }
            }
            if (i) {
                i = mathfloor(i / 2);
                if (i === 0) break;
                nIsOdd = i % 2;
            } else {
                n = n.times(half);
                round(n, n.e + 1, 1);
                if (n.e > 14) {
                    nIsOdd = isOdd(n);
                } else {
                    i = +valueOf(n);
                    if (i === 0) break;
                    nIsOdd = i % 2;
                }
            }
            x = x.times(x);
            if (k) {
                if (x.c && x.c.length > k) x.c.length = k;
            } else if (isModExp) {
                x = x.mod(m); //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
            }
        }
        if (isModExp) return y;
        if (nIsNeg) y = ONE.div(y);
        return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };
    /*
   * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
   * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
   *
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
   */ P.integerValue = function(rm) {
        var n = new BigNumber(this);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);
        return round(n, n.e + 1, rm);
    };
    /*
   * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
   * otherwise return false.
   */ P.isEqualTo = P.eq = function(y, b) {
        return compare(this, new BigNumber(y, b)) === 0;
    };
    /*
   * Return true if the value of this BigNumber is a finite number, otherwise return false.
   */ P.isFinite = function() {
        return !!this.c;
    };
    /*
   * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
   * otherwise return false.
   */ P.isGreaterThan = P.gt = function(y, b) {
        return compare(this, new BigNumber(y, b)) > 0;
    };
    /*
   * Return true if the value of this BigNumber is greater than or equal to the value of
   * BigNumber(y, b), otherwise return false.
   */ P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
        return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;
    };
    /*
   * Return true if the value of this BigNumber is an integer, otherwise return false.
   */ P.isInteger = function() {
        return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };
    /*
   * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
   * otherwise return false.
   */ P.isLessThan = P.lt = function(y, b) {
        return compare(this, new BigNumber(y, b)) < 0;
    };
    /*
   * Return true if the value of this BigNumber is less than or equal to the value of
   * BigNumber(y, b), otherwise return false.
   */ P.isLessThanOrEqualTo = P.lte = function(y, b) {
        return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
    };
    /*
   * Return true if the value of this BigNumber is NaN, otherwise return false.
   */ P.isNaN = function() {
        return !this.s;
    };
    /*
   * Return true if the value of this BigNumber is negative, otherwise return false.
   */ P.isNegative = function() {
        return this.s < 0;
    };
    /*
   * Return true if the value of this BigNumber is positive, otherwise return false.
   */ P.isPositive = function() {
        return this.s > 0;
    };
    /*
   * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
   */ P.isZero = function() {
        return !!this.c && this.c[0] == 0;
    };
    /*
   *  n - 0 = n
   *  n - N = N
   *  n - I = -I
   *  0 - n = -n
   *  0 - 0 = 0
   *  0 - N = N
   *  0 - I = -I
   *  N - n = N
   *  N - 0 = N
   *  N - N = N
   *  N - I = N
   *  I - n = I
   *  I - 0 = I
   *  I - N = N
   *  I - I = N
   *
   * Return a new BigNumber whose value is the value of this BigNumber minus the value of
   * BigNumber(y, b).
   */ P.minus = function(y, b) {
        var i, j, t, xLTy, x = this, a = x.s;
        y = new BigNumber(y, b);
        b = y.s;
        // Either NaN?
        if (!a || !b) return new BigNumber(NaN);
        // Signs differ?
        if (a != b) {
            y.s = -b;
            return x.plus(y);
        }
        var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
        if (!xe || !ye) {
            // Either Infinity?
            if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);
            // Either zero?
            if (!xc[0] || !yc[0]) {
                // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x : // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0);
            }
        }
        xe = bitFloor(xe);
        ye = bitFloor(ye);
        xc = xc.slice();
        // Determine which is the bigger number.
        if (a = xe - ye) {
            if (xLTy = a < 0) {
                a = -a;
                t = xc;
            } else {
                ye = xe;
                t = yc;
            }
            t.reverse();
            // Prepend zeros to equalise exponents.
            for(b = a; b--; t.push(0));
            t.reverse();
        } else {
            // Exponents equal. Check digit by digit.
            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
            for(a = b = 0; b < j; b++){
                if (xc[b] != yc[b]) {
                    xLTy = xc[b] < yc[b];
                    break;
                }
            }
        }
        // x < y? Point xc to the array of the bigger number.
        if (xLTy) {
            t = xc;
            xc = yc;
            yc = t;
            y.s = -y.s;
        }
        b = (j = yc.length) - (i = xc.length);
        // Append zeros to xc if shorter.
        // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
        if (b > 0) for(; b--; xc[i++] = 0);
        b = BASE - 1;
        // Subtract yc from xc.
        for(; j > a;){
            if (xc[--j] < yc[j]) {
                for(i = j; i && !xc[--i]; xc[i] = b);
                --xc[i];
                xc[j] += BASE;
            }
            xc[j] -= yc[j];
        }
        // Remove leading zeros and adjust exponent accordingly.
        for(; xc[0] == 0; xc.splice(0, 1), --ye);
        // Zero?
        if (!xc[0]) {
            // Following IEEE 754 (2008) 6.3,
            // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [
                y.e = 0
            ];
            return y;
        }
        // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
        // for finite x and y.
        return normalise(y, xc, ye);
    };
    /*
   *   n % 0 =  N
   *   n % N =  N
   *   n % I =  n
   *   0 % n =  0
   *  -0 % n = -0
   *   0 % 0 =  N
   *   0 % N =  N
   *   0 % I =  0
   *   N % n =  N
   *   N % 0 =  N
   *   N % N =  N
   *   N % I =  N
   *   I % n =  N
   *   I % 0 =  N
   *   I % N =  N
   *   I % I =  N
   *
   * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
   * BigNumber(y, b). The result depends on the value of MODULO_MODE.
   */ P.modulo = P.mod = function(y, b) {
        var q, s, x = this;
        y = new BigNumber(y, b);
        // Return NaN if x is Infinity or NaN, or y is NaN or zero.
        if (!x.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber(NaN);
        // Return x if y is Infinity or x is zero.
        } else if (!y.c || x.c && !x.c[0]) {
            return new BigNumber(x);
        }
        if (MODULO_MODE == 9) {
            // Euclidian division: q = sign(y) * floor(x / abs(y))
            // r = x - qy    where  0 <= r < abs(y)
            s = y.s;
            y.s = 1;
            q = div(x, y, 0, 3);
            y.s = s;
            q.s *= s;
        } else {
            q = div(x, y, 0, MODULO_MODE);
        }
        y = x.minus(q.times(y));
        // To match JavaScript %, ensure sign of zero is sign of dividend.
        if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
        return y;
    };
    /*
   *  n * 0 = 0
   *  n * N = N
   *  n * I = I
   *  0 * n = 0
   *  0 * 0 = 0
   *  0 * N = N
   *  0 * I = N
   *  N * n = N
   *  N * 0 = N
   *  N * N = N
   *  N * I = N
   *  I * n = I
   *  I * 0 = N
   *  I * N = N
   *  I * I = I
   *
   * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
   * of BigNumber(y, b).
   */ P.multipliedBy = P.times = function(y, b) {
        var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber(y, b)).c;
        // Either NaN, Infinity or 0?
        if (!xc || !yc || !xc[0] || !yc[0]) {
            // Return NaN if either is NaN, or one is 0 and the other is Infinity.
            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
                y.c = y.e = y.s = null;
            } else {
                y.s *= x.s;
                // Return Infinity if either is Infinity.
                if (!xc || !yc) {
                    y.c = y.e = null;
                // Return 0 if either is 0.
                } else {
                    y.c = [
                        0
                    ];
                    y.e = 0;
                }
            }
            return y;
        }
        e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
        y.s *= x.s;
        xcL = xc.length;
        ycL = yc.length;
        // Ensure xc points to longer array and xcL to its length.
        if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i = xcL;
            xcL = ycL;
            ycL = i;
        }
        // Initialise the result array with zeros.
        for(i = xcL + ycL, zc = []; i--; zc.push(0));
        base = BASE;
        sqrtBase = SQRT_BASE;
        for(i = ycL; --i >= 0;){
            c = 0;
            ylo = yc[i] % sqrtBase;
            yhi = yc[i] / sqrtBase | 0;
            for(k = xcL, j = i + k; j > i;){
                xlo = xc[--k] % sqrtBase;
                xhi = xc[k] / sqrtBase | 0;
                m = yhi * xlo + xhi * ylo;
                xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
                c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
                zc[j--] = xlo % base;
            }
            zc[j] = c;
        }
        if (c) {
            ++e;
        } else {
            zc.splice(0, 1);
        }
        return normalise(y, zc, e);
    };
    /*
   * Return a new BigNumber whose value is the value of this BigNumber negated,
   * i.e. multiplied by -1.
   */ P.negated = function() {
        var x = new BigNumber(this);
        x.s = -x.s || null;
        return x;
    };
    /*
   *  n + 0 = n
   *  n + N = N
   *  n + I = I
   *  0 + n = n
   *  0 + 0 = 0
   *  0 + N = N
   *  0 + I = I
   *  N + n = N
   *  N + 0 = N
   *  N + N = N
   *  N + I = N
   *  I + n = I
   *  I + 0 = I
   *  I + N = N
   *  I + I = I
   *
   * Return a new BigNumber whose value is the value of this BigNumber plus the value of
   * BigNumber(y, b).
   */ P.plus = function(y, b) {
        var t, x = this, a = x.s;
        y = new BigNumber(y, b);
        b = y.s;
        // Either NaN?
        if (!a || !b) return new BigNumber(NaN);
        // Signs differ?
        if (a != b) {
            y.s = -b;
            return x.minus(y);
        }
        var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
        if (!xe || !ye) {
            // Return Infinity if either Infinity.
            if (!xc || !yc) return new BigNumber(a / 0);
            // Either zero?
            // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
            if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
        }
        xe = bitFloor(xe);
        ye = bitFloor(ye);
        xc = xc.slice();
        // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
        if (a = xe - ye) {
            if (a > 0) {
                ye = xe;
                t = yc;
            } else {
                a = -a;
                t = xc;
            }
            t.reverse();
            for(; a--; t.push(0));
            t.reverse();
        }
        a = xc.length;
        b = yc.length;
        // Point xc to the longer array, and b to the shorter length.
        if (a - b < 0) {
            t = yc;
            yc = xc;
            xc = t;
            b = a;
        }
        // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
        for(a = 0; b;){
            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
        }
        if (a) {
            xc = [
                a
            ].concat(xc);
            ++ye;
        }
        // No need to check for zero, as +x + +y != 0 && -x + -y != 0
        // ye = MAX_EXP + 1 possible
        return normalise(y, xc, ye);
    };
    /*
   * If sd is undefined or null or true or false, return the number of significant digits of
   * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
   * If sd is true include integer-part trailing zeros in the count.
   *
   * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
   * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
   * ROUNDING_MODE if rm is omitted.
   *
   * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
   *                     boolean: whether to count integer-part trailing zeros: true or false.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
   */ P.precision = P.sd = function(sd, rm) {
        var c, n, v, x = this;
        if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber(x), sd, rm);
        }
        if (!(c = x.c)) return null;
        v = c.length - 1;
        n = v * LOG_BASE + 1;
        if (v = c[v]) {
            // Subtract the number of trailing zeros of the last element.
            for(; v % 10 == 0; v /= 10, n--);
            // Add the number of digits of the first element.
            for(v = c[0]; v >= 10; v /= 10, n++);
        }
        if (sd && x.e + 1 > n) n = x.e + 1;
        return n;
    };
    /*
   * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
   * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
   *
   * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
   */ P.shiftedBy = function(k) {
        intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
        return this.times('1e' + k);
    };
    /*
   *  sqrt(-n) =  N
   *  sqrt(N) =  N
   *  sqrt(-I) =  N
   *  sqrt(I) =  I
   *  sqrt(0) =  0
   *  sqrt(-0) = -0
   *
   * Return a new BigNumber whose value is the square root of the value of this BigNumber,
   * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
   */ P.squareRoot = P.sqrt = function() {
        var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber('0.5');
        // Negative/NaN/Infinity/zero?
        if (s !== 1 || !c || !c[0]) {
            return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
        }
        // Initial estimate.
        s = Math.sqrt(+valueOf(x));
        // Math.sqrt underflow/overflow?
        // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
        if (s == 0 || s == 1 / 0) {
            n = coeffToString(c);
            if ((n.length + e) % 2 == 0) n += '0';
            s = Math.sqrt(+n);
            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
            if (s == 1 / 0) {
                n = '5e' + e;
            } else {
                n = s.toExponential();
                n = n.slice(0, n.indexOf('e') + 1) + e;
            }
            r = new BigNumber(n);
        } else {
            r = new BigNumber(s + '');
        }
        // Check for zero.
        // r could be zero if MIN_EXP is changed after the this value was created.
        // This would cause a division by zero (x/t) and hence Infinity below, which would cause
        // coeffToString to throw.
        if (r.c[0]) {
            e = r.e;
            s = e + dp;
            if (s < 3) s = 0;
            // Newton-Raphson iteration.
            for(;;){
                t = r;
                r = half.times(t.plus(div(x, t, dp, 1)));
                if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                    // The exponent of r may here be one less than the final result exponent,
                    // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
                    // are indexed correctly.
                    if (r.e < e) --s;
                    n = n.slice(s - 3, s + 1);
                    // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
                    // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
                    // iteration.
                    if (n == '9999' || !rep && n == '4999') {
                        // On the first iteration only, check to see if rounding up gives the
                        // exact result as the nines may infinitely repeat.
                        if (!rep) {
                            round(t, t.e + DECIMAL_PLACES + 2, 0);
                            if (t.times(t).eq(x)) {
                                r = t;
                                break;
                            }
                        }
                        dp += 4;
                        s += 4;
                        rep = 1;
                    } else {
                        // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
                        // result. If not, then there are further digits and m will be truthy.
                        if (!+n || !+n.slice(1) && n.charAt(0) == '5') {
                            // Truncate to the first rounding digit.
                            round(r, r.e + DECIMAL_PLACES + 2, 1);
                            m = !r.times(r).eq(x);
                        }
                        break;
                    }
                }
            }
        }
        return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };
    /*
   * Return a string representing the value of this BigNumber in exponential notation and
   * rounded using ROUNDING_MODE to dp fixed decimal places.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
   */ P.toExponential = function(dp, rm) {
        if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
        }
        return format(this, dp, rm, 1);
    };
    /*
   * Return a string representing the value of this BigNumber in fixed-point notation rounding
   * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
   *
   * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
   * but e.g. (-0.00001).toFixed(0) is '-0'.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
   */ P.toFixed = function(dp, rm) {
        if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
        }
        return format(this, dp, rm);
    };
    /*
   * Return a string representing the value of this BigNumber in fixed-point notation rounded
   * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
   * of the format or FORMAT object (see BigNumber.set).
   *
   * The formatting object may contain some or all of the properties shown below.
   *
   * FORMAT = {
   *   prefix: '',
   *   groupSize: 3,
   *   secondaryGroupSize: 0,
   *   groupSeparator: ',',
   *   decimalSeparator: '.',
   *   fractionGroupSize: 0,
   *   fractionGroupSeparator: '\xA0',      // non-breaking space
   *   suffix: ''
   * };
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   * [format] {object} Formatting options. See FORMAT pbject above.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
   * '[BigNumber Error] Argument not an object: {format}'
   */ P.toFormat = function(dp, rm, format) {
        var str, x = this;
        if (format == null) {
            if (dp != null && rm && typeof rm == 'object') {
                format = rm;
                rm = null;
            } else if (dp && typeof dp == 'object') {
                format = dp;
                dp = rm = null;
            } else {
                format = FORMAT;
            }
        } else if (typeof format != 'object') {
            throw Error(bignumberError + 'Argument not an object: ' + format);
        }
        str = x.toFixed(dp, rm);
        if (x.c) {
            var i, arr = str.split('.'), g1 = +format.groupSize, g2 = +format.secondaryGroupSize, groupSeparator = format.groupSeparator || '', intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2) {
                i = g1;
                g1 = g2;
                g2 = i;
                len -= i;
            }
            if (g1 > 0 && len > 0) {
                i = len % g1 || g1;
                intPart = intDigits.substr(0, i);
                for(; i < len; i += g1)intPart += groupSeparator + intDigits.substr(i, g1);
                if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
                if (isNeg) intPart = '-' + intPart;
            }
            str = fractionPart ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize) ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'), '$&' + (format.fractionGroupSeparator || '')) : fractionPart) : intPart;
        }
        return (format.prefix || '') + str + (format.suffix || '');
    };
    /*
   * Return an array of two BigNumbers representing the value of this BigNumber as a simple
   * fraction with an integer numerator and an integer denominator.
   * The denominator will be a positive non-zero value less than or equal to the specified
   * maximum denominator. If a maximum denominator is not specified, the denominator will be
   * the lowest value necessary to represent the number exactly.
   *
   * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
   *
   * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
   */ P.toFraction = function(md) {
        var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
        if (md != null) {
            n = new BigNumber(md);
            // Throw if md is less than one or is not an integer, unless it is Infinity.
            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
                throw Error(bignumberError + 'Argument ' + (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
            }
        }
        if (!xc) return new BigNumber(x);
        d = new BigNumber(ONE);
        n1 = d0 = new BigNumber(ONE);
        d1 = n0 = new BigNumber(ONE);
        s = coeffToString(xc);
        // Determine initial denominator.
        // d is a power of 10 and the minimum max denominator that specifies the value exactly.
        e = d.e = s.length - x.e - 1;
        d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
        md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
        exp = MAX_EXP;
        MAX_EXP = 1 / 0;
        n = new BigNumber(s);
        // n0 = d1 = 0
        n0.c[0] = 0;
        for(;;){
            q = div(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.comparedTo(md) == 1) break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times(d2 = n1));
            n0 = d2;
            d = n.minus(q.times(d2 = d));
            n = d2;
        }
        d2 = div(md.minus(d0), d1, 0, 1);
        n0 = n0.plus(d2.times(n1));
        d0 = d0.plus(d2.times(d1));
        n0.s = n1.s = x.s;
        e = e * 2;
        // Determine which fraction is closer to x, n0/d0 or n1/d1
        r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [
            n1,
            d1
        ] : [
            n0,
            d0
        ];
        MAX_EXP = exp;
        return r;
    };
    /*
   * Return the value of this BigNumber converted to a number primitive.
   */ P.toNumber = function() {
        return +valueOf(this);
    };
    /*
   * Return a string representing the value of this BigNumber rounded to sd significant digits
   * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
   * necessary to represent the integer part of the value in fixed-point notation, then use
   * exponential notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
   */ P.toPrecision = function(sd, rm) {
        if (sd != null) intCheck(sd, 1, MAX);
        return format(this, sd, rm, 2);
    };
    /*
   * Return a string representing the value of this BigNumber in base b, or base 10 if b is
   * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
   * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
   * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
   * TO_EXP_NEG, return exponential notation.
   *
   * [b] {number} Integer, 2 to ALPHABET.length inclusive.
   *
   * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
   */ P.toString = function(b) {
        var str, n = this, s = n.s, e = n.e;
        // Infinity or NaN?
        if (e === null) {
            if (s) {
                str = 'Infinity';
                if (s < 0) str = '-' + str;
            } else {
                str = 'NaN';
            }
        } else {
            if (b == null) {
                str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, '0');
            } else if (b === 10 && alphabetHasNormalDecimalDigits) {
                n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
                str = toFixedPoint(coeffToString(n.c), n.e, '0');
            } else {
                intCheck(b, 2, ALPHABET.length, 'Base');
                str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
            }
            if (s < 0 && n.c[0]) str = '-' + str;
        }
        return str;
    };
    /*
   * Return as toString, but do not accept a base argument, and include the minus sign for
   * negative zero.
   */ P.valueOf = P.toJSON = function() {
        return valueOf(this);
    };
    P._isBigNumber = true;
    P[Symbol.toStringTag] = 'BigNumber';
    // Node.js v10.12.0+
    P[Symbol.for('nodejs.util.inspect.custom')] = P.valueOf;
    if (configObject != null) BigNumber.set(configObject);
    return BigNumber;
}
// PRIVATE HELPER FUNCTIONS
// These functions don't need access to variables,
// e.g. DECIMAL_PLACES, in the scope of the `clone` function above.
function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
}
// Return a coefficient array as a string of base 10 digits.
function coeffToString(a) {
    var s, z, i = 1, j = a.length, r = a[0] + '';
    for(; i < j;){
        s = a[i++] + '';
        z = LOG_BASE - s.length;
        for(; z--; s = '0' + s);
        r += s;
    }
    // Determine trailing zeros.
    for(j = r.length; r.charCodeAt(--j) === 48;);
    return r.slice(0, j + 1 || 1);
}
// Compare the value of BigNumbers x and y.
function compare(x, y) {
    var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
    // Either NaN?
    if (!i || !j) return null;
    a = xc && !xc[0];
    b = yc && !yc[0];
    // Either zero?
    if (a || b) return a ? b ? 0 : -j : i;
    // Signs differ?
    if (i != j) return i;
    a = i < 0;
    b = k == l;
    // Either Infinity?
    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;
    // Compare exponents.
    if (!b) return k > l ^ a ? 1 : -1;
    j = (k = xc.length) < (l = yc.length) ? k : l;
    // Compare digit by digit.
    for(i = 0; i < j; i++)if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;
    // Compare lengths.
    return k == l ? 0 : k > l ^ a ? 1 : -1;
}
/*
 * Check that n is a primitive number, an integer, and in range, otherwise throw.
 */ function intCheck(n, min, max, name) {
    if (n < min || n > max || n !== mathfloor(n)) {
        throw Error(bignumberError + (name || 'Argument') + (typeof n == 'number' ? n < min || n > max ? ' out of range: ' : ' not an integer: ' : ' not a primitive number: ') + String(n));
    }
}
// Assumes finite n.
function isOdd(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
}
function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) + (e < 0 ? 'e' : 'e+') + e;
}
function toFixedPoint(str, e, z) {
    var len, zs;
    // Negative exponent?
    if (e < 0) {
        // Prepend zeros.
        for(zs = z + '.'; ++e; zs += z);
        str = zs + str;
    // Positive exponent
    } else {
        len = str.length;
        // Append zeros.
        if (++e > len) {
            for(zs = z, e -= len; --e; zs += z);
            str += zs;
        } else if (e < len) {
            str = str.slice(0, e) + '.' + str.slice(e);
        }
    }
    return str;
}
var BigNumber = clone();
const __TURBOPACK__default__export__ = BigNumber;
}}),
"[project]/node_modules/splaytree-ts/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// src/index.ts
__turbopack_esm__({
    "SplayTreeMap": (()=>SplayTreeMap),
    "SplayTreeSet": (()=>SplayTreeSet)
});
var SplayTreeNode = class {
    key;
    left = null;
    right = null;
    constructor(key){
        this.key = key;
    }
};
var SplayTreeSetNode = class extends SplayTreeNode {
    constructor(key){
        super(key);
    }
};
var SplayTreeMapNode = class _SplayTreeMapNode extends SplayTreeNode {
    value;
    constructor(key, value){
        super(key);
        this.value = value;
    }
    replaceValue(value) {
        const node = new _SplayTreeMapNode(this.key, value);
        node.left = this.left;
        node.right = this.right;
        return node;
    }
};
var SplayTree = class {
    size = 0;
    modificationCount = 0;
    splayCount = 0;
    splay(key) {
        const root = this.root;
        if (root == null) {
            this.compare(key, key);
            return -1;
        }
        let right = null;
        let newTreeRight = null;
        let left = null;
        let newTreeLeft = null;
        let current = root;
        const compare = this.compare;
        let comp;
        while(true){
            comp = compare(current.key, key);
            if (comp > 0) {
                let currentLeft = current.left;
                if (currentLeft == null) break;
                comp = compare(currentLeft.key, key);
                if (comp > 0) {
                    current.left = currentLeft.right;
                    currentLeft.right = current;
                    current = currentLeft;
                    currentLeft = current.left;
                    if (currentLeft == null) break;
                }
                if (right == null) {
                    newTreeRight = current;
                } else {
                    right.left = current;
                }
                right = current;
                current = currentLeft;
            } else if (comp < 0) {
                let currentRight = current.right;
                if (currentRight == null) break;
                comp = compare(currentRight.key, key);
                if (comp < 0) {
                    current.right = currentRight.left;
                    currentRight.left = current;
                    current = currentRight;
                    currentRight = current.right;
                    if (currentRight == null) break;
                }
                if (left == null) {
                    newTreeLeft = current;
                } else {
                    left.right = current;
                }
                left = current;
                current = currentRight;
            } else {
                break;
            }
        }
        if (left != null) {
            left.right = current.left;
            current.left = newTreeLeft;
        }
        if (right != null) {
            right.left = current.right;
            current.right = newTreeRight;
        }
        if (this.root !== current) {
            this.root = current;
            this.splayCount++;
        }
        return comp;
    }
    splayMin(node) {
        let current = node;
        let nextLeft = current.left;
        while(nextLeft != null){
            const left = nextLeft;
            current.left = left.right;
            left.right = current;
            current = left;
            nextLeft = current.left;
        }
        return current;
    }
    splayMax(node) {
        let current = node;
        let nextRight = current.right;
        while(nextRight != null){
            const right = nextRight;
            current.right = right.left;
            right.left = current;
            current = right;
            nextRight = current.right;
        }
        return current;
    }
    _delete(key) {
        if (this.root == null) return null;
        const comp = this.splay(key);
        if (comp != 0) return null;
        let root = this.root;
        const result = root;
        const left = root.left;
        this.size--;
        if (left == null) {
            this.root = root.right;
        } else {
            const right = root.right;
            root = this.splayMax(left);
            root.right = right;
            this.root = root;
        }
        this.modificationCount++;
        return result;
    }
    addNewRoot(node, comp) {
        this.size++;
        this.modificationCount++;
        const root = this.root;
        if (root == null) {
            this.root = node;
            return;
        }
        if (comp < 0) {
            node.left = root;
            node.right = root.right;
            root.right = null;
        } else {
            node.right = root;
            node.left = root.left;
            root.left = null;
        }
        this.root = node;
    }
    _first() {
        const root = this.root;
        if (root == null) return null;
        this.root = this.splayMin(root);
        return this.root;
    }
    _last() {
        const root = this.root;
        if (root == null) return null;
        this.root = this.splayMax(root);
        return this.root;
    }
    clear() {
        this.root = null;
        this.size = 0;
        this.modificationCount++;
    }
    has(key) {
        return this.validKey(key) && this.splay(key) == 0;
    }
    defaultCompare() {
        return (a, b)=>a < b ? -1 : a > b ? 1 : 0;
    }
    wrap() {
        return {
            getRoot: ()=>{
                return this.root;
            },
            setRoot: (root)=>{
                this.root = root;
            },
            getSize: ()=>{
                return this.size;
            },
            getModificationCount: ()=>{
                return this.modificationCount;
            },
            getSplayCount: ()=>{
                return this.splayCount;
            },
            setSplayCount: (count)=>{
                this.splayCount = count;
            },
            splay: (key)=>{
                return this.splay(key);
            },
            has: (key)=>{
                return this.has(key);
            }
        };
    }
};
var SplayTreeMap = class extends SplayTree {
    root = null;
    compare;
    validKey;
    constructor(compare, isValidKey){
        super();
        this.compare = compare ?? this.defaultCompare();
        this.validKey = isValidKey ?? ((a)=>a != null && a != void 0);
    }
    delete(key) {
        if (!this.validKey(key)) return false;
        return this._delete(key) != null;
    }
    forEach(f) {
        const nodes = new SplayTreeMapEntryIterableIterator(this.wrap());
        let result;
        while(result = nodes.next(), !result.done){
            f(result.value[1], result.value[0], this);
        }
    }
    get(key) {
        if (!this.validKey(key)) return void 0;
        if (this.root != null) {
            const comp = this.splay(key);
            if (comp == 0) {
                return this.root.value;
            }
        }
        return void 0;
    }
    hasValue(value) {
        const initialSplayCount = this.splayCount;
        const visit = (node)=>{
            while(node != null){
                if (node.value == value) return true;
                if (initialSplayCount != this.splayCount) {
                    throw "Concurrent modification during iteration.";
                }
                if (node.right != null && visit(node.right)) {
                    return true;
                }
                node = node.left;
            }
            return false;
        };
        return visit(this.root);
    }
    set(key, value) {
        const comp = this.splay(key);
        if (comp == 0) {
            this.root = this.root.replaceValue(value);
            this.splayCount += 1;
            return this;
        }
        this.addNewRoot(new SplayTreeMapNode(key, value), comp);
        return this;
    }
    setAll(other) {
        other.forEach((value, key)=>{
            this.set(key, value);
        });
    }
    setIfAbsent(key, ifAbsent) {
        let comp = this.splay(key);
        if (comp == 0) {
            return this.root.value;
        }
        const modificationCount = this.modificationCount;
        const splayCount = this.splayCount;
        const value = ifAbsent();
        if (modificationCount != this.modificationCount) {
            throw "Concurrent modification during iteration.";
        }
        if (splayCount != this.splayCount) {
            comp = this.splay(key);
        }
        this.addNewRoot(new SplayTreeMapNode(key, value), comp);
        return value;
    }
    isEmpty() {
        return this.root == null;
    }
    isNotEmpty() {
        return !this.isEmpty();
    }
    firstKey() {
        if (this.root == null) return null;
        return this._first().key;
    }
    lastKey() {
        if (this.root == null) return null;
        return this._last().key;
    }
    lastKeyBefore(key) {
        if (key == null) throw "Invalid arguments(s)";
        if (this.root == null) return null;
        const comp = this.splay(key);
        if (comp < 0) return this.root.key;
        let node = this.root.left;
        if (node == null) return null;
        let nodeRight = node.right;
        while(nodeRight != null){
            node = nodeRight;
            nodeRight = node.right;
        }
        return node.key;
    }
    firstKeyAfter(key) {
        if (key == null) throw "Invalid arguments(s)";
        if (this.root == null) return null;
        const comp = this.splay(key);
        if (comp > 0) return this.root.key;
        let node = this.root.right;
        if (node == null) return null;
        let nodeLeft = node.left;
        while(nodeLeft != null){
            node = nodeLeft;
            nodeLeft = node.left;
        }
        return node.key;
    }
    update(key, update, ifAbsent) {
        let comp = this.splay(key);
        if (comp == 0) {
            const modificationCount = this.modificationCount;
            const splayCount = this.splayCount;
            const newValue = update(this.root.value);
            if (modificationCount != this.modificationCount) {
                throw "Concurrent modification during iteration.";
            }
            if (splayCount != this.splayCount) {
                this.splay(key);
            }
            this.root = this.root.replaceValue(newValue);
            this.splayCount += 1;
            return newValue;
        }
        if (ifAbsent != null) {
            const modificationCount = this.modificationCount;
            const splayCount = this.splayCount;
            const newValue = ifAbsent();
            if (modificationCount != this.modificationCount) {
                throw "Concurrent modification during iteration.";
            }
            if (splayCount != this.splayCount) {
                comp = this.splay(key);
            }
            this.addNewRoot(new SplayTreeMapNode(key, newValue), comp);
            return newValue;
        }
        throw "Invalid argument (key): Key not in map.";
    }
    updateAll(update) {
        const root = this.root;
        if (root == null) return;
        const iterator = new SplayTreeMapEntryIterableIterator(this.wrap());
        let node;
        while(node = iterator.next(), !node.done){
            const newValue = update(...node.value);
            iterator.replaceValue(newValue);
        }
    }
    keys() {
        return new SplayTreeKeyIterableIterator(this.wrap());
    }
    values() {
        return new SplayTreeValueIterableIterator(this.wrap());
    }
    entries() {
        return this[Symbol.iterator]();
    }
    [Symbol.iterator]() {
        return new SplayTreeMapEntryIterableIterator(this.wrap());
    }
    [Symbol.toStringTag] = "[object Map]";
};
var SplayTreeSet = class _SplayTreeSet extends SplayTree {
    root = null;
    compare;
    validKey;
    constructor(compare, isValidKey){
        super();
        this.compare = compare ?? this.defaultCompare();
        this.validKey = isValidKey ?? ((v)=>v != null && v != void 0);
    }
    delete(element) {
        if (!this.validKey(element)) return false;
        return this._delete(element) != null;
    }
    deleteAll(elements) {
        for (const element of elements){
            this.delete(element);
        }
    }
    forEach(f) {
        const nodes = this[Symbol.iterator]();
        let result;
        while(result = nodes.next(), !result.done){
            f(result.value, result.value, this);
        }
    }
    add(element) {
        const compare = this.splay(element);
        if (compare != 0) this.addNewRoot(new SplayTreeSetNode(element), compare);
        return this;
    }
    addAndReturn(element) {
        const compare = this.splay(element);
        if (compare != 0) this.addNewRoot(new SplayTreeSetNode(element), compare);
        return this.root.key;
    }
    addAll(elements) {
        for (const element of elements){
            this.add(element);
        }
    }
    isEmpty() {
        return this.root == null;
    }
    isNotEmpty() {
        return this.root != null;
    }
    single() {
        if (this.size == 0) throw "Bad state: No element";
        if (this.size > 1) throw "Bad state: Too many element";
        return this.root.key;
    }
    first() {
        if (this.size == 0) throw "Bad state: No element";
        return this._first().key;
    }
    last() {
        if (this.size == 0) throw "Bad state: No element";
        return this._last().key;
    }
    lastBefore(element) {
        if (element == null) throw "Invalid arguments(s)";
        if (this.root == null) return null;
        const comp = this.splay(element);
        if (comp < 0) return this.root.key;
        let node = this.root.left;
        if (node == null) return null;
        let nodeRight = node.right;
        while(nodeRight != null){
            node = nodeRight;
            nodeRight = node.right;
        }
        return node.key;
    }
    firstAfter(element) {
        if (element == null) throw "Invalid arguments(s)";
        if (this.root == null) return null;
        const comp = this.splay(element);
        if (comp > 0) return this.root.key;
        let node = this.root.right;
        if (node == null) return null;
        let nodeLeft = node.left;
        while(nodeLeft != null){
            node = nodeLeft;
            nodeLeft = node.left;
        }
        return node.key;
    }
    retainAll(elements) {
        const retainSet = new _SplayTreeSet(this.compare, this.validKey);
        const modificationCount = this.modificationCount;
        for (const object of elements){
            if (modificationCount != this.modificationCount) {
                throw "Concurrent modification during iteration.";
            }
            if (this.validKey(object) && this.splay(object) == 0) {
                retainSet.add(this.root.key);
            }
        }
        if (retainSet.size != this.size) {
            this.root = retainSet.root;
            this.size = retainSet.size;
            this.modificationCount++;
        }
    }
    lookup(object) {
        if (!this.validKey(object)) return null;
        const comp = this.splay(object);
        if (comp != 0) return null;
        return this.root.key;
    }
    intersection(other) {
        const result = new _SplayTreeSet(this.compare, this.validKey);
        for (const element of this){
            if (other.has(element)) result.add(element);
        }
        return result;
    }
    difference(other) {
        const result = new _SplayTreeSet(this.compare, this.validKey);
        for (const element of this){
            if (!other.has(element)) result.add(element);
        }
        return result;
    }
    union(other) {
        const u = this.clone();
        u.addAll(other);
        return u;
    }
    clone() {
        const set = new _SplayTreeSet(this.compare, this.validKey);
        set.size = this.size;
        set.root = this.copyNode(this.root);
        return set;
    }
    copyNode(node) {
        if (node == null) return null;
        function copyChildren(node2, dest) {
            let left;
            let right;
            do {
                left = node2.left;
                right = node2.right;
                if (left != null) {
                    const newLeft = new SplayTreeSetNode(left.key);
                    dest.left = newLeft;
                    copyChildren(left, newLeft);
                }
                if (right != null) {
                    const newRight = new SplayTreeSetNode(right.key);
                    dest.right = newRight;
                    node2 = right;
                    dest = newRight;
                }
            }while (right != null)
        }
        const result = new SplayTreeSetNode(node.key);
        copyChildren(node, result);
        return result;
    }
    toSet() {
        return this.clone();
    }
    entries() {
        return new SplayTreeSetEntryIterableIterator(this.wrap());
    }
    keys() {
        return this[Symbol.iterator]();
    }
    values() {
        return this[Symbol.iterator]();
    }
    [Symbol.iterator]() {
        return new SplayTreeKeyIterableIterator(this.wrap());
    }
    [Symbol.toStringTag] = "[object Set]";
};
var SplayTreeIterableIterator = class {
    tree;
    path = new Array();
    modificationCount = null;
    splayCount;
    constructor(tree){
        this.tree = tree;
        this.splayCount = tree.getSplayCount();
    }
    [Symbol.iterator]() {
        return this;
    }
    next() {
        if (this.moveNext()) return {
            done: false,
            value: this.current()
        };
        return {
            done: true,
            value: null
        };
    }
    current() {
        if (!this.path.length) return null;
        const node = this.path[this.path.length - 1];
        return this.getValue(node);
    }
    rebuildPath(key) {
        this.path.splice(0, this.path.length);
        this.tree.splay(key);
        this.path.push(this.tree.getRoot());
        this.splayCount = this.tree.getSplayCount();
    }
    findLeftMostDescendent(node) {
        while(node != null){
            this.path.push(node);
            node = node.left;
        }
    }
    moveNext() {
        if (this.modificationCount != this.tree.getModificationCount()) {
            if (this.modificationCount == null) {
                this.modificationCount = this.tree.getModificationCount();
                let node2 = this.tree.getRoot();
                while(node2 != null){
                    this.path.push(node2);
                    node2 = node2.left;
                }
                return this.path.length > 0;
            }
            throw "Concurrent modification during iteration.";
        }
        if (!this.path.length) return false;
        if (this.splayCount != this.tree.getSplayCount()) {
            this.rebuildPath(this.path[this.path.length - 1].key);
        }
        let node = this.path[this.path.length - 1];
        let next = node.right;
        if (next != null) {
            while(next != null){
                this.path.push(next);
                next = next.left;
            }
            return true;
        }
        this.path.pop();
        while(this.path.length && this.path[this.path.length - 1].right === node){
            node = this.path.pop();
        }
        return this.path.length > 0;
    }
};
var SplayTreeKeyIterableIterator = class extends SplayTreeIterableIterator {
    getValue(node) {
        return node.key;
    }
};
var SplayTreeSetEntryIterableIterator = class extends SplayTreeIterableIterator {
    getValue(node) {
        return [
            node.key,
            node.key
        ];
    }
};
var SplayTreeValueIterableIterator = class extends SplayTreeIterableIterator {
    constructor(map){
        super(map);
    }
    getValue(node) {
        return node.value;
    }
};
var SplayTreeMapEntryIterableIterator = class extends SplayTreeIterableIterator {
    constructor(map){
        super(map);
    }
    getValue(node) {
        return [
            node.key,
            node.value
        ];
    }
    replaceValue(value) {
        if (this.modificationCount != this.tree.getModificationCount()) {
            throw "Concurrent modification during iteration.";
        }
        if (this.splayCount != this.tree.getSplayCount()) {
            this.rebuildPath(this.path[this.path.length - 1].key);
        }
        const last = this.path.pop();
        const newLast = last.replaceValue(value);
        if (!this.path.length) {
            this.tree.setRoot(newLast);
        } else {
            const parent = this.path[this.path.length - 1];
            if (last === parent.left) {
                parent.left = newLast;
            } else {
                parent.right = newLast;
            }
        }
        this.path.push(newLast);
        const count = this.tree.getSplayCount() + 1;
        this.tree.setSplayCount(count);
        this.splayCount = count;
    }
};
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/polyclip-ts/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// src/geom-in.ts
__turbopack_esm__({
    "difference": (()=>difference),
    "intersection": (()=>intersection2),
    "setPrecision": (()=>setPrecision),
    "union": (()=>union),
    "xor": (()=>xor)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/bignumber.js/bignumber.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$splaytree$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/splaytree-ts/dist/esm/index.js [app-client] (ecmascript)");
;
// src/constant.ts
var constant_default = (x)=>{
    return ()=>{
        return x;
    };
};
// src/compare.ts
var compare_default = (eps)=>{
    const almostEqual = eps ? (a, b)=>b.minus(a).abs().isLessThanOrEqualTo(eps) : constant_default(false);
    return (a, b)=>{
        if (almostEqual(a, b)) return 0;
        return a.comparedTo(b);
    };
};
// src/orient.ts
function orient_default(eps) {
    const almostCollinear = eps ? (area2, ax, ay, cx, cy)=>area2.exponentiatedBy(2).isLessThanOrEqualTo(cx.minus(ax).exponentiatedBy(2).plus(cy.minus(ay).exponentiatedBy(2)).times(eps)) : constant_default(false);
    return (a, b, c)=>{
        const ax = a.x, ay = a.y, cx = c.x, cy = c.y;
        const area2 = ay.minus(cy).times(b.x.minus(cx)).minus(ax.minus(cx).times(b.y.minus(cy)));
        if (almostCollinear(area2, ax, ay, cx, cy)) return 0;
        return area2.comparedTo(0);
    };
}
;
;
// src/identity.ts
var identity_default = (x)=>{
    return x;
};
// src/snap.ts
var snap_default = (eps)=>{
    if (eps) {
        const xTree = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$splaytree$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SplayTreeSet"](compare_default(eps));
        const yTree = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$splaytree$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SplayTreeSet"](compare_default(eps));
        const snapCoord = (coord, tree)=>{
            return tree.addAndReturn(coord);
        };
        const snap = (v)=>{
            return {
                x: snapCoord(v.x, xTree),
                y: snapCoord(v.y, yTree)
            };
        };
        snap({
            x: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0),
            y: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](0)
        });
        return snap;
    }
    return identity_default;
};
// src/precision.ts
var set = (eps)=>{
    return {
        set: (eps2)=>{
            precision = set(eps2);
        },
        reset: ()=>set(eps),
        compare: compare_default(eps),
        snap: snap_default(eps),
        orient: orient_default(eps)
    };
};
var precision = set();
// src/bbox.ts
var isInBbox = (bbox, point)=>{
    return bbox.ll.x.isLessThanOrEqualTo(point.x) && point.x.isLessThanOrEqualTo(bbox.ur.x) && bbox.ll.y.isLessThanOrEqualTo(point.y) && point.y.isLessThanOrEqualTo(bbox.ur.y);
};
var getBboxOverlap = (b1, b2)=>{
    if (b2.ur.x.isLessThan(b1.ll.x) || b1.ur.x.isLessThan(b2.ll.x) || b2.ur.y.isLessThan(b1.ll.y) || b1.ur.y.isLessThan(b2.ll.y)) return null;
    const lowerX = b1.ll.x.isLessThan(b2.ll.x) ? b2.ll.x : b1.ll.x;
    const upperX = b1.ur.x.isLessThan(b2.ur.x) ? b1.ur.x : b2.ur.x;
    const lowerY = b1.ll.y.isLessThan(b2.ll.y) ? b2.ll.y : b1.ll.y;
    const upperY = b1.ur.y.isLessThan(b2.ur.y) ? b1.ur.y : b2.ur.y;
    return {
        ll: {
            x: lowerX,
            y: lowerY
        },
        ur: {
            x: upperX,
            y: upperY
        }
    };
};
;
// src/vector.ts
var crossProduct = (a, b)=>a.x.times(b.y).minus(a.y.times(b.x));
var dotProduct = (a, b)=>a.x.times(b.x).plus(a.y.times(b.y));
var length = (v)=>dotProduct(v, v).sqrt();
var sineOfAngle = (pShared, pBase, pAngle)=>{
    const vBase = {
        x: pBase.x.minus(pShared.x),
        y: pBase.y.minus(pShared.y)
    };
    const vAngle = {
        x: pAngle.x.minus(pShared.x),
        y: pAngle.y.minus(pShared.y)
    };
    return crossProduct(vAngle, vBase).div(length(vAngle)).div(length(vBase));
};
var cosineOfAngle = (pShared, pBase, pAngle)=>{
    const vBase = {
        x: pBase.x.minus(pShared.x),
        y: pBase.y.minus(pShared.y)
    };
    const vAngle = {
        x: pAngle.x.minus(pShared.x),
        y: pAngle.y.minus(pShared.y)
    };
    return dotProduct(vAngle, vBase).div(length(vAngle)).div(length(vBase));
};
var horizontalIntersection = (pt, v, y)=>{
    if (v.y.isZero()) return null;
    return {
        x: pt.x.plus(v.x.div(v.y).times(y.minus(pt.y))),
        y
    };
};
var verticalIntersection = (pt, v, x)=>{
    if (v.x.isZero()) return null;
    return {
        x,
        y: pt.y.plus(v.y.div(v.x).times(x.minus(pt.x)))
    };
};
var intersection = (pt1, v1, pt2, v2)=>{
    if (v1.x.isZero()) return verticalIntersection(pt2, v2, pt1.x);
    if (v2.x.isZero()) return verticalIntersection(pt1, v1, pt2.x);
    if (v1.y.isZero()) return horizontalIntersection(pt2, v2, pt1.y);
    if (v2.y.isZero()) return horizontalIntersection(pt1, v1, pt2.y);
    const kross = crossProduct(v1, v2);
    if (kross.isZero()) return null;
    const ve = {
        x: pt2.x.minus(pt1.x),
        y: pt2.y.minus(pt1.y)
    };
    const d1 = crossProduct(ve, v1).div(kross);
    const d2 = crossProduct(ve, v2).div(kross);
    const x1 = pt1.x.plus(d2.times(v1.x)), x2 = pt2.x.plus(d1.times(v2.x));
    const y1 = pt1.y.plus(d2.times(v1.y)), y2 = pt2.y.plus(d1.times(v2.y));
    const x = x1.plus(x2).div(2);
    const y = y1.plus(y2).div(2);
    return {
        x,
        y
    };
};
// src/sweep-event.ts
var SweepEvent = class _SweepEvent {
    point;
    isLeft;
    segment;
    otherSE;
    consumedBy;
    // for ordering sweep events in the sweep event queue
    static compare(a, b) {
        const ptCmp = _SweepEvent.comparePoints(a.point, b.point);
        if (ptCmp !== 0) return ptCmp;
        if (a.point !== b.point) a.link(b);
        if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1;
        return Segment.compare(a.segment, b.segment);
    }
    // for ordering points in sweep line order
    static comparePoints(aPt, bPt) {
        if (aPt.x.isLessThan(bPt.x)) return -1;
        if (aPt.x.isGreaterThan(bPt.x)) return 1;
        if (aPt.y.isLessThan(bPt.y)) return -1;
        if (aPt.y.isGreaterThan(bPt.y)) return 1;
        return 0;
    }
    // Warning: 'point' input will be modified and re-used (for performance)
    constructor(point, isLeft){
        if (point.events === void 0) point.events = [
            this
        ];
        else point.events.push(this);
        this.point = point;
        this.isLeft = isLeft;
    }
    link(other) {
        if (other.point === this.point) {
            throw new Error("Tried to link already linked events");
        }
        const otherEvents = other.point.events;
        for(let i = 0, iMax = otherEvents.length; i < iMax; i++){
            const evt = otherEvents[i];
            this.point.events.push(evt);
            evt.point = this.point;
        }
        this.checkForConsuming();
    }
    /* Do a pass over our linked events and check to see if any pair
   * of segments match, and should be consumed. */ checkForConsuming() {
        const numEvents = this.point.events.length;
        for(let i = 0; i < numEvents; i++){
            const evt1 = this.point.events[i];
            if (evt1.segment.consumedBy !== void 0) continue;
            for(let j = i + 1; j < numEvents; j++){
                const evt2 = this.point.events[j];
                if (evt2.consumedBy !== void 0) continue;
                if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;
                evt1.segment.consume(evt2.segment);
            }
        }
    }
    getAvailableLinkedEvents() {
        const events = [];
        for(let i = 0, iMax = this.point.events.length; i < iMax; i++){
            const evt = this.point.events[i];
            if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {
                events.push(evt);
            }
        }
        return events;
    }
    /**
   * Returns a comparator function for sorting linked events that will
   * favor the event that will give us the smallest left-side angle.
   * All ring construction starts as low as possible heading to the right,
   * so by always turning left as sharp as possible we'll get polygons
   * without uncessary loops & holes.
   *
   * The comparator function has a compute cache such that it avoids
   * re-computing already-computed values.
   */ getLeftmostComparator(baseEvent) {
        const cache = /* @__PURE__ */ new Map();
        const fillCache = (linkedEvent)=>{
            const nextEvent = linkedEvent.otherSE;
            cache.set(linkedEvent, {
                sine: sineOfAngle(this.point, baseEvent.point, nextEvent.point),
                cosine: cosineOfAngle(this.point, baseEvent.point, nextEvent.point)
            });
        };
        return (a, b)=>{
            if (!cache.has(a)) fillCache(a);
            if (!cache.has(b)) fillCache(b);
            const { sine: asine, cosine: acosine } = cache.get(a);
            const { sine: bsine, cosine: bcosine } = cache.get(b);
            if (asine.isGreaterThanOrEqualTo(0) && bsine.isGreaterThanOrEqualTo(0)) {
                if (acosine.isLessThan(bcosine)) return 1;
                if (acosine.isGreaterThan(bcosine)) return -1;
                return 0;
            }
            if (asine.isLessThan(0) && bsine.isLessThan(0)) {
                if (acosine.isLessThan(bcosine)) return -1;
                if (acosine.isGreaterThan(bcosine)) return 1;
                return 0;
            }
            if (bsine.isLessThan(asine)) return -1;
            if (bsine.isGreaterThan(asine)) return 1;
            return 0;
        };
    }
};
// src/geom-out.ts
var RingOut = class _RingOut {
    events;
    poly;
    _isExteriorRing;
    _enclosingRing;
    /* Given the segments from the sweep line pass, compute & return a series
   * of closed rings from all the segments marked to be part of the result */ static factory(allSegments) {
        const ringsOut = [];
        for(let i = 0, iMax = allSegments.length; i < iMax; i++){
            const segment = allSegments[i];
            if (!segment.isInResult() || segment.ringOut) continue;
            let prevEvent = null;
            let event = segment.leftSE;
            let nextEvent = segment.rightSE;
            const events = [
                event
            ];
            const startingPoint = event.point;
            const intersectionLEs = [];
            while(true){
                prevEvent = event;
                event = nextEvent;
                events.push(event);
                if (event.point === startingPoint) break;
                while(true){
                    const availableLEs = event.getAvailableLinkedEvents();
                    if (availableLEs.length === 0) {
                        const firstPt = events[0].point;
                        const lastPt = events[events.length - 1].point;
                        throw new Error(`Unable to complete output ring starting at [${firstPt.x}, ${firstPt.y}]. Last matching segment found ends at [${lastPt.x}, ${lastPt.y}].`);
                    }
                    if (availableLEs.length === 1) {
                        nextEvent = availableLEs[0].otherSE;
                        break;
                    }
                    let indexLE = null;
                    for(let j = 0, jMax = intersectionLEs.length; j < jMax; j++){
                        if (intersectionLEs[j].point === event.point) {
                            indexLE = j;
                            break;
                        }
                    }
                    if (indexLE !== null) {
                        const intersectionLE = intersectionLEs.splice(indexLE)[0];
                        const ringEvents = events.splice(intersectionLE.index);
                        ringEvents.unshift(ringEvents[0].otherSE);
                        ringsOut.push(new _RingOut(ringEvents.reverse()));
                        continue;
                    }
                    intersectionLEs.push({
                        index: events.length,
                        point: event.point
                    });
                    const comparator = event.getLeftmostComparator(prevEvent);
                    nextEvent = availableLEs.sort(comparator)[0].otherSE;
                    break;
                }
            }
            ringsOut.push(new _RingOut(events));
        }
        return ringsOut;
    }
    constructor(events){
        this.events = events;
        for(let i = 0, iMax = events.length; i < iMax; i++){
            events[i].segment.ringOut = this;
        }
        this.poly = null;
    }
    getGeom() {
        let prevPt = this.events[0].point;
        const points = [
            prevPt
        ];
        for(let i = 1, iMax = this.events.length - 1; i < iMax; i++){
            const pt2 = this.events[i].point;
            const nextPt2 = this.events[i + 1].point;
            if (precision.orient(pt2, prevPt, nextPt2) === 0) continue;
            points.push(pt2);
            prevPt = pt2;
        }
        if (points.length === 1) return null;
        const pt = points[0];
        const nextPt = points[1];
        if (precision.orient(pt, prevPt, nextPt) === 0) points.shift();
        points.push(points[0]);
        const step = this.isExteriorRing() ? 1 : -1;
        const iStart = this.isExteriorRing() ? 0 : points.length - 1;
        const iEnd = this.isExteriorRing() ? points.length : -1;
        const orderedPoints = [];
        for(let i = iStart; i != iEnd; i += step)orderedPoints.push([
            points[i].x.toNumber(),
            points[i].y.toNumber()
        ]);
        return orderedPoints;
    }
    isExteriorRing() {
        if (this._isExteriorRing === void 0) {
            const enclosing = this.enclosingRing();
            this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;
        }
        return this._isExteriorRing;
    }
    enclosingRing() {
        if (this._enclosingRing === void 0) {
            this._enclosingRing = this._calcEnclosingRing();
        }
        return this._enclosingRing;
    }
    /* Returns the ring that encloses this one, if any */ _calcEnclosingRing() {
        let leftMostEvt = this.events[0];
        for(let i = 1, iMax = this.events.length; i < iMax; i++){
            const evt = this.events[i];
            if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;
        }
        let prevSeg = leftMostEvt.segment.prevInResult();
        let prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
        while(true){
            if (!prevSeg) return null;
            if (!prevPrevSeg) return prevSeg.ringOut;
            if (prevPrevSeg.ringOut !== prevSeg.ringOut) {
                if (prevPrevSeg.ringOut?.enclosingRing() !== prevSeg.ringOut) {
                    return prevSeg.ringOut;
                } else return prevSeg.ringOut?.enclosingRing();
            }
            prevSeg = prevPrevSeg.prevInResult();
            prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
        }
    }
};
var PolyOut = class {
    exteriorRing;
    interiorRings;
    constructor(exteriorRing){
        this.exteriorRing = exteriorRing;
        exteriorRing.poly = this;
        this.interiorRings = [];
    }
    addInterior(ring) {
        this.interiorRings.push(ring);
        ring.poly = this;
    }
    getGeom() {
        const geom0 = this.exteriorRing.getGeom();
        if (geom0 === null) return null;
        const geom = [
            geom0
        ];
        for(let i = 0, iMax = this.interiorRings.length; i < iMax; i++){
            const ringGeom = this.interiorRings[i].getGeom();
            if (ringGeom === null) continue;
            geom.push(ringGeom);
        }
        return geom;
    }
};
var MultiPolyOut = class {
    rings;
    polys;
    constructor(rings){
        this.rings = rings;
        this.polys = this._composePolys(rings);
    }
    getGeom() {
        const geom = [];
        for(let i = 0, iMax = this.polys.length; i < iMax; i++){
            const polyGeom = this.polys[i].getGeom();
            if (polyGeom === null) continue;
            geom.push(polyGeom);
        }
        return geom;
    }
    _composePolys(rings) {
        const polys = [];
        for(let i = 0, iMax = rings.length; i < iMax; i++){
            const ring = rings[i];
            if (ring.poly) continue;
            if (ring.isExteriorRing()) polys.push(new PolyOut(ring));
            else {
                const enclosingRing = ring.enclosingRing();
                if (!enclosingRing?.poly) polys.push(new PolyOut(enclosingRing));
                enclosingRing?.poly?.addInterior(ring);
            }
        }
        return polys;
    }
};
;
var SweepLine = class {
    queue;
    tree;
    segments;
    constructor(queue, comparator = Segment.compare){
        this.queue = queue;
        this.tree = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$splaytree$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SplayTreeSet"](comparator);
        this.segments = [];
    }
    process(event) {
        const segment = event.segment;
        const newEvents = [];
        if (event.consumedBy) {
            if (event.isLeft) this.queue.delete(event.otherSE);
            else this.tree.delete(segment);
            return newEvents;
        }
        if (event.isLeft) this.tree.add(segment);
        let prevSeg = segment;
        let nextSeg = segment;
        do {
            prevSeg = this.tree.lastBefore(prevSeg);
        }while (prevSeg != null && prevSeg.consumedBy != void 0)
        do {
            nextSeg = this.tree.firstAfter(nextSeg);
        }while (nextSeg != null && nextSeg.consumedBy != void 0)
        if (event.isLeft) {
            let prevMySplitter = null;
            if (prevSeg) {
                const prevInter = prevSeg.getIntersection(segment);
                if (prevInter !== null) {
                    if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;
                    if (!prevSeg.isAnEndpoint(prevInter)) {
                        const newEventsFromSplit = this._splitSafely(prevSeg, prevInter);
                        for(let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++){
                            newEvents.push(newEventsFromSplit[i]);
                        }
                    }
                }
            }
            let nextMySplitter = null;
            if (nextSeg) {
                const nextInter = nextSeg.getIntersection(segment);
                if (nextInter !== null) {
                    if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;
                    if (!nextSeg.isAnEndpoint(nextInter)) {
                        const newEventsFromSplit = this._splitSafely(nextSeg, nextInter);
                        for(let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++){
                            newEvents.push(newEventsFromSplit[i]);
                        }
                    }
                }
            }
            if (prevMySplitter !== null || nextMySplitter !== null) {
                let mySplitter = null;
                if (prevMySplitter === null) mySplitter = nextMySplitter;
                else if (nextMySplitter === null) mySplitter = prevMySplitter;
                else {
                    const cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);
                    mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;
                }
                this.queue.delete(segment.rightSE);
                newEvents.push(segment.rightSE);
                const newEventsFromSplit = segment.split(mySplitter);
                for(let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++){
                    newEvents.push(newEventsFromSplit[i]);
                }
            }
            if (newEvents.length > 0) {
                this.tree.delete(segment);
                newEvents.push(event);
            } else {
                this.segments.push(segment);
                segment.prev = prevSeg;
            }
        } else {
            if (prevSeg && nextSeg) {
                const inter = prevSeg.getIntersection(nextSeg);
                if (inter !== null) {
                    if (!prevSeg.isAnEndpoint(inter)) {
                        const newEventsFromSplit = this._splitSafely(prevSeg, inter);
                        for(let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++){
                            newEvents.push(newEventsFromSplit[i]);
                        }
                    }
                    if (!nextSeg.isAnEndpoint(inter)) {
                        const newEventsFromSplit = this._splitSafely(nextSeg, inter);
                        for(let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++){
                            newEvents.push(newEventsFromSplit[i]);
                        }
                    }
                }
            }
            this.tree.delete(segment);
        }
        return newEvents;
    }
    /* Safely split a segment that is currently in the datastructures
   * IE - a segment other than the one that is currently being processed. */ _splitSafely(seg, pt) {
        this.tree.delete(seg);
        const rightSE = seg.rightSE;
        this.queue.delete(rightSE);
        const newEvents = seg.split(pt);
        newEvents.push(rightSE);
        if (seg.consumedBy === void 0) this.tree.add(seg);
        return newEvents;
    }
};
// src/operation.ts
var Operation = class {
    type;
    numMultiPolys;
    run(type, geom, moreGeoms) {
        operation.type = type;
        const multipolys = [
            new MultiPolyIn(geom, true)
        ];
        for(let i = 0, iMax = moreGeoms.length; i < iMax; i++){
            multipolys.push(new MultiPolyIn(moreGeoms[i], false));
        }
        operation.numMultiPolys = multipolys.length;
        if (operation.type === "difference") {
            const subject = multipolys[0];
            let i = 1;
            while(i < multipolys.length){
                if (getBboxOverlap(multipolys[i].bbox, subject.bbox) !== null) i++;
                else multipolys.splice(i, 1);
            }
        }
        if (operation.type === "intersection") {
            for(let i = 0, iMax = multipolys.length; i < iMax; i++){
                const mpA = multipolys[i];
                for(let j = i + 1, jMax = multipolys.length; j < jMax; j++){
                    if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];
                }
            }
        }
        const queue = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$splaytree$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SplayTreeSet"](SweepEvent.compare);
        for(let i = 0, iMax = multipolys.length; i < iMax; i++){
            const sweepEvents = multipolys[i].getSweepEvents();
            for(let j = 0, jMax = sweepEvents.length; j < jMax; j++){
                queue.add(sweepEvents[j]);
            }
        }
        const sweepLine = new SweepLine(queue);
        let evt = null;
        if (queue.size != 0) {
            evt = queue.first();
            queue.delete(evt);
        }
        while(evt){
            const newEvents = sweepLine.process(evt);
            for(let i = 0, iMax = newEvents.length; i < iMax; i++){
                const evt2 = newEvents[i];
                if (evt2.consumedBy === void 0) queue.add(evt2);
            }
            if (queue.size != 0) {
                evt = queue.first();
                queue.delete(evt);
            } else {
                evt = null;
            }
        }
        precision.reset();
        const ringsOut = RingOut.factory(sweepLine.segments);
        const result = new MultiPolyOut(ringsOut);
        return result.getGeom();
    }
};
var operation = new Operation();
var operation_default = operation;
// src/segment.ts
var segmentId = 0;
var Segment = class _Segment {
    id;
    leftSE;
    rightSE;
    rings;
    windings;
    ringOut;
    consumedBy;
    prev;
    _prevInResult;
    _beforeState;
    _afterState;
    _isInResult;
    /* This compare() function is for ordering segments in the sweep
   * line tree, and does so according to the following criteria:
   *
   * Consider the vertical line that lies an infinestimal step to the
   * right of the right-more of the two left endpoints of the input
   * segments. Imagine slowly moving a point up from negative infinity
   * in the increasing y direction. Which of the two segments will that
   * point intersect first? That segment comes 'before' the other one.
   *
   * If neither segment would be intersected by such a line, (if one
   * or more of the segments are vertical) then the line to be considered
   * is directly on the right-more of the two left inputs.
   */ static compare(a, b) {
        const alx = a.leftSE.point.x;
        const blx = b.leftSE.point.x;
        const arx = a.rightSE.point.x;
        const brx = b.rightSE.point.x;
        if (brx.isLessThan(alx)) return 1;
        if (arx.isLessThan(blx)) return -1;
        const aly = a.leftSE.point.y;
        const bly = b.leftSE.point.y;
        const ary = a.rightSE.point.y;
        const bry = b.rightSE.point.y;
        if (alx.isLessThan(blx)) {
            if (bly.isLessThan(aly) && bly.isLessThan(ary)) return 1;
            if (bly.isGreaterThan(aly) && bly.isGreaterThan(ary)) return -1;
            const aCmpBLeft = a.comparePoint(b.leftSE.point);
            if (aCmpBLeft < 0) return 1;
            if (aCmpBLeft > 0) return -1;
            const bCmpARight = b.comparePoint(a.rightSE.point);
            if (bCmpARight !== 0) return bCmpARight;
            return -1;
        }
        if (alx.isGreaterThan(blx)) {
            if (aly.isLessThan(bly) && aly.isLessThan(bry)) return -1;
            if (aly.isGreaterThan(bly) && aly.isGreaterThan(bry)) return 1;
            const bCmpALeft = b.comparePoint(a.leftSE.point);
            if (bCmpALeft !== 0) return bCmpALeft;
            const aCmpBRight = a.comparePoint(b.rightSE.point);
            if (aCmpBRight < 0) return 1;
            if (aCmpBRight > 0) return -1;
            return 1;
        }
        if (aly.isLessThan(bly)) return -1;
        if (aly.isGreaterThan(bly)) return 1;
        if (arx.isLessThan(brx)) {
            const bCmpARight = b.comparePoint(a.rightSE.point);
            if (bCmpARight !== 0) return bCmpARight;
        }
        if (arx.isGreaterThan(brx)) {
            const aCmpBRight = a.comparePoint(b.rightSE.point);
            if (aCmpBRight < 0) return 1;
            if (aCmpBRight > 0) return -1;
        }
        if (!arx.eq(brx)) {
            const ay = ary.minus(aly);
            const ax = arx.minus(alx);
            const by = bry.minus(bly);
            const bx = brx.minus(blx);
            if (ay.isGreaterThan(ax) && by.isLessThan(bx)) return 1;
            if (ay.isLessThan(ax) && by.isGreaterThan(bx)) return -1;
        }
        if (arx.isGreaterThan(brx)) return 1;
        if (arx.isLessThan(brx)) return -1;
        if (ary.isLessThan(bry)) return -1;
        if (ary.isGreaterThan(bry)) return 1;
        if (a.id < b.id) return -1;
        if (a.id > b.id) return 1;
        return 0;
    }
    /* Warning: a reference to ringWindings input will be stored,
   *  and possibly will be later modified */ constructor(leftSE, rightSE, rings, windings){
        this.id = ++segmentId;
        this.leftSE = leftSE;
        leftSE.segment = this;
        leftSE.otherSE = rightSE;
        this.rightSE = rightSE;
        rightSE.segment = this;
        rightSE.otherSE = leftSE;
        this.rings = rings;
        this.windings = windings;
    }
    static fromRing(pt1, pt2, ring) {
        let leftPt, rightPt, winding;
        const cmpPts = SweepEvent.comparePoints(pt1, pt2);
        if (cmpPts < 0) {
            leftPt = pt1;
            rightPt = pt2;
            winding = 1;
        } else if (cmpPts > 0) {
            leftPt = pt2;
            rightPt = pt1;
            winding = -1;
        } else throw new Error(`Tried to create degenerate segment at [${pt1.x}, ${pt1.y}]`);
        const leftSE = new SweepEvent(leftPt, true);
        const rightSE = new SweepEvent(rightPt, false);
        return new _Segment(leftSE, rightSE, [
            ring
        ], [
            winding
        ]);
    }
    /* When a segment is split, the rightSE is replaced with a new sweep event */ replaceRightSE(newRightSE) {
        this.rightSE = newRightSE;
        this.rightSE.segment = this;
        this.rightSE.otherSE = this.leftSE;
        this.leftSE.otherSE = this.rightSE;
    }
    bbox() {
        const y1 = this.leftSE.point.y;
        const y2 = this.rightSE.point.y;
        return {
            ll: {
                x: this.leftSE.point.x,
                y: y1.isLessThan(y2) ? y1 : y2
            },
            ur: {
                x: this.rightSE.point.x,
                y: y1.isGreaterThan(y2) ? y1 : y2
            }
        };
    }
    /* A vector from the left point to the right */ vector() {
        return {
            x: this.rightSE.point.x.minus(this.leftSE.point.x),
            y: this.rightSE.point.y.minus(this.leftSE.point.y)
        };
    }
    isAnEndpoint(pt) {
        return pt.x.eq(this.leftSE.point.x) && pt.y.eq(this.leftSE.point.y) || pt.x.eq(this.rightSE.point.x) && pt.y.eq(this.rightSE.point.y);
    }
    /* Compare this segment with a point.
   *
   * A point P is considered to be colinear to a segment if there
   * exists a distance D such that if we travel along the segment
   * from one * endpoint towards the other a distance D, we find
   * ourselves at point P.
   *
   * Return value indicates:
   *
   *   1: point lies above the segment (to the left of vertical)
   *   0: point is colinear to segment
   *  -1: point lies below the segment (to the right of vertical)
   */ comparePoint(point) {
        return precision.orient(this.leftSE.point, point, this.rightSE.point);
    }
    /**
   * Given another segment, returns the first non-trivial intersection
   * between the two segments (in terms of sweep line ordering), if it exists.
   *
   * A 'non-trivial' intersection is one that will cause one or both of the
   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
   *
   *   * endpoint of segA with endpoint of segB --> trivial
   *   * endpoint of segA with point along segB --> non-trivial
   *   * endpoint of segB with point along segA --> non-trivial
   *   * point along segA with point along segB --> non-trivial
   *
   * If no non-trivial intersection exists, return null
   * Else, return null.
   */ getIntersection(other) {
        const tBbox = this.bbox();
        const oBbox = other.bbox();
        const bboxOverlap = getBboxOverlap(tBbox, oBbox);
        if (bboxOverlap === null) return null;
        const tlp = this.leftSE.point;
        const trp = this.rightSE.point;
        const olp = other.leftSE.point;
        const orp = other.rightSE.point;
        const touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;
        const touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;
        const touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;
        const touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0;
        if (touchesThisLSE && touchesOtherLSE) {
            if (touchesThisRSE && !touchesOtherRSE) return trp;
            if (!touchesThisRSE && touchesOtherRSE) return orp;
            return null;
        }
        if (touchesThisLSE) {
            if (touchesOtherRSE) {
                if (tlp.x.eq(orp.x) && tlp.y.eq(orp.y)) return null;
            }
            return tlp;
        }
        if (touchesOtherLSE) {
            if (touchesThisRSE) {
                if (trp.x.eq(olp.x) && trp.y.eq(olp.y)) return null;
            }
            return olp;
        }
        if (touchesThisRSE && touchesOtherRSE) return null;
        if (touchesThisRSE) return trp;
        if (touchesOtherRSE) return orp;
        const pt = intersection(tlp, this.vector(), olp, other.vector());
        if (pt === null) return null;
        if (!isInBbox(bboxOverlap, pt)) return null;
        return precision.snap(pt);
    }
    /**
   * Split the given segment into multiple segments on the given points.
   *  * Each existing segment will retain its leftSE and a new rightSE will be
   *    generated for it.
   *  * A new segment will be generated which will adopt the original segment's
   *    rightSE, and a new leftSE will be generated for it.
   *  * If there are more than two points given to split on, new segments
   *    in the middle will be generated with new leftSE and rightSE's.
   *  * An array of the newly generated SweepEvents will be returned.
   *
   * Warning: input array of points is modified
   */ split(point) {
        const newEvents = [];
        const alreadyLinked = point.events !== void 0;
        const newLeftSE = new SweepEvent(point, true);
        const newRightSE = new SweepEvent(point, false);
        const oldRightSE = this.rightSE;
        this.replaceRightSE(newRightSE);
        newEvents.push(newRightSE);
        newEvents.push(newLeftSE);
        const newSeg = new _Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice());
        if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {
            newSeg.swapEvents();
        }
        if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {
            this.swapEvents();
        }
        if (alreadyLinked) {
            newLeftSE.checkForConsuming();
            newRightSE.checkForConsuming();
        }
        return newEvents;
    }
    /* Swap which event is left and right */ swapEvents() {
        const tmpEvt = this.rightSE;
        this.rightSE = this.leftSE;
        this.leftSE = tmpEvt;
        this.leftSE.isLeft = true;
        this.rightSE.isLeft = false;
        for(let i = 0, iMax = this.windings.length; i < iMax; i++){
            this.windings[i] *= -1;
        }
    }
    /* Consume another segment. We take their rings under our wing
   * and mark them as consumed. Use for perfectly overlapping segments */ consume(other) {
        let consumer = this;
        let consumee = other;
        while(consumer.consumedBy)consumer = consumer.consumedBy;
        while(consumee.consumedBy)consumee = consumee.consumedBy;
        const cmp = _Segment.compare(consumer, consumee);
        if (cmp === 0) return;
        if (cmp > 0) {
            const tmp = consumer;
            consumer = consumee;
            consumee = tmp;
        }
        if (consumer.prev === consumee) {
            const tmp = consumer;
            consumer = consumee;
            consumee = tmp;
        }
        for(let i = 0, iMax = consumee.rings.length; i < iMax; i++){
            const ring = consumee.rings[i];
            const winding = consumee.windings[i];
            const index = consumer.rings.indexOf(ring);
            if (index === -1) {
                consumer.rings.push(ring);
                consumer.windings.push(winding);
            } else consumer.windings[index] += winding;
        }
        consumee.rings = null;
        consumee.windings = null;
        consumee.consumedBy = consumer;
        consumee.leftSE.consumedBy = consumer.leftSE;
        consumee.rightSE.consumedBy = consumer.rightSE;
    }
    /* The first segment previous segment chain that is in the result */ prevInResult() {
        if (this._prevInResult !== void 0) return this._prevInResult;
        if (!this.prev) this._prevInResult = null;
        else if (this.prev.isInResult()) this._prevInResult = this.prev;
        else this._prevInResult = this.prev.prevInResult();
        return this._prevInResult;
    }
    beforeState() {
        if (this._beforeState !== void 0) return this._beforeState;
        if (!this.prev) this._beforeState = {
            rings: [],
            windings: [],
            multiPolys: []
        };
        else {
            const seg = this.prev.consumedBy || this.prev;
            this._beforeState = seg.afterState();
        }
        return this._beforeState;
    }
    afterState() {
        if (this._afterState !== void 0) return this._afterState;
        const beforeState = this.beforeState();
        this._afterState = {
            rings: beforeState.rings.slice(0),
            windings: beforeState.windings.slice(0),
            multiPolys: []
        };
        const ringsAfter = this._afterState.rings;
        const windingsAfter = this._afterState.windings;
        const mpsAfter = this._afterState.multiPolys;
        for(let i = 0, iMax = this.rings.length; i < iMax; i++){
            const ring = this.rings[i];
            const winding = this.windings[i];
            const index = ringsAfter.indexOf(ring);
            if (index === -1) {
                ringsAfter.push(ring);
                windingsAfter.push(winding);
            } else windingsAfter[index] += winding;
        }
        const polysAfter = [];
        const polysExclude = [];
        for(let i = 0, iMax = ringsAfter.length; i < iMax; i++){
            if (windingsAfter[i] === 0) continue;
            const ring = ringsAfter[i];
            const poly = ring.poly;
            if (polysExclude.indexOf(poly) !== -1) continue;
            if (ring.isExterior) polysAfter.push(poly);
            else {
                if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);
                const index = polysAfter.indexOf(ring.poly);
                if (index !== -1) polysAfter.splice(index, 1);
            }
        }
        for(let i = 0, iMax = polysAfter.length; i < iMax; i++){
            const mp = polysAfter[i].multiPoly;
            if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);
        }
        return this._afterState;
    }
    /* Is this segment part of the final result? */ isInResult() {
        if (this.consumedBy) return false;
        if (this._isInResult !== void 0) return this._isInResult;
        const mpsBefore = this.beforeState().multiPolys;
        const mpsAfter = this.afterState().multiPolys;
        switch(operation_default.type){
            case "union":
                {
                    const noBefores = mpsBefore.length === 0;
                    const noAfters = mpsAfter.length === 0;
                    this._isInResult = noBefores !== noAfters;
                    break;
                }
            case "intersection":
                {
                    let least;
                    let most;
                    if (mpsBefore.length < mpsAfter.length) {
                        least = mpsBefore.length;
                        most = mpsAfter.length;
                    } else {
                        least = mpsAfter.length;
                        most = mpsBefore.length;
                    }
                    this._isInResult = most === operation_default.numMultiPolys && least < most;
                    break;
                }
            case "xor":
                {
                    const diff = Math.abs(mpsBefore.length - mpsAfter.length);
                    this._isInResult = diff % 2 === 1;
                    break;
                }
            case "difference":
                {
                    const isJustSubject = (mps)=>mps.length === 1 && mps[0].isSubject;
                    this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);
                    break;
                }
        }
        return this._isInResult;
    }
};
// src/geom-in.ts
var RingIn = class {
    poly;
    isExterior;
    segments;
    bbox;
    constructor(geomRing, poly, isExterior){
        if (!Array.isArray(geomRing) || geomRing.length === 0) {
            throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
        }
        this.poly = poly;
        this.isExterior = isExterior;
        this.segments = [];
        if (typeof geomRing[0][0] !== "number" || typeof geomRing[0][1] !== "number") {
            throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
        }
        const firstPoint = precision.snap({
            x: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](geomRing[0][0]),
            y: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](geomRing[0][1])
        });
        this.bbox = {
            ll: {
                x: firstPoint.x,
                y: firstPoint.y
            },
            ur: {
                x: firstPoint.x,
                y: firstPoint.y
            }
        };
        let prevPoint = firstPoint;
        for(let i = 1, iMax = geomRing.length; i < iMax; i++){
            if (typeof geomRing[i][0] !== "number" || typeof geomRing[i][1] !== "number") {
                throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            }
            const point = precision.snap({
                x: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](geomRing[i][0]),
                y: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](geomRing[i][1])
            });
            if (point.x.eq(prevPoint.x) && point.y.eq(prevPoint.y)) continue;
            this.segments.push(Segment.fromRing(prevPoint, point, this));
            if (point.x.isLessThan(this.bbox.ll.x)) this.bbox.ll.x = point.x;
            if (point.y.isLessThan(this.bbox.ll.y)) this.bbox.ll.y = point.y;
            if (point.x.isGreaterThan(this.bbox.ur.x)) this.bbox.ur.x = point.x;
            if (point.y.isGreaterThan(this.bbox.ur.y)) this.bbox.ur.y = point.y;
            prevPoint = point;
        }
        if (!firstPoint.x.eq(prevPoint.x) || !firstPoint.y.eq(prevPoint.y)) {
            this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));
        }
    }
    getSweepEvents() {
        const sweepEvents = [];
        for(let i = 0, iMax = this.segments.length; i < iMax; i++){
            const segment = this.segments[i];
            sweepEvents.push(segment.leftSE);
            sweepEvents.push(segment.rightSE);
        }
        return sweepEvents;
    }
};
var PolyIn = class {
    multiPoly;
    exteriorRing;
    interiorRings;
    bbox;
    constructor(geomPoly, multiPoly){
        if (!Array.isArray(geomPoly)) {
            throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
        }
        this.exteriorRing = new RingIn(geomPoly[0], this, true);
        this.bbox = {
            ll: {
                x: this.exteriorRing.bbox.ll.x,
                y: this.exteriorRing.bbox.ll.y
            },
            ur: {
                x: this.exteriorRing.bbox.ur.x,
                y: this.exteriorRing.bbox.ur.y
            }
        };
        this.interiorRings = [];
        for(let i = 1, iMax = geomPoly.length; i < iMax; i++){
            const ring = new RingIn(geomPoly[i], this, false);
            if (ring.bbox.ll.x.isLessThan(this.bbox.ll.x)) this.bbox.ll.x = ring.bbox.ll.x;
            if (ring.bbox.ll.y.isLessThan(this.bbox.ll.y)) this.bbox.ll.y = ring.bbox.ll.y;
            if (ring.bbox.ur.x.isGreaterThan(this.bbox.ur.x)) this.bbox.ur.x = ring.bbox.ur.x;
            if (ring.bbox.ur.y.isGreaterThan(this.bbox.ur.y)) this.bbox.ur.y = ring.bbox.ur.y;
            this.interiorRings.push(ring);
        }
        this.multiPoly = multiPoly;
    }
    getSweepEvents() {
        const sweepEvents = this.exteriorRing.getSweepEvents();
        for(let i = 0, iMax = this.interiorRings.length; i < iMax; i++){
            const ringSweepEvents = this.interiorRings[i].getSweepEvents();
            for(let j = 0, jMax = ringSweepEvents.length; j < jMax; j++){
                sweepEvents.push(ringSweepEvents[j]);
            }
        }
        return sweepEvents;
    }
};
var MultiPolyIn = class {
    isSubject;
    polys;
    bbox;
    constructor(geom, isSubject){
        if (!Array.isArray(geom)) {
            throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
        }
        try {
            if (typeof geom[0][0][0] === "number") geom = [
                geom
            ];
        } catch (ex) {}
        this.polys = [];
        this.bbox = {
            ll: {
                x: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](Number.POSITIVE_INFINITY),
                y: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](Number.POSITIVE_INFINITY)
            },
            ur: {
                x: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](Number.NEGATIVE_INFINITY),
                y: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](Number.NEGATIVE_INFINITY)
            }
        };
        for(let i = 0, iMax = geom.length; i < iMax; i++){
            const poly = new PolyIn(geom[i], this);
            if (poly.bbox.ll.x.isLessThan(this.bbox.ll.x)) this.bbox.ll.x = poly.bbox.ll.x;
            if (poly.bbox.ll.y.isLessThan(this.bbox.ll.y)) this.bbox.ll.y = poly.bbox.ll.y;
            if (poly.bbox.ur.x.isGreaterThan(this.bbox.ur.x)) this.bbox.ur.x = poly.bbox.ur.x;
            if (poly.bbox.ur.y.isGreaterThan(this.bbox.ur.y)) this.bbox.ur.y = poly.bbox.ur.y;
            this.polys.push(poly);
        }
        this.isSubject = isSubject;
    }
    getSweepEvents() {
        const sweepEvents = [];
        for(let i = 0, iMax = this.polys.length; i < iMax; i++){
            const polySweepEvents = this.polys[i].getSweepEvents();
            for(let j = 0, jMax = polySweepEvents.length; j < jMax; j++){
                sweepEvents.push(polySweepEvents[j]);
            }
        }
        return sweepEvents;
    }
};
// src/index.ts
var union = (geom, ...moreGeoms)=>operation_default.run("union", geom, moreGeoms);
var intersection2 = (geom, ...moreGeoms)=>operation_default.run("intersection", geom, moreGeoms);
var xor = (geom, ...moreGeoms)=>operation_default.run("xor", geom, moreGeoms);
var difference = (geom, ...moreGeoms)=>operation_default.run("difference", geom, moreGeoms);
var setPrecision = precision.set;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/difference/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_difference_default),
    "difference": (()=>difference2)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/polyclip-ts/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
function difference2(features) {
    const geoms = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["geomEach"])(features, (geom)=>{
        geoms.push(geom.coordinates);
    });
    if (geoms.length < 2) {
        throw new Error("Must have at least two features");
    }
    const properties = features.features[0].properties || {};
    const differenced = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.difference(geoms[0], ...geoms.slice(1));
    if (differenced.length === 0) return null;
    if (differenced.length === 1) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])(differenced[0], properties);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiPolygon"])(differenced, properties);
}
var turf_difference_default = difference2;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/flatten/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_flatten_default),
    "flatten": (()=>flatten)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
;
function flatten(geojson) {
    if (!geojson) throw new Error("geojson is required");
    var results = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["flattenEach"])(geojson, function(feature) {
        results.push(feature);
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(results);
}
var turf_flatten_default = flatten;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/dissolve/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_dissolve_default),
    "dissolve": (()=>dissolve)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/polyclip-ts/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$flatten$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/flatten/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
;
function dissolve(fc, options = {}) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    const { propertyName } = options;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["collectionOf"])(fc, "Polygon", "dissolve");
    const outFeatures = [];
    if (!propertyName) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$flatten$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["flatten"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiPolygon"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.union.apply(null, // List of polygons expressed as Position[][][] a.k.a. Geom[]
        fc.features.map(function(f) {
            return f.geometry.coordinates;
        }))));
    } else {
        const uniquePropertyVals = {};
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"])(fc, function(feature) {
            if (feature.properties) {
                if (!Object.prototype.hasOwnProperty.call(uniquePropertyVals, feature.properties[propertyName])) {
                    uniquePropertyVals[feature.properties[propertyName]] = [];
                }
                uniquePropertyVals[feature.properties[propertyName]].push(feature);
            }
        });
        const vals = Object.keys(uniquePropertyVals);
        for(let i = 0; i < vals.length; i++){
            const mp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiPolygon"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.union.apply(null, // List of polygons expressed as Position[][][] a.k.a. Geom[]
            uniquePropertyVals[vals[i]].map(function(f) {
                return f.geometry.coordinates;
            })));
            if (mp && mp.properties) {
                mp.properties[propertyName] = vals[i];
                outFeatures.push(mp);
            }
        }
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$flatten$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["flatten"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(outFeatures));
}
var turf_dissolve_default = dissolve;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/distance-weight/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_distance_weight_default),
    "distanceWeight": (()=>distanceWeight),
    "pNormDistance": (()=>pNormDistance)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/centroid/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
function pNormDistance(feature1, feature2, p = 2) {
    const coordinate1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(feature1);
    const coordinate2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(feature2);
    const xDiff = coordinate1[0] - coordinate2[0];
    const yDiff = coordinate1[1] - coordinate2[1];
    if (p === 1) {
        return Math.abs(xDiff) + Math.abs(yDiff);
    }
    return Math.pow(Math.pow(xDiff, p) + Math.pow(yDiff, p), 1 / p);
}
function distanceWeight(fc, options) {
    var _a, _b;
    options = options || {};
    const threshold = options.threshold || 1e4;
    const p = options.p || 2;
    const binary = (_a = options.binary) != null ? _a : false;
    const alpha = options.alpha || -1;
    const rowTransform = (_b = options.standardization) != null ? _b : false;
    const features = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"])(fc, (feature)=>{
        features.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["centroid"])(feature));
    });
    const weights = [];
    for(let i = 0; i < features.length; i++){
        weights[i] = [];
    }
    for(let i = 0; i < features.length; i++){
        for(let j = i; j < features.length; j++){
            if (i === j) {
                weights[i][j] = 0;
            }
            const dis = pNormDistance(features[i], features[j], p);
            weights[i][j] = dis;
            weights[j][i] = dis;
        }
    }
    for(let i = 0; i < features.length; i++){
        for(let j = 0; j < features.length; j++){
            const dis = weights[i][j];
            if (dis === 0) {
                continue;
            }
            if (binary) {
                if (dis <= threshold) {
                    weights[i][j] = 1;
                } else {
                    weights[i][j] = 0;
                }
            } else {
                if (dis <= threshold) {
                    weights[i][j] = Math.pow(dis, alpha);
                } else {
                    weights[i][j] = 0;
                }
            }
        }
    }
    if (rowTransform) {
        for(let i = 0; i < features.length; i++){
            const rowSum = weights[i].reduce((sum, currentVal)=>{
                return sum + currentVal;
            }, 0);
            for(let j = 0; j < features.length; j++){
                weights[i][j] = weights[i][j] / rowSum;
            }
        }
    }
    return weights;
}
var turf_distance_weight_default = distanceWeight;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/rhumb-destination/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_rhumb_destination_default),
    "rhumbDestination": (()=>rhumbDestination)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
;
;
function rhumbDestination(origin, distance, bearing, options = {}) {
    const wasNegativeDistance = distance < 0;
    let distanceInMeters = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertLength"])(Math.abs(distance), options.units, "meters");
    if (wasNegativeDistance) distanceInMeters = -Math.abs(distanceInMeters);
    const coords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(origin);
    const destination = calculateRhumbDestination(coords, distanceInMeters, bearing);
    destination[0] += destination[0] - coords[0] > 180 ? -360 : coords[0] - destination[0] > 180 ? 360 : 0;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])(destination, options.properties);
}
function calculateRhumbDestination(origin, distance, bearing, radius) {
    radius = radius === void 0 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["earthRadius"] : Number(radius);
    const delta = distance / radius;
    const lambda1 = origin[0] * Math.PI / 180;
    const phi1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])(origin[1]);
    const theta = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])(bearing);
    const DeltaPhi = delta * Math.cos(theta);
    let phi2 = phi1 + DeltaPhi;
    if (Math.abs(phi2) > Math.PI / 2) {
        phi2 = phi2 > 0 ? Math.PI - phi2 : -Math.PI - phi2;
    }
    const DeltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
    const q = Math.abs(DeltaPsi) > 1e-11 ? DeltaPhi / DeltaPsi : Math.cos(phi1);
    const DeltaLambda = delta * Math.sin(theta) / q;
    const lambda2 = lambda1 + DeltaLambda;
    return [
        (lambda2 * 180 / Math.PI + 540) % 360 - 180,
        phi2 * 180 / Math.PI
    ];
}
var turf_rhumb_destination_default = rhumbDestination;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/rhumb-distance/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_rhumb_distance_default),
    "rhumbDistance": (()=>rhumbDistance)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
;
function rhumbDistance(from, to, options = {}) {
    const origin = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(from);
    const destination = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(to);
    destination[0] += destination[0] - origin[0] > 180 ? -360 : origin[0] - destination[0] > 180 ? 360 : 0;
    const distanceInMeters = calculateRhumbDistance(origin, destination);
    const distance = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertLength"])(distanceInMeters, "meters", options.units);
    return distance;
}
function calculateRhumbDistance(origin, destination, radius) {
    radius = radius === void 0 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["earthRadius"] : Number(radius);
    const R = radius;
    const phi1 = origin[1] * Math.PI / 180;
    const phi2 = destination[1] * Math.PI / 180;
    const DeltaPhi = phi2 - phi1;
    let DeltaLambda = Math.abs(destination[0] - origin[0]) * Math.PI / 180;
    if (DeltaLambda > Math.PI) {
        DeltaLambda -= 2 * Math.PI;
    }
    const DeltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
    const q = Math.abs(DeltaPsi) > 1e-11 ? DeltaPhi / DeltaPsi : Math.cos(phi1);
    const delta = Math.sqrt(DeltaPhi * DeltaPhi + q * q * DeltaLambda * DeltaLambda);
    const dist = delta * R;
    return dist;
}
var turf_rhumb_distance_default = rhumbDistance;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/transform-rotate/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_transform_rotate_default),
    "transformRotate": (()=>transformRotate)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/centroid/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rhumb-bearing/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rhumb-distance/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rhumb-destination/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
function transformRotate(geojson, angle, options) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    const pivot = options.pivot;
    const mutate = options.mutate;
    if (!geojson) throw new Error("geojson is required");
    if (angle === void 0 || angle === null || isNaN(angle)) throw new Error("angle is required");
    if (angle === 0) return geojson;
    const pivotCoord = pivot != null ? pivot : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["centroid"])(geojson);
    if (mutate === false || mutate === void 0) geojson = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(geojson);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coordEach"])(geojson, function(pointCoords) {
        const initialAngle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rhumbBearing"])(pivotCoord, pointCoords);
        const finalAngle = initialAngle + angle;
        const distance = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rhumbDistance"])(pivotCoord, pointCoords);
        const newCoords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rhumbDestination"])(pivotCoord, distance, finalAngle));
        pointCoords[0] = newCoords[0];
        pointCoords[1] = newCoords[1];
    });
    return geojson;
}
var turf_transform_rotate_default = transformRotate;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/ellipse/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_ellipse_default),
    "ellipse": (()=>ellipse)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rhumb-destination/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$transform$2d$rotate$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/transform-rotate/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
function ellipse(center, xSemiAxis, ySemiAxis, options) {
    options = options || {};
    const steps = options.steps || 64;
    const units = options.units || "kilometers";
    const angle = options.angle || 0;
    const pivot = options.pivot || center;
    const properties = options.properties || {};
    if (!center) throw new Error("center is required");
    if (!xSemiAxis) throw new Error("xSemiAxis is required");
    if (!ySemiAxis) throw new Error("ySemiAxis is required");
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options must be an object");
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(steps)) throw new Error("steps must be a number");
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(angle)) throw new Error("angle must be a number");
    const centerCoords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(center);
    if (units !== "degrees") {
        const xDest = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rhumbDestination"])(center, xSemiAxis, 90, {
            units
        });
        const yDest = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rhumbDestination"])(center, ySemiAxis, 0, {
            units
        });
        xSemiAxis = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(xDest)[0] - centerCoords[0];
        ySemiAxis = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(yDest)[1] - centerCoords[1];
    }
    const coordinates = [];
    for(let i = 0; i < steps; i += 1){
        const stepAngle = i * -360 / steps;
        let x = xSemiAxis * ySemiAxis / Math.sqrt(Math.pow(ySemiAxis, 2) + Math.pow(xSemiAxis, 2) * Math.pow(getTanDeg(stepAngle), 2));
        let y = xSemiAxis * ySemiAxis / Math.sqrt(Math.pow(xSemiAxis, 2) + Math.pow(ySemiAxis, 2) / Math.pow(getTanDeg(stepAngle), 2));
        if (stepAngle < -90 && stepAngle >= -270) x = -x;
        if (stepAngle < -180 && stepAngle >= -360) y = -y;
        if (units === "degrees") {
            const angleRad = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])(angle);
            const newx = x * Math.cos(angleRad) + y * Math.sin(angleRad);
            const newy = y * Math.cos(angleRad) - x * Math.sin(angleRad);
            x = newx;
            y = newy;
        }
        coordinates.push([
            x + centerCoords[0],
            y + centerCoords[1]
        ]);
    }
    coordinates.push(coordinates[0]);
    if (units === "degrees") {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])([
            coordinates
        ], properties);
    } else {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$transform$2d$rotate$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transformRotate"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])([
            coordinates
        ], properties), angle, {
            pivot
        });
    }
}
function getTanDeg(deg) {
    const rad = deg * Math.PI / 180;
    return Math.tan(rad);
}
var turf_ellipse_default = ellipse;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/envelope/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_envelope_default),
    "envelope": (()=>envelope)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox-polygon/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-client] (ecmascript)");
;
;
function envelope(geojson) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bboxPolygon"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bbox"])(geojson));
}
var turf_envelope_default = envelope;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/explode/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_explode_default),
    "explode": (()=>explode)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
;
function explode(geojson) {
    const points = [];
    if (geojson.type === "FeatureCollection") {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"])(geojson, function(feature) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coordEach"])(feature, function(coord) {
                points.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])(coord, feature.properties));
            });
        });
    } else if (geojson.type === "Feature") {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coordEach"])(geojson, function(coord) {
            points.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])(coord, geojson.properties));
        });
    } else {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coordEach"])(geojson, function(coord) {
            points.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])(coord));
        });
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(points);
}
var turf_explode_default = explode;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/flip/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_flip_default),
    "flip": (()=>flip)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
function flip(geojson, options) {
    var _a;
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    const mutate = (_a = options.mutate) != null ? _a : false;
    if (!geojson) throw new Error("geojson is required");
    if (mutate === false || mutate === void 0) geojson = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(geojson);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coordEach"])(geojson, function(coord) {
        var x = coord[0];
        var y = coord[1];
        coord[0] = y;
        coord[1] = x;
    });
    return geojson;
}
var turf_flip_default = flip;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/great-circle/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.js
__turbopack_esm__({
    "default": (()=>turf_great_circle_default),
    "greatCircle": (()=>greatCircle)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
;
// lib/arc.js
var D2R = Math.PI / 180;
var R2D = 180 / Math.PI;
var Coord = function(lon, lat) {
    this.lon = lon;
    this.lat = lat;
    this.x = D2R * lon;
    this.y = D2R * lat;
};
Coord.prototype.view = function() {
    return String(this.lon).slice(0, 4) + "," + String(this.lat).slice(0, 4);
};
Coord.prototype.antipode = function() {
    var anti_lat = -1 * this.lat;
    var anti_lon = this.lon < 0 ? 180 + this.lon : (180 - this.lon) * -1;
    return new Coord(anti_lon, anti_lat);
};
var LineString = function() {
    this.coords = [];
    this.length = 0;
};
LineString.prototype.move_to = function(coord) {
    this.length++;
    this.coords.push(coord);
};
var Arc = function(properties) {
    this.properties = properties || {};
    this.geometries = [];
};
Arc.prototype.json = function() {
    if (this.geometries.length <= 0) {
        return {
            geometry: {
                type: "LineString",
                coordinates: null
            },
            type: "Feature",
            properties: this.properties
        };
    } else if (this.geometries.length === 1) {
        return {
            geometry: {
                type: "LineString",
                coordinates: this.geometries[0].coords
            },
            type: "Feature",
            properties: this.properties
        };
    } else {
        var multiline = [];
        for(var i = 0; i < this.geometries.length; i++){
            multiline.push(this.geometries[i].coords);
        }
        return {
            geometry: {
                type: "MultiLineString",
                coordinates: multiline
            },
            type: "Feature",
            properties: this.properties
        };
    }
};
Arc.prototype.wkt = function() {
    var wkt_string = "";
    var wkt = "LINESTRING(";
    var collect = function(c) {
        wkt += c[0] + " " + c[1] + ",";
    };
    for(var i = 0; i < this.geometries.length; i++){
        if (this.geometries[i].coords.length === 0) {
            return "LINESTRING(empty)";
        } else {
            var coords = this.geometries[i].coords;
            coords.forEach(collect);
            wkt_string += wkt.substring(0, wkt.length - 1) + ")";
        }
    }
    return wkt_string;
};
var GreatCircle = function(start, end, properties) {
    if (!start || start.x === void 0 || start.y === void 0) {
        throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties");
    }
    if (!end || end.x === void 0 || end.y === void 0) {
        throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties");
    }
    this.start = new Coord(start.x, start.y);
    this.end = new Coord(end.x, end.y);
    this.properties = properties || {};
    var w = this.start.x - this.end.x;
    var h = this.start.y - this.end.y;
    var z = Math.pow(Math.sin(h / 2), 2) + Math.cos(this.start.y) * Math.cos(this.end.y) * Math.pow(Math.sin(w / 2), 2);
    this.g = 2 * Math.asin(Math.sqrt(z));
    if (this.g === Math.PI) {
        throw new Error("it appears " + start.view() + " and " + end.view() + " are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite");
    } else if (isNaN(this.g)) {
        throw new Error("could not calculate great circle between " + start + " and " + end);
    }
};
GreatCircle.prototype.interpolate = function(f) {
    var A = Math.sin((1 - f) * this.g) / Math.sin(this.g);
    var B = Math.sin(f * this.g) / Math.sin(this.g);
    var x = A * Math.cos(this.start.y) * Math.cos(this.start.x) + B * Math.cos(this.end.y) * Math.cos(this.end.x);
    var y = A * Math.cos(this.start.y) * Math.sin(this.start.x) + B * Math.cos(this.end.y) * Math.sin(this.end.x);
    var z = A * Math.sin(this.start.y) + B * Math.sin(this.end.y);
    var lat = R2D * Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));
    var lon = R2D * Math.atan2(y, x);
    return [
        lon,
        lat
    ];
};
GreatCircle.prototype.Arc = function(npoints, options) {
    var first_pass = [];
    if (!npoints || npoints <= 2) {
        first_pass.push([
            this.start.lon,
            this.start.lat
        ]);
        first_pass.push([
            this.end.lon,
            this.end.lat
        ]);
    } else {
        var delta = 1 / (npoints - 1);
        for(var i = 0; i < npoints; ++i){
            var step = delta * i;
            var pair = this.interpolate(step);
            first_pass.push(pair);
        }
    }
    var bHasBigDiff = false;
    var dfMaxSmallDiffLong = 0;
    var dfDateLineOffset = options && options.offset ? options.offset : 10;
    var dfLeftBorderX = 180 - dfDateLineOffset;
    var dfRightBorderX = -180 + dfDateLineOffset;
    var dfDiffSpace = 360 - dfDateLineOffset;
    for(var j = 1; j < first_pass.length; ++j){
        var dfPrevX = first_pass[j - 1][0];
        var dfX = first_pass[j][0];
        var dfDiffLong = Math.abs(dfX - dfPrevX);
        if (dfDiffLong > dfDiffSpace && (dfX > dfLeftBorderX && dfPrevX < dfRightBorderX || dfPrevX > dfLeftBorderX && dfX < dfRightBorderX)) {
            bHasBigDiff = true;
        } else if (dfDiffLong > dfMaxSmallDiffLong) {
            dfMaxSmallDiffLong = dfDiffLong;
        }
    }
    var poMulti = [];
    if (bHasBigDiff && dfMaxSmallDiffLong < dfDateLineOffset) {
        var poNewLS = [];
        poMulti.push(poNewLS);
        for(var k = 0; k < first_pass.length; ++k){
            var dfX0 = parseFloat(first_pass[k][0]);
            if (k > 0 && Math.abs(dfX0 - first_pass[k - 1][0]) > dfDiffSpace) {
                var dfX1 = parseFloat(first_pass[k - 1][0]);
                var dfY1 = parseFloat(first_pass[k - 1][1]);
                var dfX2 = parseFloat(first_pass[k][0]);
                var dfY2 = parseFloat(first_pass[k][1]);
                if (dfX1 > -180 && dfX1 < dfRightBorderX && dfX2 === 180 && k + 1 < first_pass.length && first_pass[k - 1][0] > -180 && first_pass[k - 1][0] < dfRightBorderX) {
                    poNewLS.push([
                        -180,
                        first_pass[k][1]
                    ]);
                    k++;
                    poNewLS.push([
                        first_pass[k][0],
                        first_pass[k][1]
                    ]);
                    continue;
                } else if (dfX1 > dfLeftBorderX && dfX1 < 180 && dfX2 === -180 && k + 1 < first_pass.length && first_pass[k - 1][0] > dfLeftBorderX && first_pass[k - 1][0] < 180) {
                    poNewLS.push([
                        180,
                        first_pass[k][1]
                    ]);
                    k++;
                    poNewLS.push([
                        first_pass[k][0],
                        first_pass[k][1]
                    ]);
                    continue;
                }
                if (dfX1 < dfRightBorderX && dfX2 > dfLeftBorderX) {
                    var tmpX = dfX1;
                    dfX1 = dfX2;
                    dfX2 = tmpX;
                    var tmpY = dfY1;
                    dfY1 = dfY2;
                    dfY2 = tmpY;
                }
                if (dfX1 > dfLeftBorderX && dfX2 < dfRightBorderX) {
                    dfX2 += 360;
                }
                if (dfX1 <= 180 && dfX2 >= 180 && dfX1 < dfX2) {
                    var dfRatio = (180 - dfX1) / (dfX2 - dfX1);
                    var dfY = dfRatio * dfY2 + (1 - dfRatio) * dfY1;
                    poNewLS.push([
                        first_pass[k - 1][0] > dfLeftBorderX ? 180 : -180,
                        dfY
                    ]);
                    poNewLS = [];
                    poNewLS.push([
                        first_pass[k - 1][0] > dfLeftBorderX ? -180 : 180,
                        dfY
                    ]);
                    poMulti.push(poNewLS);
                } else {
                    poNewLS = [];
                    poMulti.push(poNewLS);
                }
                poNewLS.push([
                    dfX0,
                    first_pass[k][1]
                ]);
            } else {
                poNewLS.push([
                    first_pass[k][0],
                    first_pass[k][1]
                ]);
            }
        }
    } else {
        var poNewLS0 = [];
        poMulti.push(poNewLS0);
        for(var l = 0; l < first_pass.length; ++l){
            poNewLS0.push([
                first_pass[l][0],
                first_pass[l][1]
            ]);
        }
    }
    var arc = new Arc(this.properties);
    for(var m = 0; m < poMulti.length; ++m){
        var line = new LineString();
        arc.geometries.push(line);
        var points = poMulti[m];
        for(var j0 = 0; j0 < points.length; ++j0){
            line.move_to(points[j0]);
        }
    }
    return arc;
};
// index.js
function greatCircle(start, end, options) {
    options = options || {};
    if (typeof options !== "object") throw new Error("options is invalid");
    var properties = options.properties;
    var npoints = options.npoints;
    var offset = options.offset;
    start = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(start);
    end = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(end);
    properties = properties || {};
    npoints = npoints || 100;
    if (start[0] === end[0] && start[1] === end[1]) {
        const arr = Array(npoints);
        arr.fill([
            start[0],
            start[1]
        ]);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineString"])(arr, properties);
    }
    offset = offset || 10;
    var generator = new GreatCircle({
        x: start[0],
        y: start[1]
    }, {
        x: end[0],
        y: end[1]
    }, properties);
    var line = generator.Arc(npoints, {
        offset
    });
    return line.json();
}
var turf_great_circle_default = greatCircle;
;
 /*!
 * Copyright (c) 2019, Dane Springmeyer
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in
 *       the documentation and/or other materials provided with the
 *       distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */  //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/intersect/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_intersect_default),
    "intersect": (()=>intersect)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/polyclip-ts/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
function intersect(features, options = {}) {
    const geoms = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["geomEach"])(features, (geom)=>{
        geoms.push(geom.coordinates);
    });
    if (geoms.length < 2) {
        throw new Error("Must specify at least 2 geometries");
    }
    const intersection2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.intersection(geoms[0], ...geoms.slice(1));
    if (intersection2.length === 0) return null;
    if (intersection2.length === 1) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])(intersection2[0], options.properties);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiPolygon"])(intersection2, options.properties);
}
var turf_intersect_default = intersect;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/hex-grid/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_hex_grid_default),
    "hexGrid": (()=>hexGrid)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/intersect/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
function hexGrid(bbox, cellSide, options = {}) {
    const clonedProperties = JSON.stringify(options.properties || {});
    const [west, south, east, north] = bbox;
    const centerY = (south + north) / 2;
    const centerX = (west + east) / 2;
    const xFraction = cellSide * 2 / (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])([
        west,
        centerY
    ], [
        east,
        centerY
    ], options);
    const cellWidth = xFraction * (east - west);
    const yFraction = cellSide * 2 / (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])([
        centerX,
        south
    ], [
        centerX,
        north
    ], options);
    const cellHeight = yFraction * (north - south);
    const radius = cellWidth / 2;
    const hex_width = radius * 2;
    const hex_height = Math.sqrt(3) / 2 * cellHeight;
    const box_width = east - west;
    const box_height = north - south;
    const x_interval = 3 / 4 * hex_width;
    const y_interval = hex_height;
    const x_span = (box_width - hex_width) / (hex_width - radius / 2);
    const x_count = Math.floor(x_span);
    const x_adjust = (x_count * x_interval - radius / 2 - box_width) / 2 - radius / 2 + x_interval / 2;
    const y_count = Math.floor((box_height - hex_height) / hex_height);
    let y_adjust = (box_height - y_count * hex_height) / 2;
    const hasOffsetY = y_count * hex_height - box_height > hex_height / 2;
    if (hasOffsetY) {
        y_adjust -= hex_height / 4;
    }
    const cosines = [];
    const sines = [];
    for(let i = 0; i < 6; i++){
        const angle = 2 * Math.PI / 6 * i;
        cosines.push(Math.cos(angle));
        sines.push(Math.sin(angle));
    }
    const results = [];
    for(let x = 0; x <= x_count; x++){
        for(let y = 0; y <= y_count; y++){
            const isOdd = x % 2 === 1;
            if (y === 0 && isOdd) continue;
            if (y === 0 && hasOffsetY) continue;
            const center_x = x * x_interval + west - x_adjust;
            let center_y = y * y_interval + south + y_adjust;
            if (isOdd) {
                center_y -= hex_height / 2;
            }
            if (options.triangles === true) {
                hexTriangles([
                    center_x,
                    center_y
                ], cellWidth / 2, cellHeight / 2, JSON.parse(clonedProperties), cosines, sines).forEach(function(triangle) {
                    if (options.mask) {
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["intersect"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])([
                            options.mask,
                            triangle
                        ]))) results.push(triangle);
                    } else {
                        results.push(triangle);
                    }
                });
            } else {
                const hex = hexagon([
                    center_x,
                    center_y
                ], cellWidth / 2, cellHeight / 2, JSON.parse(clonedProperties), cosines, sines);
                if (options.mask) {
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["intersect"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])([
                        options.mask,
                        hex
                    ]))) results.push(hex);
                } else {
                    results.push(hex);
                }
            }
        }
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(results);
}
function hexagon(center, rx, ry, properties, cosines, sines) {
    const vertices = [];
    for(let i = 0; i < 6; i++){
        const x = center[0] + rx * cosines[i];
        const y = center[1] + ry * sines[i];
        vertices.push([
            x,
            y
        ]);
    }
    vertices.push(vertices[0].slice());
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])([
        vertices
    ], properties);
}
function hexTriangles(center, rx, ry, properties, cosines, sines) {
    const triangles = [];
    for(let i = 0; i < 6; i++){
        const vertices = [];
        vertices.push(center);
        vertices.push([
            center[0] + rx * cosines[i],
            center[1] + ry * sines[i]
        ]);
        vertices.push([
            center[0] + rx * cosines[(i + 1) % 6],
            center[1] + ry * sines[(i + 1) % 6]
        ]);
        vertices.push(center);
        triangles.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])([
            vertices
        ], properties));
    }
    return triangles;
}
var turf_hex_grid_default = hexGrid;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/point-grid/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_point_grid_default),
    "pointGrid": (()=>pointGrid)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$within$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-within/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
function pointGrid(bbox, cellSide, options = {}) {
    if (options.mask && !options.units) options.units = "kilometers";
    var results = [];
    var west = bbox[0];
    var south = bbox[1];
    var east = bbox[2];
    var north = bbox[3];
    var xFraction = cellSide / (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])([
        west,
        south
    ], [
        east,
        south
    ], options);
    var cellWidth = xFraction * (east - west);
    var yFraction = cellSide / (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])([
        west,
        south
    ], [
        west,
        north
    ], options);
    var cellHeight = yFraction * (north - south);
    var bboxWidth = east - west;
    var bboxHeight = north - south;
    var columns = Math.floor(bboxWidth / cellWidth);
    var rows = Math.floor(bboxHeight / cellHeight);
    var deltaX = (bboxWidth - columns * cellWidth) / 2;
    var deltaY = (bboxHeight - rows * cellHeight) / 2;
    var currentX = west + deltaX;
    while(currentX <= east){
        var currentY = south + deltaY;
        while(currentY <= north){
            var cellPt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])([
                currentX,
                currentY
            ], options.properties);
            if (options.mask) {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$within$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanWithin"])(cellPt, options.mask)) results.push(cellPt);
            } else {
                results.push(cellPt);
            }
            currentY += cellHeight;
        }
        currentX += cellWidth;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(results);
}
var turf_point_grid_default = pointGrid;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/rectangle-grid/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_rectangle_grid_default),
    "rectangleGrid": (()=>rectangleGrid)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$intersects$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-intersects/dist/esm/index.js [app-client] (ecmascript)");
;
;
function rectangleGrid(bbox, cellWidth, cellHeight, options = {}) {
    const results = [];
    const west = bbox[0];
    const south = bbox[1];
    const east = bbox[2];
    const north = bbox[3];
    const bboxWidth = east - west;
    const cellWidthDeg = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertLength"])(cellWidth, options.units, "degrees");
    const bboxHeight = north - south;
    const cellHeightDeg = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertLength"])(cellHeight, options.units, "degrees");
    const columns = Math.floor(Math.abs(bboxWidth) / cellWidthDeg);
    const rows = Math.floor(Math.abs(bboxHeight) / cellHeightDeg);
    const deltaX = (bboxWidth - columns * cellWidthDeg) / 2;
    const deltaY = (bboxHeight - rows * cellHeightDeg) / 2;
    let currentX = west + deltaX;
    for(let column = 0; column < columns; column++){
        let currentY = south + deltaY;
        for(let row = 0; row < rows; row++){
            const cellPoly = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])([
                [
                    [
                        currentX,
                        currentY
                    ],
                    [
                        currentX,
                        currentY + cellHeightDeg
                    ],
                    [
                        currentX + cellWidthDeg,
                        currentY + cellHeightDeg
                    ],
                    [
                        currentX + cellWidthDeg,
                        currentY
                    ],
                    [
                        currentX,
                        currentY
                    ]
                ]
            ], options.properties);
            if (options.mask) {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$intersects$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanIntersects"])(options.mask, cellPoly)) {
                    results.push(cellPoly);
                }
            } else {
                results.push(cellPoly);
            }
            currentY += cellHeightDeg;
        }
        currentX += cellWidthDeg;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(results);
}
var turf_rectangle_grid_default = rectangleGrid;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/square-grid/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_square_grid_default),
    "squareGrid": (()=>squareGrid)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rectangle$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rectangle-grid/dist/esm/index.js [app-client] (ecmascript)");
;
function squareGrid(bbox, cellSide, options = {}) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rectangle$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rectangleGrid"])(bbox, cellSide, cellSide, options);
}
var turf_square_grid_default = squareGrid;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/triangle-grid/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_triangle_grid_default),
    "triangleGrid": (()=>triangleGrid)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/intersect/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
function triangleGrid(bbox, cellSide, options = {}) {
    var results = [];
    var xFraction = cellSide / (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])([
        bbox[0],
        bbox[1]
    ], [
        bbox[2],
        bbox[1]
    ], options);
    var cellWidth = xFraction * (bbox[2] - bbox[0]);
    var yFraction = cellSide / (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])([
        bbox[0],
        bbox[1]
    ], [
        bbox[0],
        bbox[3]
    ], options);
    var cellHeight = yFraction * (bbox[3] - bbox[1]);
    var xi = 0;
    var currentX = bbox[0];
    while(currentX <= bbox[2]){
        var yi = 0;
        var currentY = bbox[1];
        while(currentY <= bbox[3]){
            var cellTriangle1 = null;
            var cellTriangle2 = null;
            if (xi % 2 === 0 && yi % 2 === 0) {
                cellTriangle1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])([
                    [
                        [
                            currentX,
                            currentY
                        ],
                        [
                            currentX,
                            currentY + cellHeight
                        ],
                        [
                            currentX + cellWidth,
                            currentY
                        ],
                        [
                            currentX,
                            currentY
                        ]
                    ]
                ], options.properties);
                cellTriangle2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])([
                    [
                        [
                            currentX,
                            currentY + cellHeight
                        ],
                        [
                            currentX + cellWidth,
                            currentY + cellHeight
                        ],
                        [
                            currentX + cellWidth,
                            currentY
                        ],
                        [
                            currentX,
                            currentY + cellHeight
                        ]
                    ]
                ], options.properties);
            } else if (xi % 2 === 0 && yi % 2 === 1) {
                cellTriangle1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])([
                    [
                        [
                            currentX,
                            currentY
                        ],
                        [
                            currentX + cellWidth,
                            currentY + cellHeight
                        ],
                        [
                            currentX + cellWidth,
                            currentY
                        ],
                        [
                            currentX,
                            currentY
                        ]
                    ]
                ], options.properties);
                cellTriangle2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])([
                    [
                        [
                            currentX,
                            currentY
                        ],
                        [
                            currentX,
                            currentY + cellHeight
                        ],
                        [
                            currentX + cellWidth,
                            currentY + cellHeight
                        ],
                        [
                            currentX,
                            currentY
                        ]
                    ]
                ], options.properties);
            } else if (yi % 2 === 0 && xi % 2 === 1) {
                cellTriangle1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])([
                    [
                        [
                            currentX,
                            currentY
                        ],
                        [
                            currentX,
                            currentY + cellHeight
                        ],
                        [
                            currentX + cellWidth,
                            currentY + cellHeight
                        ],
                        [
                            currentX,
                            currentY
                        ]
                    ]
                ], options.properties);
                cellTriangle2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])([
                    [
                        [
                            currentX,
                            currentY
                        ],
                        [
                            currentX + cellWidth,
                            currentY + cellHeight
                        ],
                        [
                            currentX + cellWidth,
                            currentY
                        ],
                        [
                            currentX,
                            currentY
                        ]
                    ]
                ], options.properties);
            } else if (yi % 2 === 1 && xi % 2 === 1) {
                cellTriangle1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])([
                    [
                        [
                            currentX,
                            currentY
                        ],
                        [
                            currentX,
                            currentY + cellHeight
                        ],
                        [
                            currentX + cellWidth,
                            currentY
                        ],
                        [
                            currentX,
                            currentY
                        ]
                    ]
                ], options.properties);
                cellTriangle2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])([
                    [
                        [
                            currentX,
                            currentY + cellHeight
                        ],
                        [
                            currentX + cellWidth,
                            currentY + cellHeight
                        ],
                        [
                            currentX + cellWidth,
                            currentY
                        ],
                        [
                            currentX,
                            currentY + cellHeight
                        ]
                    ]
                ], options.properties);
            }
            if (options.mask) {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["intersect"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])([
                    options.mask,
                    cellTriangle1
                ]))) results.push(cellTriangle1);
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["intersect"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])([
                    options.mask,
                    cellTriangle2
                ]))) results.push(cellTriangle2);
            } else {
                results.push(cellTriangle1);
                results.push(cellTriangle2);
            }
            currentY += cellHeight;
            yi++;
        }
        xi++;
        currentX += cellWidth;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(results);
}
var turf_triangle_grid_default = triangleGrid;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/interpolate/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.js
__turbopack_esm__({
    "default": (()=>turf_interpolate_default),
    "interpolate": (()=>interpolate)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$point$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/point-grid/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$square$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/square-grid/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$hex$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/hex-grid/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$triangle$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/triangle-grid/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/centroid/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
function interpolate(points, cellSize, options) {
    options = options || {};
    if (typeof options !== "object") throw new Error("options is invalid");
    var gridType = options.gridType;
    var property = options.property;
    var weight = options.weight;
    var box = options.bbox;
    if (!points) throw new Error("points is required");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["collectionOf"])(points, "Point", "input must contain Points");
    if (!cellSize) throw new Error("cellSize is required");
    if (weight !== void 0 && typeof weight !== "number") throw new Error("weight must be a number");
    property = property || "elevation";
    gridType = gridType || "square";
    weight = weight || 1;
    box = box != null ? box : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bbox"])(points);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateBBox"])(box);
    var grid;
    switch(gridType){
        case "point":
        case "points":
            grid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$point$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pointGrid"])(box, cellSize, options);
            break;
        case "square":
        case "squares":
            grid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$square$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["squareGrid"])(box, cellSize, options);
            break;
        case "hex":
        case "hexes":
            grid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$hex$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hexGrid"])(box, cellSize, options);
            break;
        case "triangle":
        case "triangles":
            grid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$triangle$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["triangleGrid"])(box, cellSize, options);
            break;
        default:
            throw new Error("invalid gridType");
    }
    var results = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"])(grid, function(gridFeature) {
        var zw = 0;
        var sw = 0;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"])(points, function(point) {
            var gridPoint = gridType === "point" ? gridFeature : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["centroid"])(gridFeature);
            var d = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(gridPoint, point, options);
            var zValue;
            if (property !== void 0) zValue = point.properties[property];
            if (zValue === void 0) zValue = point.geometry.coordinates[2];
            if (zValue === void 0) throw new Error("zValue is missing");
            if (d === 0) zw = zValue;
            var w = 1 / Math.pow(d, weight);
            sw += w;
            zw += w * zValue;
        });
        var newFeature = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(gridFeature);
        newFeature.properties[property] = zw / sw;
        results.push(newFeature);
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(results);
}
var turf_interpolate_default = interpolate;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/isobands/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>turf_isobands_default),
    "isobands": (()=>isobands)
});
// index.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$marchingsquares$2f$dist$2f$marchingsquares$2d$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/marchingsquares/dist/marchingsquares-esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
// lib/grid-to-matrix.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
// index.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$area$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/area/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$explode$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/explode/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [app-client] (ecmascript)");
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
;
;
;
;
;
;
;
;
;
function gridToMatrix(grid, options) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    var zProperty = options.zProperty || "elevation";
    var flip = options.flip;
    var flags = options.flags;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["collectionOf"])(grid, "Point", "input must contain Points");
    var pointsMatrix = sortPointsByLatLng(grid, flip);
    var matrix = [];
    for(var r = 0; r < pointsMatrix.length; r++){
        var pointRow = pointsMatrix[r];
        var row = [];
        for(var c = 0; c < pointRow.length; c++){
            var point = pointRow[c];
            if (point.properties[zProperty]) row.push(point.properties[zProperty]);
            else row.push(0);
            if (flags === true) point.properties.matrixPosition = [
                r,
                c
            ];
        }
        matrix.push(row);
    }
    return matrix;
}
function sortPointsByLatLng(points, flip) {
    var pointsByLatitude = {};
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"])(points, function(point) {
        var lat = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(point)[1];
        if (!pointsByLatitude[lat]) pointsByLatitude[lat] = [];
        pointsByLatitude[lat].push(point);
    });
    var orderedRowsByLatitude = Object.keys(pointsByLatitude).map(function(lat) {
        var row = pointsByLatitude[lat];
        var rowOrderedByLongitude = row.sort(function(a, b) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(a)[0] - (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(b)[0];
        });
        return rowOrderedByLongitude;
    });
    var pointMatrix = orderedRowsByLatitude.sort(function(a, b) {
        if (flip) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(a[0])[1] - (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(b[0])[1];
        else return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(b[0])[1] - (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(a[0])[1];
    });
    return pointMatrix;
}
;
function isobands(pointGrid, breaks, options) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    const zProperty = options.zProperty || "elevation";
    const commonProperties = options.commonProperties || {};
    const breaksProperties = options.breaksProperties || [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["collectionOf"])(pointGrid, "Point", "Input must contain Points");
    if (!breaks) throw new Error("breaks is required");
    if (!Array.isArray(breaks)) throw new Error("breaks is not an Array");
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(commonProperties)) throw new Error("commonProperties is not an Object");
    if (!Array.isArray(breaksProperties)) throw new Error("breaksProperties is not an Array");
    const matrix = gridToMatrix(pointGrid, {
        zProperty,
        flip: true
    });
    let contours = createContourLines(matrix, breaks, zProperty);
    contours = rescaleContours(contours, matrix, pointGrid);
    const multipolygons = contours.map((contour, index)=>{
        if (breaksProperties[index] && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(breaksProperties[index])) {
            throw new Error("Each mappedProperty is required to be an Object");
        }
        const contourProperties = __spreadValues(__spreadValues({}, commonProperties), breaksProperties[index]);
        contourProperties[zProperty] = contour[zProperty];
        const multiP = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiPolygon"])(contour.groupedRings, contourProperties);
        return multiP;
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(multipolygons);
}
function createContourLines(matrix, breaks, property) {
    const contours = [];
    for(let i = 1; i < breaks.length; i++){
        const lowerBand = +breaks[i - 1];
        const upperBand = +breaks[i];
        const isobandsCoords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$marchingsquares$2f$dist$2f$marchingsquares$2d$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isoBands"])(matrix, lowerBand, upperBand - lowerBand);
        const nestedRings = orderByArea(isobandsCoords);
        const groupedRings = groupNestedRings(nestedRings);
        contours.push({
            groupedRings,
            [property]: lowerBand + "-" + upperBand
        });
    }
    return contours;
}
function rescaleContours(contours, matrix, points) {
    const gridBbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bbox"])(points);
    const originalWidth = gridBbox[2] - gridBbox[0];
    const originalHeigth = gridBbox[3] - gridBbox[1];
    const x0 = gridBbox[0];
    const y0 = gridBbox[1];
    const matrixWidth = matrix[0].length - 1;
    const matrixHeight = matrix.length - 1;
    const scaleX = originalWidth / matrixWidth;
    const scaleY = originalHeigth / matrixHeight;
    return contours.map(function(contour) {
        contour.groupedRings = contour.groupedRings.map(function(lineRingSet) {
            return lineRingSet.map(function(lineRing) {
                return lineRing.map((point)=>[
                        point[0] * scaleX + x0,
                        point[1] * scaleY + y0
                    ]);
            });
        });
        return contour;
    });
}
function orderByArea(ringsCoords) {
    const ringsWithArea = ringsCoords.map(function(coords) {
        return {
            ring: coords,
            area: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$area$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["area"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])([
                coords
            ]))
        };
    });
    ringsWithArea.sort(function(a, b) {
        return b.area - a.area;
    });
    return ringsWithArea.map(function(x) {
        return x.ring;
    });
}
function groupNestedRings(orderedLinearRings) {
    const lrList = orderedLinearRings.map((lr)=>{
        return {
            lrCoordinates: lr,
            grouped: false
        };
    });
    const groupedLinearRingsCoords = [];
    while(!allGrouped(lrList)){
        for(let i = 0; i < lrList.length; i++){
            if (!lrList[i].grouped) {
                const group = [];
                group.push(lrList[i].lrCoordinates);
                lrList[i].grouped = true;
                const outerMostPoly = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])([
                    lrList[i].lrCoordinates
                ]);
                for(let j = i + 1; j < lrList.length; j++){
                    if (!lrList[j].grouped) {
                        const lrPoly = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])([
                            lrList[j].lrCoordinates
                        ]);
                        if (isInside(lrPoly, outerMostPoly)) {
                            group.push(lrList[j].lrCoordinates);
                            lrList[j].grouped = true;
                        }
                    }
                }
                groupedLinearRingsCoords.push(group);
            }
        }
    }
    return groupedLinearRingsCoords;
}
function isInside(testPolygon, targetPolygon) {
    const points = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$explode$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["explode"])(testPolygon);
    for(let i = 0; i < points.features.length; i++){
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(points.features[i], targetPolygon)) {
            return false;
        }
    }
    return true;
}
function allGrouped(list) {
    for(let i = 0; i < list.length; i++){
        if (list[i].grouped === false) {
            return false;
        }
    }
    return true;
}
var turf_isobands_default = isobands;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/isolines/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>turf_isolines_default),
    "isolines": (()=>isolines)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$marchingsquares$2f$dist$2f$marchingsquares$2d$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/marchingsquares/dist/marchingsquares-esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
// lib/grid-to-matrix.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
// index.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-client] (ecmascript)");
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
;
;
;
;
;
;
;
;
function gridToMatrix(grid, options) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    var zProperty = options.zProperty || "elevation";
    var flip = options.flip;
    var flags = options.flags;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["collectionOf"])(grid, "Point", "input must contain Points");
    var pointsMatrix = sortPointsByLatLng(grid, flip);
    var matrix = [];
    for(var r = 0; r < pointsMatrix.length; r++){
        var pointRow = pointsMatrix[r];
        var row = [];
        for(var c = 0; c < pointRow.length; c++){
            var point = pointRow[c];
            if (point.properties[zProperty]) row.push(point.properties[zProperty]);
            else row.push(0);
            if (flags === true) point.properties.matrixPosition = [
                r,
                c
            ];
        }
        matrix.push(row);
    }
    return matrix;
}
function sortPointsByLatLng(points, flip) {
    var pointsByLatitude = {};
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"])(points, function(point) {
        var lat = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(point)[1];
        if (!pointsByLatitude[lat]) pointsByLatitude[lat] = [];
        pointsByLatitude[lat].push(point);
    });
    var orderedRowsByLatitude = Object.keys(pointsByLatitude).map(function(lat) {
        var row = pointsByLatitude[lat];
        var rowOrderedByLongitude = row.sort(function(a, b) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(a)[0] - (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(b)[0];
        });
        return rowOrderedByLongitude;
    });
    var pointMatrix = orderedRowsByLatitude.sort(function(a, b) {
        if (flip) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(a[0])[1] - (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(b[0])[1];
        else return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(b[0])[1] - (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(a[0])[1];
    });
    return pointMatrix;
}
// index.ts
function isolines(pointGrid, breaks, options) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    const zProperty = options.zProperty || "elevation";
    const commonProperties = options.commonProperties || {};
    const breaksProperties = options.breaksProperties || [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["collectionOf"])(pointGrid, "Point", "Input must contain Points");
    if (!breaks) throw new Error("breaks is required");
    if (!Array.isArray(breaks)) throw new Error("breaks must be an Array");
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(commonProperties)) throw new Error("commonProperties must be an Object");
    if (!Array.isArray(breaksProperties)) throw new Error("breaksProperties must be an Array");
    const matrix = gridToMatrix(pointGrid, {
        zProperty,
        flip: true
    });
    const createdIsoLines = createIsoLines(matrix, breaks, zProperty, commonProperties, breaksProperties);
    const scaledIsolines = rescaleIsolines(createdIsoLines, matrix, pointGrid);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(scaledIsolines);
}
function createIsoLines(matrix, breaks, zProperty, commonProperties, breaksProperties) {
    const results = [];
    for(let i = 0; i < breaks.length; i++){
        const threshold = +breaks[i];
        const properties = __spreadValues(__spreadValues({}, commonProperties), breaksProperties[i]);
        properties[zProperty] = threshold;
        const isoline = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiLineString"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$marchingsquares$2f$dist$2f$marchingsquares$2d$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isoContours"])(matrix, threshold, {
            linearRing: false,
            noFrame: true
        }), properties);
        results.push(isoline);
    }
    return results;
}
function rescaleIsolines(createdIsoLines, matrix, points) {
    const gridBbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bbox"])(points);
    const originalWidth = gridBbox[2] - gridBbox[0];
    const originalHeigth = gridBbox[3] - gridBbox[1];
    const x0 = gridBbox[0];
    const y0 = gridBbox[1];
    const matrixWidth = matrix[0].length - 1;
    const matrixHeight = matrix.length - 1;
    const scaleX = originalWidth / matrixWidth;
    const scaleY = originalHeigth / matrixHeight;
    const resize = (point)=>{
        point[0] = point[0] * scaleX + x0;
        point[1] = point[1] * scaleY + y0;
    };
    createdIsoLines.forEach((isoline)=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coordEach"])(isoline, resize);
    });
    return createdIsoLines;
}
var turf_isolines_default = isolines;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/kinks/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_kinks_default),
    "kinks": (()=>kinks)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
function kinks(featureIn) {
    let coordinates;
    let feature;
    const results = {
        type: "FeatureCollection",
        features: []
    };
    if (featureIn.type === "Feature") {
        feature = featureIn.geometry;
    } else {
        feature = featureIn;
    }
    if (feature.type === "LineString") {
        coordinates = [
            feature.coordinates
        ];
    } else if (feature.type === "MultiLineString") {
        coordinates = feature.coordinates;
    } else if (feature.type === "MultiPolygon") {
        coordinates = [].concat(...feature.coordinates);
    } else if (feature.type === "Polygon") {
        coordinates = feature.coordinates;
    } else {
        throw new Error("Input must be a LineString, MultiLineString, Polygon, or MultiPolygon Feature or Geometry");
    }
    coordinates.forEach((line1)=>{
        coordinates.forEach((line2)=>{
            for(let i = 0; i < line1.length - 1; i++){
                for(let k = i; k < line2.length - 1; k++){
                    if (line1 === line2) {
                        if (Math.abs(i - k) === 1) {
                            continue;
                        }
                        if (// segments are first and last segment of lineString
                        i === 0 && k === line1.length - 2 && // lineString is closed
                        line1[i][0] === line1[line1.length - 1][0] && line1[i][1] === line1[line1.length - 1][1]) {
                            continue;
                        }
                    }
                    const intersection = lineIntersects(line1[i][0], line1[i][1], line1[i + 1][0], line1[i + 1][1], line2[k][0], line2[k][1], line2[k + 1][0], line2[k + 1][1]);
                    if (intersection) {
                        results.features.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])([
                            intersection[0],
                            intersection[1]
                        ]));
                    }
                }
            }
        });
    });
    return results;
}
function lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
    let denominator;
    let a;
    let b;
    let numerator1;
    let numerator2;
    const result = {
        x: null,
        y: null,
        onLine1: false,
        onLine2: false
    };
    denominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY);
    if (denominator === 0) {
        if (result.x !== null && result.y !== null) {
            return result;
        } else {
            return false;
        }
    }
    a = line1StartY - line2StartY;
    b = line1StartX - line2StartX;
    numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;
    numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;
    a = numerator1 / denominator;
    b = numerator2 / denominator;
    result.x = line1StartX + a * (line1EndX - line1StartX);
    result.y = line1StartY + a * (line1EndY - line1StartY);
    if (a >= 0 && a <= 1) {
        result.onLine1 = true;
    }
    if (b >= 0 && b <= 1) {
        result.onLine2 = true;
    }
    if (result.onLine1 && result.onLine2) {
        return [
            result.x,
            result.y
        ];
    } else {
        return false;
    }
}
var turf_kinks_default = kinks;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/length/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_length_default),
    "length": (()=>length)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-client] (ecmascript)");
;
;
function length(geojson, options = {}) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["segmentReduce"])(geojson, (previousValue, segment)=>{
        const coords = segment.geometry.coordinates;
        return previousValue + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(coords[0], coords[1], options);
    }, 0);
}
var turf_length_default = length;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/line-arc/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_line_arc_default),
    "lineArc": (()=>lineArc)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/destination/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$circle$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/circle/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
function lineArc(center, radius, bearing1, bearing2, options = {}) {
    const steps = options.steps || 64;
    const angle1 = convertAngleTo360(bearing1);
    const angle2 = convertAngleTo360(bearing2);
    const properties = !Array.isArray(center) && center.type === "Feature" ? center.properties : {};
    if (angle1 === angle2) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineString"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$circle$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["circle"])(center, radius, options).geometry.coordinates[0], properties);
    }
    const arcStartDegree = angle1;
    const arcEndDegree = angle1 < angle2 ? angle2 : angle2 + 360;
    let alpha = arcStartDegree;
    const coordinates = [];
    let i = 0;
    const arcStep = (arcEndDegree - arcStartDegree) / steps;
    while(alpha <= arcEndDegree){
        coordinates.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["destination"])(center, radius, alpha, options).geometry.coordinates);
        i++;
        alpha = arcStartDegree + i * arcStep;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineString"])(coordinates, properties);
}
function convertAngleTo360(alpha) {
    let beta = alpha % 360;
    if (beta < 0) {
        beta += 360;
    }
    return beta;
}
var turf_line_arc_default = lineArc;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/line-slice-along/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.js
__turbopack_esm__({
    "default": (()=>turf_line_slice_along_default),
    "lineSliceAlong": (()=>lineSliceAlong)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bearing/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/destination/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
function lineSliceAlong(line, startDist, stopDist, options) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    var coords;
    var slice = [];
    if (line.type === "Feature") coords = line.geometry.coordinates;
    else if (line.type === "LineString") coords = line.coordinates;
    else throw new Error("input must be a LineString Feature or Geometry");
    var origCoordsLength = coords.length;
    var travelled = 0;
    var overshot, direction, interpolated;
    for(var i = 0; i < coords.length; i++){
        if (startDist >= travelled && i === coords.length - 1) break;
        else if (travelled > startDist && slice.length === 0) {
            overshot = startDist - travelled;
            if (!overshot) {
                slice.push(coords[i]);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineString"])(slice);
            }
            direction = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bearing"])(coords[i], coords[i - 1]) - 180;
            interpolated = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["destination"])(coords[i], overshot, direction, options);
            slice.push(interpolated.geometry.coordinates);
        }
        if (travelled >= stopDist) {
            overshot = stopDist - travelled;
            if (!overshot) {
                slice.push(coords[i]);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineString"])(slice);
            }
            direction = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bearing"])(coords[i], coords[i - 1]) - 180;
            interpolated = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["destination"])(coords[i], overshot, direction, options);
            slice.push(interpolated.geometry.coordinates);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineString"])(slice);
        }
        if (travelled >= startDist) {
            slice.push(coords[i]);
        }
        if (i === coords.length - 1) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineString"])(slice);
        }
        travelled += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(coords[i], coords[i + 1], options);
    }
    if (travelled < startDist && coords.length === origCoordsLength) throw new Error("Start position is beyond line");
    var last = coords[coords.length - 1];
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineString"])([
        last,
        last
    ]);
}
var turf_line_slice_along_default = lineSliceAlong;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/line-chunk/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.js
__turbopack_esm__({
    "default": (()=>turf_line_chunk_default),
    "lineChunk": (()=>lineChunk)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$length$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/length/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$slice$2d$along$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-slice-along/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
function lineChunk(geojson, segmentLength, options) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    var units = options.units;
    var reverse = options.reverse;
    if (!geojson) throw new Error("geojson is required");
    if (segmentLength <= 0) throw new Error("segmentLength must be greater than 0");
    var results = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["flattenEach"])(geojson, function(feature) {
        if (reverse) feature.geometry.coordinates = feature.geometry.coordinates.reverse();
        sliceLineSegments(feature, segmentLength, units, function(segment) {
            results.push(segment);
        });
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(results);
}
function sliceLineSegments(line, segmentLength, units, callback) {
    var lineLength = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$length$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["length"])(line, {
        units
    });
    if (lineLength <= segmentLength) return callback(line);
    var numberOfSegments = lineLength / segmentLength;
    if (!Number.isInteger(numberOfSegments)) {
        numberOfSegments = Math.floor(numberOfSegments) + 1;
    }
    for(var i = 0; i < numberOfSegments; i++){
        var outline = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$slice$2d$along$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineSliceAlong"])(line, segmentLength * i, segmentLength * (i + 1), {
            units
        });
        callback(outline, i);
    }
}
var turf_line_chunk_default = lineChunk;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/line-offset/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.js
__turbopack_esm__({
    "default": (()=>turf_line_offset_default),
    "lineOffset": (()=>lineOffset)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
// lib/intersection.js
function ab(segment) {
    var start = segment[0];
    var end = segment[1];
    return [
        end[0] - start[0],
        end[1] - start[1]
    ];
}
function crossProduct(v1, v2) {
    return v1[0] * v2[1] - v2[0] * v1[1];
}
function add(v1, v2) {
    return [
        v1[0] + v2[0],
        v1[1] + v2[1]
    ];
}
function sub(v1, v2) {
    return [
        v1[0] - v2[0],
        v1[1] - v2[1]
    ];
}
function scalarMult(s, v) {
    return [
        s * v[0],
        s * v[1]
    ];
}
function intersectSegments(a, b) {
    var p = a[0];
    var r = ab(a);
    var q = b[0];
    var s = ab(b);
    var cross = crossProduct(r, s);
    var qmp = sub(q, p);
    var numerator = crossProduct(qmp, s);
    var t = numerator / cross;
    var intersection2 = add(p, scalarMult(t, r));
    return intersection2;
}
function isParallel(a, b) {
    var r = ab(a);
    var s = ab(b);
    return crossProduct(r, s) === 0;
}
function intersection(a, b) {
    if (isParallel(a, b)) return false;
    return intersectSegments(a, b);
}
// index.js
function lineOffset(geojson, distance, options) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    var units = options.units;
    if (!geojson) throw new Error("geojson is required");
    if (distance === void 0 || distance === null || isNaN(distance)) throw new Error("distance is required");
    var type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getType"])(geojson);
    var properties = geojson.properties;
    switch(type){
        case "LineString":
            return lineOffsetFeature(geojson, distance, units);
        case "MultiLineString":
            var coords = [];
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["flattenEach"])(geojson, function(feature) {
                coords.push(lineOffsetFeature(feature, distance, units).geometry.coordinates);
            });
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiLineString"])(coords, properties);
        default:
            throw new Error("geometry " + type + " is not supported");
    }
}
function lineOffsetFeature(line, distance, units) {
    var segments = [];
    var offsetDegrees = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lengthToDegrees"])(distance, units);
    var coords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(line);
    var finalCoords = [];
    coords.forEach(function(currentCoords, index) {
        if (index !== coords.length - 1) {
            var segment = processSegment(currentCoords, coords[index + 1], offsetDegrees);
            segments.push(segment);
            if (index > 0) {
                var seg2Coords = segments[index - 1];
                var intersects = intersection(segment, seg2Coords);
                if (intersects !== false) {
                    seg2Coords[1] = intersects;
                    segment[0] = intersects;
                }
                finalCoords.push(seg2Coords[0]);
                if (index === coords.length - 2) {
                    finalCoords.push(segment[0]);
                    finalCoords.push(segment[1]);
                }
            }
            if (coords.length === 2) {
                finalCoords.push(segment[0]);
                finalCoords.push(segment[1]);
            }
        }
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineString"])(finalCoords, line.properties);
}
function processSegment(point1, point2, offset) {
    var L = Math.sqrt((point1[0] - point2[0]) * (point1[0] - point2[0]) + (point1[1] - point2[1]) * (point1[1] - point2[1]));
    var out1x = point1[0] + offset * (point2[1] - point1[1]) / L;
    var out2x = point2[0] + offset * (point2[1] - point1[1]) / L;
    var out1y = point1[1] + offset * (point1[0] - point2[0]) / L;
    var out2y = point2[1] + offset * (point1[0] - point2[0]) / L;
    return [
        [
            out1x,
            out1y
        ],
        [
            out2x,
            out2y
        ]
    ];
}
var turf_line_offset_default = lineOffset;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/line-slice/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.js
__turbopack_esm__({
    "default": (()=>turf_line_slice_default),
    "lineSlice": (()=>lineSlice)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/nearest-point-on-line/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
function lineSlice(startPt, stopPt, line) {
    var coords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(line);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getType"])(line) !== "LineString") throw new Error("line must be a LineString");
    var startVertex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nearestPointOnLine"])(line, startPt);
    var stopVertex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nearestPointOnLine"])(line, stopPt);
    var ends;
    if (startVertex.properties.index <= stopVertex.properties.index) {
        ends = [
            startVertex,
            stopVertex
        ];
    } else {
        ends = [
            stopVertex,
            startVertex
        ];
    }
    var clipCoords = [
        ends[0].geometry.coordinates
    ];
    for(var i = ends[0].properties.index + 1; i < ends[1].properties.index + 1; i++){
        clipCoords.push(coords[i]);
    }
    clipCoords.push(ends[1].geometry.coordinates);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineString"])(clipCoords, line.properties);
}
var turf_line_slice_default = lineSlice;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/truncate/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_truncate_default),
    "truncate": (()=>truncate)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
;
;
function truncate(geojson, options) {
    options = options != null ? options : {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    var precision = options.precision;
    var coordinates = options.coordinates;
    var mutate = options.mutate;
    precision = precision === void 0 || precision === null || isNaN(precision) ? 6 : precision;
    coordinates = coordinates === void 0 || coordinates === null || isNaN(coordinates) ? 3 : coordinates;
    if (!geojson) throw new Error("<geojson> is required");
    if (typeof precision !== "number") throw new Error("<precision> must be a number");
    if (typeof coordinates !== "number") throw new Error("<coordinates> must be a number");
    if (mutate === false || mutate === void 0) geojson = JSON.parse(JSON.stringify(geojson));
    var factor = Math.pow(10, precision);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coordEach"])(geojson, function(coords) {
        truncateCoords(coords, factor, coordinates);
    });
    return geojson;
}
function truncateCoords(coords, factor, coordinates) {
    if (coords.length > coordinates) coords.splice(coordinates, coords.length);
    for(var i = 0; i < coords.length; i++){
        coords[i] = Math.round(coords[i] * factor) / factor;
    }
    return coords;
}
var turf_truncate_default = truncate;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/square/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_square_default),
    "square": (()=>square)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-client] (ecmascript)");
;
function square(bbox) {
    var west = bbox[0];
    var south = bbox[1];
    var east = bbox[2];
    var north = bbox[3];
    var horizontalDistance = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(bbox.slice(0, 2), [
        east,
        south
    ]);
    var verticalDistance = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(bbox.slice(0, 2), [
        west,
        north
    ]);
    if (horizontalDistance >= verticalDistance) {
        var verticalMidpoint = (south + north) / 2;
        return [
            west,
            verticalMidpoint - (east - west) / 2,
            east,
            verticalMidpoint + (east - west) / 2
        ];
    } else {
        var horizontalMidpoint = (west + east) / 2;
        return [
            horizontalMidpoint - (north - south) / 2,
            south,
            horizontalMidpoint + (north - south) / 2,
            north
        ];
    }
}
var turf_square_default = square;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/line-split/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.js
__turbopack_esm__({
    "default": (()=>turf_line_split_default),
    "lineSplit": (()=>lineSplit)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$truncate$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/truncate/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-intersect/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$geojson$2d$rbush$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/geojson-rbush/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$square$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/square/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$segment$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-segment/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/nearest-point-on-line/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
function lineSplit(line, splitter) {
    if (!line) throw new Error("line is required");
    if (!splitter) throw new Error("splitter is required");
    var lineType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getType"])(line);
    var splitterType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getType"])(splitter);
    if (lineType !== "LineString") throw new Error("line must be LineString");
    if (splitterType === "FeatureCollection") throw new Error("splitter cannot be a FeatureCollection");
    if (splitterType === "GeometryCollection") throw new Error("splitter cannot be a GeometryCollection");
    var truncatedSplitter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$truncate$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["truncate"])(splitter, {
        precision: 7
    });
    switch(splitterType){
        case "Point":
            return splitLineWithPoint(line, truncatedSplitter);
        case "MultiPoint":
            return splitLineWithPoints(line, truncatedSplitter);
        case "LineString":
        case "MultiLineString":
        case "Polygon":
        case "MultiPolygon":
            return splitLineWithPoints(line, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$intersect$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineIntersect"])(line, truncatedSplitter, {
                ignoreSelfIntersections: true
            }));
    }
}
function splitLineWithPoints(line, splitter) {
    var results = [];
    var tree = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$geojson$2d$rbush$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["geojsonRbush"])();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["flattenEach"])(splitter, function(point) {
        results.forEach(function(feature, index) {
            feature.id = index;
        });
        if (!results.length) {
            results = splitLineWithPoint(line, point).features;
            results.forEach(function(feature) {
                if (!feature.bbox) feature.bbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$square$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["square"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bbox"])(feature));
            });
            tree.load((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(results));
        } else {
            var search = tree.search(point);
            if (search.features.length) {
                var closestLine = findClosestFeature(point, search);
                results = results.filter(function(feature) {
                    return feature.id !== closestLine.id;
                });
                tree.remove(closestLine);
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"])(splitLineWithPoint(closestLine, point), function(line2) {
                    results.push(line2);
                    tree.insert(line2);
                });
            }
        }
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(results);
}
function splitLineWithPoint(line, splitter) {
    var results = [];
    var startPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(line)[0];
    var endPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(line)[line.geometry.coordinates.length - 1];
    if (pointsEquals(startPoint, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(splitter)) || pointsEquals(endPoint, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(splitter))) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])([
        line
    ]);
    var tree = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$geojson$2d$rbush$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["geojsonRbush"])();
    var segments = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$segment$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineSegment"])(line);
    tree.load(segments);
    var search = tree.search(splitter);
    if (!search.features.length) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])([
        line
    ]);
    var closestSegment = findClosestFeature(splitter, search);
    var initialValue = [
        startPoint
    ];
    var lastCoords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureReduce"])(segments, function(previous, current, index) {
        var currentCoords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(current)[1];
        var splitterCoords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(splitter);
        if (index === closestSegment.id) {
            previous.push(splitterCoords);
            results.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineString"])(previous));
            if (pointsEquals(splitterCoords, currentCoords)) return [
                splitterCoords
            ];
            return [
                splitterCoords,
                currentCoords
            ];
        } else {
            previous.push(currentCoords);
            return previous;
        }
    }, initialValue);
    if (lastCoords.length > 1) {
        results.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineString"])(lastCoords));
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(results);
}
function findClosestFeature(point, lines) {
    if (!lines.features.length) throw new Error("lines must contain features");
    if (lines.features.length === 1) return lines.features[0];
    var closestFeature;
    var closestDistance = Infinity;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"])(lines, function(segment) {
        var pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nearestPointOnLine"])(segment, point);
        var dist = pt.properties.dist;
        if (dist < closestDistance) {
            closestFeature = segment;
            closestDistance = dist;
        }
    });
    return closestFeature;
}
function pointsEquals(pt1, pt2) {
    return pt1[0] === pt2[0] && pt1[1] === pt2[1];
}
var turf_line_split_default = lineSplit;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/line-to-polygon/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_line_to_polygon_default),
    "lineToPolygon": (()=>lineToPolygon)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
function lineToPolygon(lines, options = {}) {
    var _a, _b, _c;
    var properties = options.properties;
    var autoComplete = (_a = options.autoComplete) != null ? _a : true;
    var orderCoords = (_b = options.orderCoords) != null ? _b : true;
    var mutate = (_c = options.mutate) != null ? _c : false;
    if (!mutate) {
        lines = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(lines);
    }
    switch(lines.type){
        case "FeatureCollection":
            var coords = [];
            lines.features.forEach(function(line) {
                coords.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(lineStringToPolygon(line, {}, autoComplete, orderCoords)));
            });
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiPolygon"])(coords, properties);
        default:
            return lineStringToPolygon(lines, properties, autoComplete, orderCoords);
    }
}
function lineStringToPolygon(line, properties, autoComplete, orderCoords) {
    properties = properties ? properties : line.type === "Feature" ? line.properties : {};
    var geom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGeom"])(line);
    var coords = geom.coordinates;
    var type = geom.type;
    if (!coords.length) throw new Error("line must contain coordinates");
    switch(type){
        case "LineString":
            if (autoComplete) coords = autoCompleteCoords(coords);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])([
                coords
            ], properties);
        case "MultiLineString":
            var multiCoords = [];
            var largestArea = 0;
            coords.forEach(function(coord) {
                if (autoComplete) coord = autoCompleteCoords(coord);
                if (orderCoords) {
                    var area = calculateArea((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bbox"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineString"])(coord)));
                    if (area > largestArea) {
                        multiCoords.unshift(coord);
                        largestArea = area;
                    } else multiCoords.push(coord);
                } else {
                    multiCoords.push(coord);
                }
            });
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])(multiCoords, properties);
        default:
            throw new Error("geometry type " + type + " is not supported");
    }
}
function autoCompleteCoords(coords) {
    var first = coords[0];
    var x1 = first[0];
    var y1 = first[1];
    var last = coords[coords.length - 1];
    var x2 = last[0];
    var y2 = last[1];
    if (x1 !== x2 || y1 !== y2) {
        coords.push(first);
    }
    return coords;
}
function calculateArea(bbox) {
    var west = bbox[0];
    var south = bbox[1];
    var east = bbox[2];
    var north = bbox[3];
    return Math.abs(west - east) * Math.abs(south - north);
}
var turf_line_to_polygon_default = lineToPolygon;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/mask/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_mask_default),
    "mask": (()=>mask)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/polyclip-ts/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
function mask(polygon, mask2, options) {
    var _a;
    const mutate = (_a = options == null ? void 0 : options.mutate) != null ? _a : false;
    let maskTemplate = mask2;
    if (mask2 && mutate === false) {
        maskTemplate = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(mask2);
    }
    const maskPolygon = createMask(maskTemplate);
    let polygonOuters = null;
    if (polygon.type === "FeatureCollection") {
        polygonOuters = unionFc(polygon);
    } else if (polygon.type === "Feature") {
        polygonOuters = createGeomFromPolygonClippingOutput(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.union(polygon.geometry.coordinates));
    } else {
        polygonOuters = createGeomFromPolygonClippingOutput(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.union(polygon.coordinates));
    }
    polygonOuters.geometry.coordinates.forEach(function(contour) {
        maskPolygon.geometry.coordinates.push(contour[0]);
    });
    return maskPolygon;
}
function unionFc(fc) {
    const unioned = fc.features.length === 2 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.union(fc.features[0].geometry.coordinates, fc.features[1].geometry.coordinates) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.union.apply(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__, fc.features.map(function(f) {
        return f.geometry.coordinates;
    }));
    return createGeomFromPolygonClippingOutput(unioned);
}
function createGeomFromPolygonClippingOutput(unioned) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiPolygon"])(unioned);
}
function createMask(mask2) {
    const world = [
        [
            [
                180,
                90
            ],
            [
                -180,
                90
            ],
            [
                -180,
                -90
            ],
            [
                180,
                -90
            ],
            [
                180,
                90
            ]
        ]
    ];
    let coordinates = world;
    if (mask2) {
        if (mask2.type === "Feature") {
            coordinates = mask2.geometry.coordinates;
        } else {
            coordinates = mask2.coordinates;
        }
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])(coordinates);
}
var turf_mask_default = mask;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/midpoint/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_midpoint_default),
    "midpoint": (()=>midpoint)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bearing/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/destination/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
function midpoint(point1, point2) {
    const dist = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(point1, point2);
    const heading = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bearing"])(point1, point2);
    const midpoint2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["destination"])(point1, dist / 2, heading);
    return midpoint2;
}
var turf_midpoint_default = midpoint;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/moran-index/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_moran_index_default),
    "moranIndex": (()=>moranIndex)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2d$weight$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance-weight/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
;
;
function moranIndex(fc, options) {
    var _a, _b;
    const inputField = options.inputField;
    const threshold = options.threshold || 1e5;
    const p = options.p || 2;
    const binary = (_a = options.binary) != null ? _a : false;
    const alpha = options.alpha || -1;
    const standardization = (_b = options.standardization) != null ? _b : true;
    const weight = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2d$weight$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distanceWeight"])(fc, {
        alpha,
        binary,
        p,
        standardization,
        threshold
    });
    const y = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"])(fc, (feature)=>{
        const feaProperties = feature.properties || {};
        y.push(feaProperties[inputField]);
    });
    const yMean = mean(y);
    const yVar = variance(y);
    let weightSum = 0;
    let s0 = 0;
    let s1 = 0;
    let s2 = 0;
    const n = weight.length;
    for(let i = 0; i < n; i++){
        let subS2 = 0;
        for(let j = 0; j < n; j++){
            weightSum += weight[i][j] * (y[i] - yMean) * (y[j] - yMean);
            s0 += weight[i][j];
            s1 += Math.pow(weight[i][j] + weight[j][i], 2);
            subS2 += weight[i][j] + weight[j][i];
        }
        s2 += Math.pow(subS2, 2);
    }
    s1 = 0.5 * s1;
    const moranIndex2 = weightSum / s0 / yVar;
    const expectedMoranIndex = -1 / (n - 1);
    const vNum = n * n * s1 - n * s2 + 3 * (s0 * s0);
    const vDen = (n - 1) * (n + 1) * (s0 * s0);
    const vNorm = vNum / vDen - expectedMoranIndex * expectedMoranIndex;
    const stdNorm = Math.sqrt(vNorm);
    const zNorm = (moranIndex2 - expectedMoranIndex) / stdNorm;
    return {
        expectedMoranIndex,
        moranIndex: moranIndex2,
        stdNorm,
        zNorm
    };
}
function mean(y) {
    let sum = 0;
    for (const item of y){
        sum += item;
    }
    return sum / y.length;
}
function variance(y) {
    const yMean = mean(y);
    let sum = 0;
    for (const item of y){
        sum += Math.pow(item - yMean, 2);
    }
    return sum / y.length;
}
var turf_moran_index_default = moranIndex;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/nearest-point/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>turf_nearest_point_default),
    "nearestPoint": (()=>nearestPoint)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-client] (ecmascript)");
// index.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-client] (ecmascript)");
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));
;
;
;
function nearestPoint(targetPoint, points, options = {}) {
    if (!targetPoint) throw new Error("targetPoint is required");
    if (!points) throw new Error("points is required");
    let minDist = Infinity;
    let bestFeatureIndex = 0;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"])(points, (pt, featureIndex)=>{
        const distanceToPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(targetPoint, pt, options);
        if (distanceToPoint < minDist) {
            bestFeatureIndex = featureIndex;
            minDist = distanceToPoint;
        }
    });
    const nearestPoint2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(points.features[bestFeatureIndex]);
    return __spreadProps(__spreadValues({}, nearestPoint2), {
        properties: __spreadProps(__spreadValues({}, nearestPoint2.properties), {
            featureIndex: bestFeatureIndex,
            distanceToPoint: minDist
        })
    });
}
var turf_nearest_point_default = nearestPoint;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/point-to-line-distance/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_point_to_line_distance_default),
    "pointToLineDistance": (()=>pointToLineDistance)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rhumb-distance/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/nearest-point-on-line/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
;
function pointToLineDistance(pt, line, options = {}) {
    var _a, _b;
    const method = (_a = options.method) != null ? _a : "geodesic";
    const units = (_b = options.units) != null ? _b : "kilometers";
    if (!pt) {
        throw new Error("pt is required");
    }
    if (Array.isArray(pt)) {
        pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])(pt);
    } else if (pt.type === "Point") {
        pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["feature"])(pt);
    } else {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureOf"])(pt, "Point", "point");
    }
    if (!line) {
        throw new Error("line is required");
    }
    if (Array.isArray(line)) {
        line = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineString"])(line);
    } else if (line.type === "LineString") {
        line = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["feature"])(line);
    } else {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureOf"])(line, "LineString", "line");
    }
    let distance = Infinity;
    const p = pt.geometry.coordinates;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["segmentEach"])(line, (segment)=>{
        if (segment) {
            const a = segment.geometry.coordinates[0];
            const b = segment.geometry.coordinates[1];
            const d = distanceToSegment(p, a, b, {
                method
            });
            if (d < distance) {
                distance = d;
            }
        }
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertLength"])(distance, "degrees", units);
}
function distanceToSegment(p, a, b, options) {
    if (options.method === "geodesic") {
        const nearest = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2d$on$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nearestPointOnLine"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineString"])([
            a,
            b
        ]).geometry, p, {
            units: "degrees"
        });
        return nearest.properties.dist;
    }
    const v = [
        b[0] - a[0],
        b[1] - a[1]
    ];
    const w = [
        p[0] - a[0],
        p[1] - a[1]
    ];
    const c1 = dot(w, v);
    if (c1 <= 0) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rhumbDistance"])(p, a, {
            units: "degrees"
        });
    }
    const c2 = dot(v, v);
    if (c2 <= c1) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rhumbDistance"])(p, b, {
            units: "degrees"
        });
    }
    const b2 = c1 / c2;
    const Pb = [
        a[0] + b2 * v[0],
        a[1] + b2 * v[1]
    ];
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rhumbDistance"])(p, Pb, {
        units: "degrees"
    });
}
function dot(u, v) {
    return u[0] * v[0] + u[1] * v[1];
}
var turf_point_to_line_distance_default = pointToLineDistance;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/nearest-point-to-line/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>turf_nearest_point_to_line_default),
    "nearestPointToLine": (()=>nearestPointToLine)
});
// index.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$point$2d$to$2d$line$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/point-to-line-distance/dist/esm/index.js [app-client] (ecmascript)");
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
;
;
;
function nearestPointToLine(points, line, options = {}) {
    const units = options.units;
    const properties = options.properties || {};
    const pts = normalize(points);
    if (!pts.features.length) {
        throw new Error("points must contain features");
    }
    if (!line) {
        throw new Error("line is required");
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getType"])(line) !== "LineString") {
        throw new Error("line must be a LineString");
    }
    let dist = Infinity;
    let pt = null;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"])(pts, (point)=>{
        const d = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$point$2d$to$2d$line$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pointToLineDistance"])(point, line, {
            units
        });
        if (d < dist) {
            dist = d;
            pt = point;
        }
    });
    if (pt) {
        pt.properties = __spreadValues(__spreadValues(__spreadValues({}, {
            dist
        }), pt.properties), properties);
    }
    return pt;
}
function normalize(points) {
    const features = [];
    const type = points.geometry ? points.geometry.type : points.type;
    switch(type){
        case "GeometryCollection":
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["geomEach"])(points, (geom)=>{
                if (geom.type === "Point") {
                    features.push({
                        type: "Feature",
                        properties: {},
                        geometry: geom
                    });
                }
            });
            return {
                type: "FeatureCollection",
                features
            };
        case "FeatureCollection":
            points.features = points.features.filter((feature)=>{
                return feature.geometry.type === "Point";
            });
            return points;
        default:
            throw new Error("points must be a Point Collection");
    }
}
var turf_nearest_point_to_line_default = nearestPointToLine;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/planepoint/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_planepoint_default),
    "planepoint": (()=>planepoint)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
;
function planepoint(point, triangle) {
    const coord = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(point);
    const geom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGeom"])(triangle);
    const coords = geom.coordinates;
    const outer = coords[0];
    if (outer.length < 4) throw new Error("OuterRing of a Polygon must have 4 or more Positions.");
    const properties = triangle.type === "Feature" && triangle.properties || {};
    const a = properties.a;
    const b = properties.b;
    const c = properties.c;
    const x = coord[0];
    const y = coord[1];
    const x1 = outer[0][0];
    const y1 = outer[0][1];
    const z1 = a !== void 0 ? a : outer[0][2];
    const x2 = outer[1][0];
    const y2 = outer[1][1];
    const z2 = b !== void 0 ? b : outer[1][2];
    const x3 = outer[2][0];
    const y3 = outer[2][1];
    const z3 = c !== void 0 ? c : outer[2][2];
    const z = (z3 * (x - x1) * (y - y2) + z1 * (x - x2) * (y - y3) + z2 * (x - x3) * (y - y1) - z2 * (x - x1) * (y - y3) - z3 * (x - x2) * (y - y1) - z1 * (x - x3) * (y - y2)) / ((x - x1) * (y - y2) + (x - x2) * (y - y3) + (x - x3) * (y - y1) - (x - x1) * (y - y3) - (x - x2) * (y - y1) - (x - x3) * (y - y2));
    return z;
}
var turf_planepoint_default = planepoint;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/point-on-feature/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_point_on_feature_default),
    "pointOnFeature": (()=>pointOnFeature)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/center/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$explode$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/explode/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/nearest-point/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
;
function pointOnFeature(geojson) {
    const fc = normalize(geojson);
    const cent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["center"])(fc);
    let onSurface = false;
    let i = 0;
    while(!onSurface && i < fc.features.length){
        const geom = fc.features[i].geometry;
        let x, y, x1, y1, x2, y2;
        let onLine = false;
        if (geom.type === "Point") {
            if (cent.geometry.coordinates[0] === geom.coordinates[0] && cent.geometry.coordinates[1] === geom.coordinates[1]) {
                onSurface = true;
            }
        } else if (geom.type === "MultiPoint") {
            let onMultiPoint = false;
            let k = 0;
            while(!onMultiPoint && k < geom.coordinates.length){
                if (cent.geometry.coordinates[0] === geom.coordinates[k][0] && cent.geometry.coordinates[1] === geom.coordinates[k][1]) {
                    onSurface = true;
                    onMultiPoint = true;
                }
                k++;
            }
        } else if (geom.type === "LineString") {
            let k = 0;
            while(!onLine && k < geom.coordinates.length - 1){
                x = cent.geometry.coordinates[0];
                y = cent.geometry.coordinates[1];
                x1 = geom.coordinates[k][0];
                y1 = geom.coordinates[k][1];
                x2 = geom.coordinates[k + 1][0];
                y2 = geom.coordinates[k + 1][1];
                if (pointOnSegment(x, y, x1, y1, x2, y2)) {
                    onLine = true;
                    onSurface = true;
                }
                k++;
            }
        } else if (geom.type === "MultiLineString") {
            let j = 0;
            while(j < geom.coordinates.length){
                onLine = false;
                let k = 0;
                const line = geom.coordinates[j];
                while(!onLine && k < line.length - 1){
                    x = cent.geometry.coordinates[0];
                    y = cent.geometry.coordinates[1];
                    x1 = line[k][0];
                    y1 = line[k][1];
                    x2 = line[k + 1][0];
                    y2 = line[k + 1][1];
                    if (pointOnSegment(x, y, x1, y1, x2, y2)) {
                        onLine = true;
                        onSurface = true;
                    }
                    k++;
                }
                j++;
            }
        } else if (geom.type === "Polygon" || geom.type === "MultiPolygon") {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(cent, geom)) {
                onSurface = true;
            }
        }
        i++;
    }
    if (onSurface) {
        return cent;
    } else {
        const vertices = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])([]);
        for(let f = 0; f < fc.features.length; f++){
            vertices.features = vertices.features.concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$explode$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["explode"])(fc.features[f]).features);
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nearestPoint"])(cent, vertices).geometry.coordinates);
    }
}
function normalize(geojson) {
    if (geojson.type !== "FeatureCollection") {
        if (geojson.type !== "Feature") {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])([
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["feature"])(geojson)
            ]);
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])([
            geojson
        ]);
    }
    return geojson;
}
function pointOnSegment(x, y, x1, y1, x2, y2) {
    const ab = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    const ap = Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));
    const pb = Math.sqrt((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y));
    return ab === ap + pb;
}
var turf_point_on_feature_default = pointOnFeature;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/point-to-polygon-distance/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_point_to_polygon_distance_default),
    "pointToPolygonDistance": (()=>pointToPolygonDistance)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygon$2d$to$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/polygon-to-line/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$point$2d$to$2d$line$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/point-to-line-distance/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
;
;
function pointToPolygonDistance(point, polygonOrMultiPolygon, options = {}) {
    var _a, _b;
    const method = (_a = options.method) != null ? _a : "geodesic";
    const units = (_b = options.units) != null ? _b : "kilometers";
    if (!point) throw new Error("point is required");
    if (!polygonOrMultiPolygon) throw new Error("polygon or multi-polygon is required");
    const geom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGeom"])(polygonOrMultiPolygon);
    if (geom.type === "MultiPolygon") {
        const distances = geom.coordinates.map((coords)=>pointToPolygonDistance(point, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])(coords), {
                method,
                units
            }));
        return Math.min(...distances.map(Math.abs)) * ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(point, polygonOrMultiPolygon) ? -1 : 1);
    }
    if (geom.coordinates.length > 1) {
        const [exteriorDistance, ...interiorDistances] = geom.coordinates.map((coords)=>pointToPolygonDistance(point, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])([
                coords
            ]), {
                method,
                units
            }));
        if (exteriorDistance >= 0) return exteriorDistance;
        const smallestInteriorDistance = Math.min(...interiorDistances);
        if (smallestInteriorDistance < 0) return Math.abs(smallestInteriorDistance);
        return Math.min(smallestInteriorDistance, Math.abs(exteriorDistance));
    }
    const lines = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$polygon$2d$to$2d$line$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygonToLine"])(geom);
    let minDistance = Infinity;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["flattenEach"])(lines, (feature)=>{
        minDistance = Math.min(minDistance, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$point$2d$to$2d$line$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pointToLineDistance"])(point, feature, {
            method,
            units
        }));
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(point, geom) ? -minDistance : minDistance;
}
var turf_point_to_polygon_distance_default = pointToPolygonDistance;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/points-within-polygon/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_points_within_polygon_default),
    "pointsWithinPolygon": (()=>pointsWithinPolygon)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
function pointsWithinPolygon(points, polygons) {
    const results = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"])(points, function(point) {
        let contained = false;
        if (point.geometry.type === "Point") {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["geomEach"])(polygons, function(polygon) {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(point, polygon)) {
                    contained = true;
                }
            });
            if (contained) {
                results.push(point);
            }
        } else if (point.geometry.type === "MultiPoint") {
            var pointsWithin = [];
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["geomEach"])(polygons, function(polygon) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coordEach"])(point, function(pointCoord) {
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(pointCoord, polygon)) {
                        contained = true;
                        pointsWithin.push(pointCoord);
                    }
                });
            });
            if (contained) {
                results.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiPoint"])(pointsWithin, point.properties));
            }
        } else {
            throw new Error("Input geometry must be a Point or MultiPoint");
        }
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(results);
}
var turf_points_within_polygon_default = pointsWithinPolygon;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/polygon-smooth/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_polygon_smooth_default),
    "polygonSmooth": (()=>polygonSmooth)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
;
function polygonSmooth(inputPolys, options) {
    options = options || {};
    options.iterations = options.iterations || 1;
    const { iterations } = options;
    const outPolys = [];
    if (!inputPolys) throw new Error("inputPolys is required");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["geomEach"])(inputPolys, function(geom, geomIndex, properties) {
        if (geom.type === "Polygon") {
            let outCoords = [
                []
            ];
            for(let i = 0; i < iterations; i++){
                let tempOutput = [];
                let poly = geom;
                if (i > 0) {
                    poly = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])(outCoords).geometry;
                }
                processPolygon(poly, tempOutput);
                outCoords = tempOutput.slice(0);
            }
            outPolys.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])(outCoords, properties));
        } else if (geom.type === "MultiPolygon") {
            let outCoords = [
                [
                    []
                ]
            ];
            for(let y = 0; y < iterations; y++){
                let tempOutput = [];
                let poly = geom;
                if (y > 0) {
                    poly = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiPolygon"])(outCoords).geometry;
                }
                processMultiPolygon(poly, tempOutput);
                outCoords = tempOutput.slice(0);
            }
            outPolys.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiPolygon"])(outCoords, properties));
        } else {
            throw new Error("geometry is invalid, must be Polygon or MultiPolygon");
        }
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(outPolys);
}
function processPolygon(poly, tempOutput) {
    var previousCoord;
    var previousGeometryIndex;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coordEach"])(poly, function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
        if (previousGeometryIndex !== geometryIndex) {
            tempOutput.push([]);
        } else {
            var p0x = previousCoord[0];
            var p0y = previousCoord[1];
            var p1x = currentCoord[0];
            var p1y = currentCoord[1];
            tempOutput[geometryIndex].push([
                0.75 * p0x + 0.25 * p1x,
                0.75 * p0y + 0.25 * p1y
            ]);
            tempOutput[geometryIndex].push([
                0.25 * p0x + 0.75 * p1x,
                0.25 * p0y + 0.75 * p1y
            ]);
        }
        previousCoord = currentCoord;
        previousGeometryIndex = geometryIndex;
    }, false);
    tempOutput.forEach(function(ring) {
        ring.push(ring[0]);
    });
}
function processMultiPolygon(poly, tempOutput) {
    let previousCoord;
    let previousMultiFeatureIndex;
    let previousGeometryIndex;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coordEach"])(poly, function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
        if (previousMultiFeatureIndex !== multiFeatureIndex) {
            tempOutput.push([
                []
            ]);
        } else if (previousGeometryIndex !== geometryIndex) {
            tempOutput[multiFeatureIndex].push([]);
        } else {
            var p0x = previousCoord[0];
            var p0y = previousCoord[1];
            var p1x = currentCoord[0];
            var p1y = currentCoord[1];
            tempOutput[multiFeatureIndex][geometryIndex].push([
                0.75 * p0x + 0.25 * p1x,
                0.75 * p0y + 0.25 * p1y
            ]);
            tempOutput[multiFeatureIndex][geometryIndex].push([
                0.25 * p0x + 0.75 * p1x,
                0.25 * p0y + 0.75 * p1y
            ]);
        }
        previousCoord = currentCoord;
        previousMultiFeatureIndex = multiFeatureIndex;
        previousGeometryIndex = geometryIndex;
    }, false);
    tempOutput.forEach(function(poly2) {
        poly2.forEach(function(ring) {
            ring.push(ring[0]);
        });
    });
}
var turf_polygon_smooth_default = polygonSmooth;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/polygon-tangents/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_polygon_tangents_default),
    "polygonTangents": (()=>polygonTangents)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/nearest-point/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$explode$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/explode/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
;
function polygonTangents(pt, polygon) {
    const pointCoords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(pt);
    const polyCoords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(polygon);
    let rtan = [];
    let ltan = [];
    let eprev;
    const bbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bbox"])(polygon);
    let nearestPtIndex = 0;
    let nearest = null;
    if (pointCoords[0] > bbox[0] && pointCoords[0] < bbox[2] && pointCoords[1] > bbox[1] && pointCoords[1] < bbox[3]) {
        nearest = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nearestPoint"])(pt, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$explode$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["explode"])(polygon));
        nearestPtIndex = nearest.properties.featureIndex;
    }
    const type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getType"])(polygon);
    switch(type){
        case "Polygon":
            rtan = polyCoords[0][nearestPtIndex];
            ltan = polyCoords[0][0];
            if (nearest !== null) {
                if (nearest.geometry.coordinates[1] < pointCoords[1]) ltan = polyCoords[0][nearestPtIndex];
            }
            eprev = isLeft(polyCoords[0][0], polyCoords[0][polyCoords[0].length - 1], pointCoords);
            [rtan, ltan] = processPolygon(polyCoords[0], pointCoords, eprev, rtan, ltan);
            break;
        case "MultiPolygon":
            var closestFeature = 0;
            var closestVertex = 0;
            var verticesCounted = 0;
            for(var i = 0; i < polyCoords[0].length; i++){
                closestFeature = i;
                var verticeFound = false;
                for(var i2 = 0; i2 < polyCoords[0][i].length; i2++){
                    closestVertex = i2;
                    if (verticesCounted === nearestPtIndex) {
                        verticeFound = true;
                        break;
                    }
                    verticesCounted++;
                }
                if (verticeFound) break;
            }
            rtan = polyCoords[0][closestFeature][closestVertex];
            ltan = polyCoords[0][closestFeature][closestVertex];
            eprev = isLeft(polyCoords[0][0][0], polyCoords[0][0][polyCoords[0][0].length - 1], pointCoords);
            polyCoords.forEach(function(ring) {
                [rtan, ltan] = processPolygon(ring[0], pointCoords, eprev, rtan, ltan);
            });
            break;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])(rtan),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])(ltan)
    ]);
}
function processPolygon(polygonCoords, ptCoords, eprev, rtan, ltan) {
    for(let i = 0; i < polygonCoords.length; i++){
        const currentCoords = polygonCoords[i];
        let nextCoordPair = polygonCoords[i + 1];
        if (i === polygonCoords.length - 1) {
            nextCoordPair = polygonCoords[0];
        }
        const enext = isLeft(currentCoords, nextCoordPair, ptCoords);
        if (eprev <= 0 && enext > 0) {
            if (!isBelow(ptCoords, currentCoords, rtan)) {
                rtan = currentCoords;
            }
        } else if (eprev > 0 && enext <= 0) {
            if (!isAbove(ptCoords, currentCoords, ltan)) {
                ltan = currentCoords;
            }
        }
        eprev = enext;
    }
    return [
        rtan,
        ltan
    ];
}
function isAbove(point1, point2, point3) {
    return isLeft(point1, point2, point3) > 0;
}
function isBelow(point1, point2, point3) {
    return isLeft(point1, point2, point3) < 0;
}
function isLeft(point1, point2, point3) {
    return (point2[0] - point1[0]) * (point3[1] - point1[1]) - (point3[0] - point1[0]) * (point2[1] - point1[1]);
}
var turf_polygon_tangents_default = polygonTangents;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/polygonize/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_polygonize_default),
    "polygonize": (()=>polygonize)
});
// lib/util.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$envelope$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/envelope/dist/esm/index.js [app-client] (ecmascript)");
// lib/Graph.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
function mathSign(x) {
    return (x > 0) - (x < 0) || +x;
}
function orientationIndex(p1, p2, q) {
    const dx1 = p2[0] - p1[0], dy1 = p2[1] - p1[1], dx2 = q[0] - p2[0], dy2 = q[1] - p2[1];
    return mathSign(dx1 * dy2 - dx2 * dy1);
}
function envelopeIsEqual(env1, env2) {
    const envX1 = env1.geometry.coordinates[0].map((c)=>c[0]), envY1 = env1.geometry.coordinates[0].map((c)=>c[1]), envX2 = env2.geometry.coordinates[0].map((c)=>c[0]), envY2 = env2.geometry.coordinates[0].map((c)=>c[1]);
    return Math.max.apply(null, envX1) === Math.max.apply(null, envX2) && Math.max.apply(null, envY1) === Math.max.apply(null, envY2) && Math.min.apply(null, envX1) === Math.min.apply(null, envX2) && Math.min.apply(null, envY1) === Math.min.apply(null, envY2);
}
function envelopeContains(self, env) {
    return env.geometry.coordinates[0].every((c)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])(c), self));
}
function coordinatesEqual(coord1, coord2) {
    return coord1[0] === coord2[0] && coord1[1] === coord2[1];
}
// lib/Node.ts
var Node = class _Node {
    static buildId(coordinates) {
        return coordinates.join(",");
    }
    constructor(coordinates){
        this.id = _Node.buildId(coordinates);
        this.coordinates = coordinates;
        this.innerEdges = [];
        this.outerEdges = [];
        this.outerEdgesSorted = false;
    }
    removeInnerEdge(edge) {
        this.innerEdges = this.innerEdges.filter((e)=>e.from.id !== edge.from.id);
    }
    removeOuterEdge(edge) {
        this.outerEdges = this.outerEdges.filter((e)=>e.to.id !== edge.to.id);
    }
    /**
   * Outer edges are stored CCW order.
   *
   * @memberof Node
   * @param {Edge} edge - Edge to add as an outerEdge.
   */ addOuterEdge(edge) {
        this.outerEdges.push(edge);
        this.outerEdgesSorted = false;
    }
    /**
   * Sorts outer edges in CCW way.
   *
   * @memberof Node
   * @private
   */ sortOuterEdges() {
        if (!this.outerEdgesSorted) {
            this.outerEdges.sort((a, b)=>{
                const aNode = a.to, bNode = b.to;
                if (aNode.coordinates[0] - this.coordinates[0] >= 0 && bNode.coordinates[0] - this.coordinates[0] < 0) return 1;
                if (aNode.coordinates[0] - this.coordinates[0] < 0 && bNode.coordinates[0] - this.coordinates[0] >= 0) return -1;
                if (aNode.coordinates[0] - this.coordinates[0] === 0 && bNode.coordinates[0] - this.coordinates[0] === 0) {
                    if (aNode.coordinates[1] - this.coordinates[1] >= 0 || bNode.coordinates[1] - this.coordinates[1] >= 0) return aNode.coordinates[1] - bNode.coordinates[1];
                    return bNode.coordinates[1] - aNode.coordinates[1];
                }
                const det = orientationIndex(this.coordinates, aNode.coordinates, bNode.coordinates);
                if (det < 0) return 1;
                if (det > 0) return -1;
                const d1 = Math.pow(aNode.coordinates[0] - this.coordinates[0], 2) + Math.pow(aNode.coordinates[1] - this.coordinates[1], 2), d2 = Math.pow(bNode.coordinates[0] - this.coordinates[0], 2) + Math.pow(bNode.coordinates[1] - this.coordinates[1], 2);
                return d1 - d2;
            });
            this.outerEdgesSorted = true;
        }
    }
    /**
   * Retrieves outer edges.
   *
   * They are sorted if they aren't in the CCW order.
   *
   * @memberof Node
   * @returns {Edge[]} - List of outer edges sorted in a CCW order.
   */ getOuterEdges() {
        this.sortOuterEdges();
        return this.outerEdges;
    }
    getOuterEdge(i) {
        this.sortOuterEdges();
        return this.outerEdges[i];
    }
    addInnerEdge(edge) {
        this.innerEdges.push(edge);
    }
};
;
var Edge = class _Edge {
    /**
   * Creates or get the symetric Edge.
   *
   * @returns {Edge} - Symetric Edge.
   */ getSymetric() {
        if (!this.symetric) {
            this.symetric = new _Edge(this.to, this.from);
            this.symetric.symetric = this;
        }
        return this.symetric;
    }
    /**
   * @param {Node} from - start node of the Edge
   * @param {Node} to - end node of the edge
   */ constructor(from, to){
        this.from = from;
        this.to = to;
        this.next = void 0;
        this.label = void 0;
        this.symetric = void 0;
        this.ring = void 0;
        this.from.addOuterEdge(this);
        this.to.addInnerEdge(this);
    }
    /**
   * Removes edge from from and to nodes.
   */ deleteEdge() {
        this.from.removeOuterEdge(this);
        this.to.removeInnerEdge(this);
    }
    /**
   * Compares Edge equallity.
   *
   * An edge is equal to another, if the from and to nodes are the same.
   *
   * @param {Edge} edge - Another Edge
   * @returns {boolean} - True if Edges are equal, False otherwise
   */ isEqual(edge) {
        return this.from.id === edge.from.id && this.to.id === edge.to.id;
    }
    toString() {
        return `Edge { ${this.from.id} -> ${this.to.id} }`;
    }
    /**
   * Returns a LineString representation of the Edge
   *
   * @returns {Feature<LineString>} - LineString representation of the Edge
   */ toLineString() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineString"])([
            this.from.coordinates,
            this.to.coordinates
        ]);
    }
    /**
   * Comparator of two edges.
   *
   * Implementation of geos::planargraph::DirectedEdge::compareTo.
   *
   * @param {Edge} edge - Another edge to compare with this one
   * @returns {number} -1 if this Edge has a greater angle with the positive x-axis than b,
   *          0 if the Edges are colinear,
   *          1 otherwise
   */ compareTo(edge) {
        return orientationIndex(edge.from.coordinates, edge.to.coordinates, this.to.coordinates);
    }
};
;
;
;
var EdgeRing = class {
    constructor(){
        this.edges = [];
        this.polygon = void 0;
        this.envelope = void 0;
    }
    /**
   * Add an edge to the ring, inserting it in the last position.
   *
   * @memberof EdgeRing
   * @param {Edge} edge - Edge to be inserted
   */ push(edge) {
        this.edges.push(edge);
        this.polygon = this.envelope = void 0;
    }
    /**
   * Get Edge.
   *
   * @memberof EdgeRing
   * @param {number} i - Index
   * @returns {Edge} - Edge in the i position
   */ get(i) {
        return this.edges[i];
    }
    /**
   * Getter of length property.
   *
   * @memberof EdgeRing
   * @returns {number} - Length of the edge ring.
   */ get length() {
        return this.edges.length;
    }
    /**
   * Similar to Array.prototype.forEach for the list of Edges in the EdgeRing.
   *
   * @memberof EdgeRing
   * @param {Function} f - The same function to be passed to Array.prototype.forEach
   */ forEach(f) {
        this.edges.forEach(f);
    }
    /**
   * Similar to Array.prototype.map for the list of Edges in the EdgeRing.
   *
   * @memberof EdgeRing
   * @param {Function} f - The same function to be passed to Array.prototype.map
   * @returns {Array} - The mapped values in the function
   */ map(f) {
        return this.edges.map(f);
    }
    /**
   * Similar to Array.prototype.some for the list of Edges in the EdgeRing.
   *
   * @memberof EdgeRing
   * @param {Function} f - The same function to be passed to Array.prototype.some
   * @returns {boolean} - True if an Edge check the condition
   */ some(f) {
        return this.edges.some(f);
    }
    /**
   * Check if the ring is valid in geomtry terms.
   *
   * A ring must have either 0 or 4 or more points. The first and the last must be
   * equal (in 2D)
   * geos::geom::LinearRing::validateConstruction
   *
   * @memberof EdgeRing
   * @returns {boolean} - Validity of the EdgeRing
   */ isValid() {
        return true;
    }
    /**
   * Tests whether this ring is a hole.
   *
   * A ring is a hole if it is oriented counter-clockwise.
   * Similar implementation of geos::algorithm::CGAlgorithms::isCCW
   *
   * @memberof EdgeRing
   * @returns {boolean} - true: if it is a hole
   */ isHole() {
        const hiIndex = this.edges.reduce((high, edge, i)=>{
            if (edge.from.coordinates[1] > this.edges[high].from.coordinates[1]) high = i;
            return high;
        }, 0), iPrev = (hiIndex === 0 ? this.length : hiIndex) - 1, iNext = (hiIndex + 1) % this.length, disc = orientationIndex(this.edges[iPrev].from.coordinates, this.edges[hiIndex].from.coordinates, this.edges[iNext].from.coordinates);
        if (disc === 0) return this.edges[iPrev].from.coordinates[0] > this.edges[iNext].from.coordinates[0];
        return disc > 0;
    }
    /**
   * Creates a MultiPoint representing the EdgeRing (discarts edges directions).
   *
   * @memberof EdgeRing
   * @returns {Feature<MultiPoint>} - Multipoint representation of the EdgeRing
   */ toMultiPoint() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiPoint"])(this.edges.map((edge)=>edge.from.coordinates));
    }
    /**
   * Creates a Polygon representing the EdgeRing.
   *
   * @memberof EdgeRing
   * @returns {Feature<Polygon>} - Polygon representation of the Edge Ring
   */ toPolygon() {
        if (this.polygon) return this.polygon;
        const coordinates = this.edges.map((edge)=>edge.from.coordinates);
        coordinates.push(this.edges[0].from.coordinates);
        return this.polygon = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])([
            coordinates
        ]);
    }
    /**
   * Calculates the envelope of the EdgeRing.
   *
   * @memberof EdgeRing
   * @returns {Feature<Polygon>} - envelope
   */ getEnvelope() {
        if (this.envelope) return this.envelope;
        return this.envelope = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$envelope$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["envelope"])(this.toPolygon());
    }
    /**
   * `geos::operation::polygonize::EdgeRing::findEdgeRingContaining`
   *
   * @param {EdgeRing} testEdgeRing - EdgeRing to look in the list
   * @param {EdgeRing[]} shellList - List of EdgeRing in which to search
   *
   * @returns {EdgeRing} - EdgeRing which contains the testEdgeRing
   */ static findEdgeRingContaining(testEdgeRing, shellList) {
        const testEnvelope = testEdgeRing.getEnvelope();
        let minEnvelope, minShell;
        shellList.forEach((shell)=>{
            const tryEnvelope = shell.getEnvelope();
            if (minShell) minEnvelope = minShell.getEnvelope();
            if (envelopeIsEqual(tryEnvelope, testEnvelope)) return;
            if (envelopeContains(tryEnvelope, testEnvelope)) {
                const testEdgeRingCoordinates = testEdgeRing.map((edge)=>edge.from.coordinates);
                let testPoint;
                for (const pt of testEdgeRingCoordinates){
                    if (!shell.some((edge)=>coordinatesEqual(pt, edge.from.coordinates))) {
                        testPoint = pt;
                    }
                }
                if (testPoint && shell.inside((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])(testPoint))) {
                    if (!minShell || envelopeContains(minEnvelope, tryEnvelope)) minShell = shell;
                }
            }
        });
        return minShell;
    }
    /**
   * Checks if the point is inside the edgeRing
   *
   * @param {Feature<Point>} pt - Point to check if it is inside the edgeRing
   * @returns {boolean} - True if it is inside, False otherwise
   */ inside(pt) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(pt, this.toPolygon());
    }
};
;
;
function validateGeoJson(geoJson) {
    if (!geoJson) throw new Error("No geojson passed");
    if (geoJson.type !== "FeatureCollection" && geoJson.type !== "GeometryCollection" && geoJson.type !== "MultiLineString" && geoJson.type !== "LineString" && geoJson.type !== "Feature") throw new Error(`Invalid input type '${geoJson.type}'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature`);
}
var Graph = class _Graph {
    /**
   * Creates a graph from a GeoJSON.
   *
   * @param {FeatureCollection<LineString>} geoJson - it must comply with the restrictions detailed in the index
   * @returns {Graph} - The newly created graph
   * @throws {Error} if geoJson is invalid.
   */ static fromGeoJson(geoJson) {
        validateGeoJson(geoJson);
        const graph = new _Graph();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["flattenEach"])(geoJson, (feature)=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureOf"])(feature, "LineString", "Graph::fromGeoJson");
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coordReduce"])(feature, (prev, cur)=>{
                if (prev) {
                    const start = graph.getNode(prev), end = graph.getNode(cur);
                    graph.addEdge(start, end);
                }
                return cur;
            });
        });
        return graph;
    }
    /**
   * Creates or get a Node.
   *
   * @param {number[]} coordinates - Coordinates of the node
   * @returns {Node} - The created or stored node
   */ getNode(coordinates) {
        const id = Node.buildId(coordinates);
        let node = this.nodes[id];
        if (!node) node = this.nodes[id] = new Node(coordinates);
        return node;
    }
    /**
   * Adds an Edge and its symetricall.
   *
   * Edges are added symetrically, i.e.: we also add its symetric
   *
   * @param {Node} from - Node which starts the Edge
   * @param {Node} to - Node which ends the Edge
   */ addEdge(from, to) {
        const edge = new Edge(from, to), symetricEdge = edge.getSymetric();
        this.edges.push(edge);
        this.edges.push(symetricEdge);
    }
    constructor(){
        this.edges = [];
        this.nodes = {};
    }
    /**
   * Removes Dangle Nodes (nodes with grade 1).
   */ deleteDangles() {
        Object.keys(this.nodes).map((id)=>this.nodes[id]).forEach((node)=>this._removeIfDangle(node));
    }
    /**
   * Check if node is dangle, if so, remove it.
   *
   * It calls itself recursively, removing a dangling node might cause another dangling node
   *
   * @param {Node} node - Node to check if it's a dangle
   */ _removeIfDangle(node) {
        if (node.innerEdges.length <= 1) {
            const outerNodes = node.getOuterEdges().map((e)=>e.to);
            this.removeNode(node);
            outerNodes.forEach((n)=>this._removeIfDangle(n));
        }
    }
    /**
   * Delete cut-edges (bridge edges).
   *
   * The graph will be traversed, all the edges will be labeled according the ring
   * in which they are. (The label is a number incremented by 1). Edges with the same
   * label are cut-edges.
   */ deleteCutEdges() {
        this._computeNextCWEdges();
        this._findLabeledEdgeRings();
        this.edges.forEach((edge)=>{
            if (edge.label === edge.symetric.label) {
                this.removeEdge(edge.symetric);
                this.removeEdge(edge);
            }
        });
    }
    /**
   * Set the `next` property of each Edge.
   *
   * The graph will be transversed in a CW form, so, we set the next of the symetrical edge as the previous one.
   * OuterEdges are sorted CCW.
   *
   * @param {Node} [node] - If no node is passed, the function calls itself for every node in the Graph
   */ _computeNextCWEdges(node) {
        if (typeof node === "undefined") {
            Object.keys(this.nodes).forEach((id)=>this._computeNextCWEdges(this.nodes[id]));
        } else {
            node.getOuterEdges().forEach((edge, i)=>{
                node.getOuterEdge((i === 0 ? node.getOuterEdges().length : i) - 1).symetric.next = edge;
            });
        }
    }
    /**
   * Computes the next edge pointers going CCW around the given node, for the given edgering label.
   *
   * This algorithm has the effect of converting maximal edgerings into minimal edgerings
   *
   * XXX: method literally transcribed from `geos::operation::polygonize::PolygonizeGraph::computeNextCCWEdges`,
   * could be written in a more javascript way.
   *
   * @param {Node} node - Node
   * @param {number} label - Ring's label
   */ _computeNextCCWEdges(node, label) {
        const edges = node.getOuterEdges();
        let firstOutDE, prevInDE;
        for(let i = edges.length - 1; i >= 0; --i){
            let de = edges[i], sym = de.symetric, outDE, inDE;
            if (de.label === label) outDE = de;
            if (sym.label === label) inDE = sym;
            if (!outDE || !inDE) continue;
            if (inDE) prevInDE = inDE;
            if (outDE) {
                if (prevInDE) {
                    prevInDE.next = outDE;
                    prevInDE = void 0;
                }
                if (!firstOutDE) firstOutDE = outDE;
            }
        }
        if (prevInDE) prevInDE.next = firstOutDE;
    }
    /**
   * Finds rings and labels edges according to which rings are.
   *
   * The label is a number which is increased for each ring.
   *
   * @returns {Edge[]} edges that start rings
   */ _findLabeledEdgeRings() {
        const edgeRingStarts = [];
        let label = 0;
        this.edges.forEach((edge)=>{
            if (edge.label >= 0) return;
            edgeRingStarts.push(edge);
            let e = edge;
            do {
                e.label = label;
                e = e.next;
            }while (!edge.isEqual(e))
            label++;
        });
        return edgeRingStarts;
    }
    /**
   * Computes the EdgeRings formed by the edges in this graph.
   *
   * @returns {EdgeRing[]} - A list of all the EdgeRings in the graph.
   */ getEdgeRings() {
        this._computeNextCWEdges();
        this.edges.forEach((edge)=>{
            edge.label = void 0;
        });
        this._findLabeledEdgeRings().forEach((edge)=>{
            this._findIntersectionNodes(edge).forEach((node)=>{
                this._computeNextCCWEdges(node, edge.label);
            });
        });
        const edgeRingList = [];
        this.edges.forEach((edge)=>{
            if (edge.ring) return;
            edgeRingList.push(this._findEdgeRing(edge));
        });
        return edgeRingList;
    }
    /**
   * Find all nodes in a Maxima EdgeRing which are self-intersection nodes.
   *
   * @param {Node} startEdge - Start Edge of the Ring
   * @returns {Node[]} - intersection nodes
   */ _findIntersectionNodes(startEdge) {
        const intersectionNodes = [];
        let edge = startEdge;
        do {
            let degree = 0;
            edge.from.getOuterEdges().forEach((e)=>{
                if (e.label === startEdge.label) ++degree;
            });
            if (degree > 1) intersectionNodes.push(edge.from);
            edge = edge.next;
        }while (!startEdge.isEqual(edge))
        return intersectionNodes;
    }
    /**
   * Get the edge-ring which starts from the provided Edge.
   *
   * @param {Edge} startEdge - starting edge of the edge ring
   * @returns {EdgeRing} - EdgeRing which start Edge is the provided one.
   */ _findEdgeRing(startEdge) {
        let edge = startEdge;
        const edgeRing = new EdgeRing();
        do {
            edgeRing.push(edge);
            edge.ring = edgeRing;
            edge = edge.next;
        }while (!startEdge.isEqual(edge))
        return edgeRing;
    }
    /**
   * Removes a node from the Graph.
   *
   * It also removes edges asociated to that node
   * @param {Node} node - Node to be removed
   */ removeNode(node) {
        node.getOuterEdges().forEach((edge)=>this.removeEdge(edge));
        node.innerEdges.forEach((edge)=>this.removeEdge(edge));
        delete this.nodes[node.id];
    }
    /**
   * Remove edge from the graph and deletes the edge.
   *
   * @param {Edge} edge - Edge to be removed
   */ removeEdge(edge) {
        this.edges = this.edges.filter((e)=>!e.isEqual(edge));
        edge.deleteEdge();
    }
};
// index.ts
function polygonize(geoJson) {
    const graph = Graph.fromGeoJson(geoJson);
    graph.deleteDangles();
    graph.deleteCutEdges();
    const holes = [], shells = [];
    graph.getEdgeRings().filter((edgeRing)=>edgeRing.isValid()).forEach((edgeRing)=>{
        if (edgeRing.isHole()) holes.push(edgeRing);
        else shells.push(edgeRing);
    });
    holes.forEach((hole)=>{
        if (EdgeRing.findEdgeRingContaining(hole, shells)) shells.push(hole);
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(shells.map((shell)=>shell.toPolygon()));
}
var turf_polygonize_default = polygonize;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/projection/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "toMercator": (()=>toMercator),
    "toWgs84": (()=>toWgs84)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
function toMercator(geojson, options = {}) {
    return convert(geojson, "mercator", options);
}
function toWgs84(geojson, options = {}) {
    return convert(geojson, "wgs84", options);
}
function convert(geojson, projection, options = {}) {
    options = options || {};
    var mutate = options.mutate;
    if (!geojson) throw new Error("geojson is required");
    if (Array.isArray(geojson) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(geojson[0])) geojson = projection === "mercator" ? convertToMercator(geojson) : convertToWgs84(geojson);
    else {
        if (mutate !== true) geojson = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(geojson);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coordEach"])(geojson, function(coord) {
            var newCoord = projection === "mercator" ? convertToMercator(coord) : convertToWgs84(coord);
            coord[0] = newCoord[0];
            coord[1] = newCoord[1];
        });
    }
    return geojson;
}
function convertToMercator(lonLat) {
    var D2R = Math.PI / 180, A = 6378137, MAXEXTENT = 20037508342789244e-9;
    var adjusted = Math.abs(lonLat[0]) <= 180 ? lonLat[0] : lonLat[0] - sign(lonLat[0]) * 360;
    var xy = [
        A * adjusted * D2R,
        A * Math.log(Math.tan(Math.PI * 0.25 + 0.5 * lonLat[1] * D2R))
    ];
    if (xy[0] > MAXEXTENT) xy[0] = MAXEXTENT;
    if (xy[0] < -MAXEXTENT) xy[0] = -MAXEXTENT;
    if (xy[1] > MAXEXTENT) xy[1] = MAXEXTENT;
    if (xy[1] < -MAXEXTENT) xy[1] = -MAXEXTENT;
    return xy;
}
function convertToWgs84(xy) {
    var R2D = 180 / Math.PI;
    var A = 6378137;
    return [
        xy[0] * R2D / A,
        (Math.PI * 0.5 - 2 * Math.atan(Math.exp(-xy[1] / A))) * R2D
    ];
}
function sign(x) {
    return x < 0 ? -1 : x > 0 ? 1 : 0;
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/random/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "randomLineString": (()=>randomLineString),
    "randomPoint": (()=>randomPoint),
    "randomPolygon": (()=>randomPolygon),
    "randomPosition": (()=>randomPosition)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
function randomPosition(bbox) {
    checkBBox(bbox);
    return randomPositionUnchecked(bbox);
}
function randomPositionUnchecked(bbox) {
    if (Array.isArray(bbox)) {
        return coordInBBox(bbox);
    }
    if (bbox && bbox.bbox) {
        return coordInBBox(bbox.bbox);
    }
    return [
        lon(),
        lat()
    ];
}
function checkBBox(bbox) {
    if (bbox == null) {
        return;
    } else if (Array.isArray(bbox)) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateBBox"])(bbox);
    } else if (bbox.bbox != null) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateBBox"])(bbox.bbox);
    }
}
function randomPoint(count, options = {}) {
    checkBBox(options.bbox);
    if (count === void 0 || count === null) {
        count = 1;
    }
    const features = [];
    for(let i = 0; i < count; i++){
        features.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])(randomPositionUnchecked(options.bbox)));
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(features);
}
function randomPolygon(count, options = {}) {
    checkBBox(options.bbox);
    if (count === void 0 || count === null) {
        count = 1;
    }
    if (options.bbox === void 0 || options.bbox === null) {
        options.bbox = [
            -180,
            -90,
            180,
            90
        ];
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(options.num_vertices) || options.num_vertices === void 0) {
        options.num_vertices = 10;
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(options.max_radial_length) || options.max_radial_length === void 0) {
        options.max_radial_length = 10;
    }
    const bboxWidth = Math.abs(options.bbox[0] - options.bbox[2]);
    const bboxHeight = Math.abs(options.bbox[1] - options.bbox[3]);
    const maxRadius = Math.min(bboxWidth / 2, bboxHeight / 2);
    if (options.max_radial_length > maxRadius) {
        throw new Error("max_radial_length is greater than the radius of the bbox");
    }
    const paddedBbox = [
        options.bbox[0] + options.max_radial_length,
        options.bbox[1] + options.max_radial_length,
        options.bbox[2] - options.max_radial_length,
        options.bbox[3] - options.max_radial_length
    ];
    const features = [];
    for(let i = 0; i < count; i++){
        let vertices = [];
        const circleOffsets = [
            ...Array(options.num_vertices + 1)
        ].map(Math.random);
        circleOffsets.forEach((cur, index, arr)=>{
            arr[index] = index > 0 ? cur + arr[index - 1] : cur;
        });
        circleOffsets.forEach((cur)=>{
            cur = cur * 2 * Math.PI / circleOffsets[circleOffsets.length - 1];
            const radialScaler = Math.random();
            vertices.push([
                radialScaler * (options.max_radial_length || 10) * Math.sin(cur),
                radialScaler * (options.max_radial_length || 10) * Math.cos(cur)
            ]);
        });
        vertices[vertices.length - 1] = vertices[0];
        vertices = vertices.reverse().map(vertexToCoordinate(randomPositionUnchecked(paddedBbox)));
        features.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])([
            vertices
        ]));
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(features);
}
function randomLineString(count, options = {}) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(options)) {
        throw new Error("options is invalid");
    }
    const bbox = options.bbox;
    checkBBox(bbox);
    let num_vertices = options.num_vertices;
    let max_length = options.max_length;
    let max_rotation = options.max_rotation;
    if (count === void 0 || count === null) {
        count = 1;
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(num_vertices) || num_vertices === void 0 || num_vertices < 2) {
        num_vertices = 10;
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(max_length) || max_length === void 0) {
        max_length = 1e-4;
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(max_rotation) || max_rotation === void 0) {
        max_rotation = Math.PI / 8;
    }
    const features = [];
    for(let i = 0; i < count; i++){
        const startingPoint = randomPositionUnchecked(bbox);
        const vertices = [
            startingPoint
        ];
        for(let j = 0; j < num_vertices - 1; j++){
            const priorAngle = j === 0 ? Math.random() * 2 * Math.PI : Math.tan((vertices[j][1] - vertices[j - 1][1]) / (vertices[j][0] - vertices[j - 1][0]));
            const angle = priorAngle + (Math.random() - 0.5) * max_rotation * 2;
            const distance = Math.random() * max_length;
            vertices.push([
                vertices[j][0] + distance * Math.cos(angle),
                vertices[j][1] + distance * Math.sin(angle)
            ]);
        }
        features.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineString"])(vertices));
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(features);
}
function vertexToCoordinate(hub) {
    return (cur)=>{
        return [
            cur[0] + hub[0],
            cur[1] + hub[1]
        ];
    };
}
function rnd() {
    return Math.random() - 0.5;
}
function lon() {
    return rnd() * 360;
}
function lat() {
    return rnd() * 180;
}
function coordInBBox(bbox) {
    return [
        Math.random() * (bbox[2] - bbox[0]) + bbox[0],
        Math.random() * (bbox[3] - bbox[1]) + bbox[1]
    ];
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/rewind/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_rewind_default),
    "rewind": (()=>rewind)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$clockwise$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-clockwise/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
;
function rewind(geojson, options = {}) {
    var _a, _b;
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    const mutate = (_a = options.mutate) != null ? _a : false;
    const reverse = (_b = options.reverse) != null ? _b : false;
    if (!geojson) throw new Error("<geojson> is required");
    if (typeof reverse !== "boolean") throw new Error("<reverse> must be a boolean");
    if (typeof mutate !== "boolean") throw new Error("<mutate> must be a boolean");
    if (!mutate && geojson.type !== "Point" && geojson.type !== "MultiPoint") {
        geojson = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(geojson);
    }
    const results = [];
    switch(geojson.type){
        case "GeometryCollection":
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["geomEach"])(geojson, function(geometry) {
                rewindFeature(geometry, reverse);
            });
            return geojson;
        case "FeatureCollection":
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"])(geojson, function(feature) {
                const rewoundFeature = rewindFeature(feature, reverse);
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"])(rewoundFeature, function(result) {
                    results.push(result);
                });
            });
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(results);
    }
    return rewindFeature(geojson, reverse);
}
function rewindFeature(geojson, reverse) {
    const type = geojson.type === "Feature" ? geojson.geometry.type : geojson.type;
    switch(type){
        case "GeometryCollection":
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["geomEach"])(geojson, function(geometry) {
                rewindFeature(geometry, reverse);
            });
            return geojson;
        case "LineString":
            rewindLineString((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(geojson), reverse);
            return geojson;
        case "Polygon":
            rewindPolygon((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(geojson), reverse);
            return geojson;
        case "MultiLineString":
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(geojson).forEach(function(lineCoords) {
                rewindLineString(lineCoords, reverse);
            });
            return geojson;
        case "MultiPolygon":
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(geojson).forEach(function(lineCoords) {
                rewindPolygon(lineCoords, reverse);
            });
            return geojson;
        case "Point":
        case "MultiPoint":
            return geojson;
    }
}
function rewindLineString(coords, reverse) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$clockwise$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanClockwise"])(coords) === reverse) coords.reverse();
}
function rewindPolygon(coords, reverse) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$clockwise$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanClockwise"])(coords[0]) !== reverse) {
        coords[0].reverse();
    }
    for(let i = 1; i < coords.length; i++){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$clockwise$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanClockwise"])(coords[i]) === reverse) {
            coords[i].reverse();
        }
    }
}
var turf_rewind_default = rewind;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/sample/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_sample_default),
    "sample": (()=>sample)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
function sample(fc, num) {
    if (!fc) throw new Error("fc is required");
    if (num === null || num === void 0) throw new Error("num is required");
    if (typeof num !== "number") throw new Error("num must be a number");
    var outFC = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(getRandomSubarray(fc.features, num));
    return outFC;
}
function getRandomSubarray(arr, size) {
    var shuffled = arr.slice(0), i = arr.length, min = i - size, temp, index;
    while(i-- > min){
        index = Math.floor((i + 1) * Math.random());
        temp = shuffled[index];
        shuffled[index] = shuffled[i];
        shuffled[i] = temp;
    }
    return shuffled.slice(min);
}
var turf_sample_default = sample;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/sector/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_sector_default),
    "sector": (()=>sector)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$arc$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/line-arc/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$circle$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/circle/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
;
function sector(center, radius, bearing1, bearing2, options = {}) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    const properties = options.properties;
    if (!center) throw new Error("center is required");
    if (bearing1 === void 0 || bearing1 === null) throw new Error("bearing1 is required");
    if (bearing2 === void 0 || bearing2 === null) throw new Error("bearing2 is required");
    if (!radius) throw new Error("radius is required");
    if (typeof options !== "object") throw new Error("options must be an object");
    if (convertAngleTo360(bearing1) === convertAngleTo360(bearing2)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$circle$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["circle"])(center, radius, options);
    }
    const coords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(center);
    const arc = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$line$2d$arc$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineArc"])(center, radius, bearing1, bearing2, options);
    const sliceCoords = [
        [
            coords
        ]
    ];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coordEach"])(arc, function(currentCoords) {
        sliceCoords[0].push(currentCoords);
    });
    sliceCoords[0].push(coords);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])(sliceCoords, properties);
}
function convertAngleTo360(alpha) {
    let beta = alpha % 360;
    if (beta < 0) {
        beta += 360;
    }
    return beta;
}
var turf_sector_default = sector;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/transform-scale/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_transform_scale_default),
    "transformScale": (()=>transformScale)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rhumb-distance/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rhumb-bearing/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rhumb-destination/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/center/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/centroid/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
function transformScale(geojson, factor, options) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    const origin = options.origin || "centroid";
    const mutate = options.mutate || false;
    if (!geojson) throw new Error("geojson required");
    if (typeof factor !== "number" || factor <= 0) throw new Error("invalid factor");
    const originIsPoint = Array.isArray(origin) || typeof origin === "object";
    if (mutate !== true) geojson = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(geojson);
    if (geojson.type === "FeatureCollection" && !originIsPoint) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"])(geojson, function(feature, index) {
            geojson.features[index] = scale(feature, factor, origin);
        });
        return geojson;
    }
    return scale(geojson, factor, origin);
}
function scale(feature, factor, origin) {
    const isPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getType"])(feature) === "Point";
    const originCoord = defineOrigin(feature, origin);
    if (factor === 1 || isPoint) return feature;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coordEach"])(feature, function(coord) {
        const originalDistance = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rhumbDistance"])(originCoord, coord);
        const bearing = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$bearing$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rhumbBearing"])(originCoord, coord);
        const newDistance = originalDistance * factor;
        const newCoord = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rhumbDestination"])(originCoord, newDistance, bearing));
        coord[0] = newCoord[0];
        coord[1] = newCoord[1];
        if (coord.length === 3) coord[2] *= factor;
    });
    delete feature.bbox;
    return feature;
}
function defineOrigin(geojson, origin) {
    if (origin === void 0 || origin === null) origin = "centroid";
    if (Array.isArray(origin) || typeof origin === "object") return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(origin);
    const bbox = geojson.bbox ? geojson.bbox : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bbox"])(geojson, {
        recompute: true
    });
    const west = bbox[0];
    const south = bbox[1];
    const east = bbox[2];
    const north = bbox[3];
    switch(origin){
        case "sw":
        // @ts-expect-error undocumented, to be removed for v8 #techdebt
        case "southwest":
        // @ts-expect-error undocumented, to be removed for v8 #techdebt
        case "westsouth":
        // @ts-expect-error undocumented, to be removed for v8 #techdebt
        case "bottomleft":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])([
                west,
                south
            ]);
        case "se":
        // @ts-expect-error undocumented, to be removed for v8 #techdebt
        case "southeast":
        // @ts-expect-error undocumented, to be removed for v8 #techdebt
        case "eastsouth":
        // @ts-expect-error undocumented, to be removed for v8 #techdebt
        case "bottomright":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])([
                east,
                south
            ]);
        case "nw":
        // @ts-expect-error undocumented, to be removed for v8 #techdebt
        case "northwest":
        // @ts-expect-error undocumented, to be removed for v8 #techdebt
        case "westnorth":
        // @ts-expect-error undocumented, to be removed for v8 #techdebt
        case "topleft":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])([
                west,
                north
            ]);
        case "ne":
        // @ts-expect-error undocumented, to be removed for v8 #techdebt
        case "northeast":
        // @ts-expect-error undocumented, to be removed for v8 #techdebt
        case "eastnorth":
        // @ts-expect-error undocumented, to be removed for v8 #techdebt
        case "topright":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])([
                east,
                north
            ]);
        case "center":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["center"])(geojson);
        case void 0:
        case null:
        case "centroid":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["centroid"])(geojson);
        default:
            throw new Error("invalid origin");
    }
}
var turf_transform_scale_default = transformScale;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/shortest-path/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_shortest_path_default),
    "shortestPath": (()=>shortestPath)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$transform$2d$scale$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/transform-scale/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox-polygon/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clean$2d$coords$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clean-coords/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
// lib/javascript-astar.js
function pathTo(node) {
    var curr = node, path = [];
    while(curr.parent){
        path.unshift(curr);
        curr = curr.parent;
    }
    return path;
}
function getHeap() {
    return new BinaryHeap(function(node) {
        return node.f;
    });
}
var astar = {
    /**
   * Perform an A* Search on a graph given a start and end node.
   *
   * @private
   * @memberof astar
   * @param {Graph} graph Graph
   * @param {GridNode} start Start
   * @param {GridNode} end End
   * @param {Object} [options] Options
   * @param {bool} [options.closest] Specifies whether to return the path to the closest node if the target is unreachable.
   * @param {Function} [options.heuristic] Heuristic function (see astar.heuristics).
   * @returns {Object} Search
   */ search: function(graph, start, end, options) {
        var _a;
        graph.cleanDirty();
        options = options || {};
        var heuristic = options.heuristic || astar.heuristics.manhattan, closest = (_a = options.closest) != null ? _a : false;
        var openHeap = getHeap(), closestNode = start;
        start.h = heuristic(start, end);
        openHeap.push(start);
        while(openHeap.size() > 0){
            var currentNode = openHeap.pop();
            if (currentNode === end) {
                return pathTo(currentNode);
            }
            currentNode.closed = true;
            var neighbors = graph.neighbors(currentNode);
            for(var i = 0, il = neighbors.length; i < il; ++i){
                var neighbor = neighbors[i];
                if (neighbor.closed || neighbor.isWall()) {
                    continue;
                }
                var gScore = currentNode.g + neighbor.getCost(currentNode), beenVisited = neighbor.visited;
                if (!beenVisited || gScore < neighbor.g) {
                    neighbor.visited = true;
                    neighbor.parent = currentNode;
                    neighbor.h = neighbor.h || heuristic(neighbor, end);
                    neighbor.g = gScore;
                    neighbor.f = neighbor.g + neighbor.h;
                    graph.markDirty(neighbor);
                    if (closest) {
                        if (neighbor.h < closestNode.h || neighbor.h === closestNode.h && neighbor.g < closestNode.g) {
                            closestNode = neighbor;
                        }
                    }
                    if (!beenVisited) {
                        openHeap.push(neighbor);
                    } else {
                        openHeap.rescoreElement(neighbor);
                    }
                }
            }
        }
        if (closest) {
            return pathTo(closestNode);
        }
        return [];
    },
    // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html
    heuristics: {
        manhattan: function(pos0, pos1) {
            var d1 = Math.abs(pos1.x - pos0.x);
            var d2 = Math.abs(pos1.y - pos0.y);
            return d1 + d2;
        },
        diagonal: function(pos0, pos1) {
            var D = 1;
            var D2 = Math.sqrt(2);
            var d1 = Math.abs(pos1.x - pos0.x);
            var d2 = Math.abs(pos1.y - pos0.y);
            return D * (d1 + d2) + (D2 - 2 * D) * Math.min(d1, d2);
        }
    },
    cleanNode: function(node) {
        node.f = 0;
        node.g = 0;
        node.h = 0;
        node.visited = false;
        node.closed = false;
        node.parent = null;
    }
};
function Graph(gridIn, options) {
    options = options || {};
    this.nodes = [];
    this.diagonal = !!options.diagonal;
    this.grid = [];
    for(var x = 0; x < gridIn.length; x++){
        this.grid[x] = [];
        for(var y = 0, row = gridIn[x]; y < row.length; y++){
            var node = new GridNode(x, y, row[y]);
            this.grid[x][y] = node;
            this.nodes.push(node);
        }
    }
    this.init();
}
Graph.prototype.init = function() {
    this.dirtyNodes = [];
    for(var i = 0; i < this.nodes.length; i++){
        astar.cleanNode(this.nodes[i]);
    }
};
Graph.prototype.cleanDirty = function() {
    for(var i = 0; i < this.dirtyNodes.length; i++){
        astar.cleanNode(this.dirtyNodes[i]);
    }
    this.dirtyNodes = [];
};
Graph.prototype.markDirty = function(node) {
    this.dirtyNodes.push(node);
};
Graph.prototype.neighbors = function(node) {
    var ret = [], x = node.x, y = node.y, grid = this.grid;
    if (grid[x - 1] && grid[x - 1][y]) {
        ret.push(grid[x - 1][y]);
    }
    if (grid[x + 1] && grid[x + 1][y]) {
        ret.push(grid[x + 1][y]);
    }
    if (grid[x] && grid[x][y - 1]) {
        ret.push(grid[x][y - 1]);
    }
    if (grid[x] && grid[x][y + 1]) {
        ret.push(grid[x][y + 1]);
    }
    if (this.diagonal) {
        if (grid[x - 1] && grid[x - 1][y - 1]) {
            ret.push(grid[x - 1][y - 1]);
        }
        if (grid[x + 1] && grid[x + 1][y - 1]) {
            ret.push(grid[x + 1][y - 1]);
        }
        if (grid[x - 1] && grid[x - 1][y + 1]) {
            ret.push(grid[x - 1][y + 1]);
        }
        if (grid[x + 1] && grid[x + 1][y + 1]) {
            ret.push(grid[x + 1][y + 1]);
        }
    }
    return ret;
};
Graph.prototype.toString = function() {
    var graphString = [], nodes = this.grid, rowDebug, row, y, l;
    for(var x = 0, len = nodes.length; x < len; x++){
        rowDebug = [];
        row = nodes[x];
        for(y = 0, l = row.length; y < l; y++){
            rowDebug.push(row[y].weight);
        }
        graphString.push(rowDebug.join(" "));
    }
    return graphString.join("\n");
};
function GridNode(x, y, weight) {
    this.x = x;
    this.y = y;
    this.weight = weight;
}
GridNode.prototype.toString = function() {
    return "[" + this.x + " " + this.y + "]";
};
GridNode.prototype.getCost = function(fromNeighbor) {
    if (fromNeighbor && fromNeighbor.x !== this.x && fromNeighbor.y !== this.y) {
        return this.weight * 1.41421;
    }
    return this.weight;
};
GridNode.prototype.isWall = function() {
    return this.weight === 0;
};
function BinaryHeap(scoreFunction) {
    this.content = [];
    this.scoreFunction = scoreFunction;
}
BinaryHeap.prototype = {
    push: function(element) {
        this.content.push(element);
        this.sinkDown(this.content.length - 1);
    },
    pop: function() {
        var result = this.content[0];
        var end = this.content.pop();
        if (this.content.length > 0) {
            this.content[0] = end;
            this.bubbleUp(0);
        }
        return result;
    },
    remove: function(node) {
        var i = this.content.indexOf(node);
        var end = this.content.pop();
        if (i !== this.content.length - 1) {
            this.content[i] = end;
            if (this.scoreFunction(end) < this.scoreFunction(node)) {
                this.sinkDown(i);
            } else {
                this.bubbleUp(i);
            }
        }
    },
    size: function() {
        return this.content.length;
    },
    rescoreElement: function(node) {
        this.sinkDown(this.content.indexOf(node));
    },
    sinkDown: function(n) {
        var element = this.content[n];
        while(n > 0){
            var parentN = (n + 1 >> 1) - 1, parent = this.content[parentN];
            if (this.scoreFunction(element) < this.scoreFunction(parent)) {
                this.content[parentN] = element;
                this.content[n] = parent;
                n = parentN;
            } else {
                break;
            }
        }
    },
    bubbleUp: function(n) {
        var length = this.content.length, element = this.content[n], elemScore = this.scoreFunction(element);
        while(true){
            var child2N = n + 1 << 1, child1N = child2N - 1;
            var swap = null, child1Score;
            if (child1N < length) {
                var child1 = this.content[child1N];
                child1Score = this.scoreFunction(child1);
                if (child1Score < elemScore) {
                    swap = child1N;
                }
            }
            if (child2N < length) {
                var child2 = this.content[child2N], child2Score = this.scoreFunction(child2);
                if (child2Score < (swap === null ? elemScore : child1Score)) {
                    swap = child2N;
                }
            }
            if (swap !== null) {
                this.content[n] = this.content[swap];
                this.content[swap] = element;
                n = swap;
            } else {
                break;
            }
        }
    }
};
// index.ts
function shortestPath(start, end, options = {}) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    let obstacles = options.obstacles || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])([]);
    let resolution = options.resolution || 100;
    if (!start) throw new Error("start is required");
    if (!end) throw new Error("end is required");
    if (resolution && (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(resolution) || resolution <= 0)) throw new Error("options.resolution must be a number, greater than 0");
    const startCoord = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(start);
    const endCoord = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(end);
    start = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])(startCoord);
    end = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])(endCoord);
    if (obstacles.type === "FeatureCollection") {
        if (obstacles.features.length === 0) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineString"])([
                startCoord,
                endCoord
            ]);
        }
    } else if (obstacles.type === "Polygon") {
        obstacles = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])([
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["feature"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getGeom"])(obstacles))
        ]);
    } else {
        throw new Error("invalid obstacles");
    }
    const collection = obstacles;
    collection.features.push(start);
    collection.features.push(end);
    const box = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bbox"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$transform$2d$scale$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transformScale"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bboxPolygon"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bbox"])(collection)), 1.15));
    const [west, south, east, north] = box;
    const width = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])([
        west,
        south
    ], [
        east,
        south
    ], options);
    const division = width / resolution;
    collection.features.pop();
    collection.features.pop();
    const xFraction = division / (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])([
        west,
        south
    ], [
        east,
        south
    ], options);
    const cellWidth = xFraction * (east - west);
    const yFraction = division / (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])([
        west,
        south
    ], [
        west,
        north
    ], options);
    const cellHeight = yFraction * (north - south);
    const bboxHorizontalSide = east - west;
    const bboxVerticalSide = north - south;
    const columns = Math.floor(bboxHorizontalSide / cellWidth);
    const rows = Math.floor(bboxVerticalSide / cellHeight);
    const deltaX = (bboxHorizontalSide - columns * cellWidth) / 2;
    const deltaY = (bboxVerticalSide - rows * cellHeight) / 2;
    const pointMatrix = [];
    const matrix = [];
    let closestToStart;
    let closestToEnd;
    let minDistStart = Infinity;
    let minDistEnd = Infinity;
    let currentY = north - deltaY;
    let r = 0;
    while(currentY >= south){
        const matrixRow = [];
        const pointMatrixRow = [];
        let currentX = west + deltaX;
        let c = 0;
        while(currentX <= east){
            const pt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])([
                currentX,
                currentY
            ]);
            const isInsideObstacle = isInside(pt, obstacles);
            matrixRow.push(isInsideObstacle ? 0 : 1);
            pointMatrixRow.push(currentX + "|" + currentY);
            const distStart = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(pt, start);
            if (!isInsideObstacle && distStart < minDistStart) {
                minDistStart = distStart;
                closestToStart = {
                    x: c,
                    y: r
                };
            }
            const distEnd = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(pt, end);
            if (!isInsideObstacle && distEnd < minDistEnd) {
                minDistEnd = distEnd;
                closestToEnd = {
                    x: c,
                    y: r
                };
            }
            currentX += cellWidth;
            c++;
        }
        matrix.push(matrixRow);
        pointMatrix.push(pointMatrixRow);
        currentY -= cellHeight;
        r++;
    }
    const graph = new Graph(matrix, {
        diagonal: true
    });
    const startOnMatrix = graph.grid[closestToStart.y][closestToStart.x];
    const endOnMatrix = graph.grid[closestToEnd.y][closestToEnd.x];
    const result = astar.search(graph, startOnMatrix, endOnMatrix);
    const path = [
        startCoord
    ];
    result.forEach(function(coord) {
        const coords = pointMatrix[coord.x][coord.y].split("|");
        path.push([
            +coords[0],
            +coords[1]
        ]);
    });
    path.push(endCoord);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clean$2d$coords$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cleanCoords"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineString"])(path));
}
function isInside(pt, polygons) {
    for(let i = 0; i < polygons.features.length; i++){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(pt, polygons.features[i])) {
            return true;
        }
    }
    return false;
}
var turf_shortest_path_default = shortestPath;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/simplify/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_simplify_default),
    "simplify": (()=>simplify2)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clean$2d$coords$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clean-coords/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
// lib/simplify.js
function getSqDist(p1, p2) {
    var dx = p1[0] - p2[0], dy = p1[1] - p2[1];
    return dx * dx + dy * dy;
}
function getSqSegDist(p, p1, p2) {
    var x = p1[0], y = p1[1], dx = p2[0] - x, dy = p2[1] - y;
    if (dx !== 0 || dy !== 0) {
        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);
        if (t > 1) {
            x = p2[0];
            y = p2[1];
        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }
    dx = p[0] - x;
    dy = p[1] - y;
    return dx * dx + dy * dy;
}
function simplifyRadialDist(points, sqTolerance) {
    var prevPoint = points[0], newPoints = [
        prevPoint
    ], point;
    for(var i = 1, len = points.length; i < len; i++){
        point = points[i];
        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }
    if (prevPoint !== point) newPoints.push(point);
    return newPoints;
}
function simplifyDPStep(points, first, last, sqTolerance, simplified) {
    var maxSqDist = sqTolerance, index;
    for(var i = first + 1; i < last; i++){
        var sqDist = getSqSegDist(points[i], points[first], points[last]);
        if (sqDist > maxSqDist) {
            index = i;
            maxSqDist = sqDist;
        }
    }
    if (maxSqDist > sqTolerance) {
        if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
        simplified.push(points[index]);
        if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
    }
}
function simplifyDouglasPeucker(points, sqTolerance) {
    var last = points.length - 1;
    var simplified = [
        points[0]
    ];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);
    return simplified;
}
function simplify(points, tolerance, highestQuality) {
    if (points.length <= 2) return points;
    var sqTolerance = tolerance !== void 0 ? tolerance * tolerance : 1;
    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);
    return points;
}
// index.ts
function simplify2(geojson, options = {}) {
    var _a, _b, _c;
    options = options != null ? options : {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    const tolerance = (_a = options.tolerance) != null ? _a : 1;
    const highQuality = (_b = options.highQuality) != null ? _b : false;
    const mutate = (_c = options.mutate) != null ? _c : false;
    if (!geojson) throw new Error("geojson is required");
    if (tolerance && tolerance < 0) throw new Error("invalid tolerance");
    if (mutate !== true) geojson = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(geojson);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["geomEach"])(geojson, function(geom) {
        simplifyGeom(geom, tolerance, highQuality);
    });
    return geojson;
}
function simplifyGeom(geometry, tolerance, highQuality) {
    const type = geometry.type;
    if (type === "Point" || type === "MultiPoint") return geometry;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clean$2d$coords$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cleanCoords"])(geometry, {
        mutate: true
    });
    if (type !== "GeometryCollection") {
        switch(type){
            case "LineString":
                geometry.coordinates = simplify(geometry.coordinates, tolerance, highQuality);
                break;
            case "MultiLineString":
                geometry.coordinates = geometry.coordinates.map((lines)=>simplify(lines, tolerance, highQuality));
                break;
            case "Polygon":
                geometry.coordinates = simplifyPolygon(geometry.coordinates, tolerance, highQuality);
                break;
            case "MultiPolygon":
                geometry.coordinates = geometry.coordinates.map((rings)=>simplifyPolygon(rings, tolerance, highQuality));
        }
    }
    return geometry;
}
function simplifyPolygon(coordinates, tolerance, highQuality) {
    return coordinates.map(function(ring) {
        if (ring.length < 4) {
            throw new Error("invalid polygon");
        }
        let ringTolerance = tolerance;
        let simpleRing = simplify(ring, ringTolerance, highQuality);
        while(!checkValidity(simpleRing)){
            ringTolerance -= ringTolerance * 0.01;
            simpleRing = simplify(ring, ringTolerance, highQuality);
        }
        if (simpleRing[simpleRing.length - 1][0] !== simpleRing[0][0] || simpleRing[simpleRing.length - 1][1] !== simpleRing[0][1]) {
            simpleRing.push(simpleRing[0]);
        }
        return simpleRing;
    });
}
function checkValidity(ring) {
    if (ring.length < 3) return false;
    return !(ring.length === 3 && ring[2][0] === ring[0][0] && ring[2][1] === ring[0][1]);
}
var turf_simplify_default = simplify2;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/standard-deviational-ellipse/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_standard_deviational_ellipse_default),
    "standardDeviationalEllipse": (()=>standardDeviationalEllipse)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2d$mean$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/center-mean/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$ellipse$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/ellipse/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$points$2d$within$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/points-within-polygon/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
;
;
function standardDeviationalEllipse(points, options) {
    var _a;
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    const steps = options.steps || 64;
    const weightTerm = options.weight;
    const properties = options.properties || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(steps)) throw new Error("steps must be a number");
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(properties)) throw new Error("properties must be a number");
    const numberOfFeatures = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coordAll"])(points).length;
    const meanCenter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$center$2d$mean$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["centerMean"])(points, {
        weight: weightTerm
    });
    let xDeviationSquaredSum = 0;
    let yDeviationSquaredSum = 0;
    let xyDeviationSum = 0;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"])(points, function(point) {
        var _a2;
        const weight = weightTerm ? ((_a2 = point.properties) == null ? void 0 : _a2[weightTerm]) || 1 : 1;
        const deviation = getDeviations((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(point), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(meanCenter));
        xDeviationSquaredSum += Math.pow(deviation.x, 2) * weight;
        yDeviationSquaredSum += Math.pow(deviation.y, 2) * weight;
        xyDeviationSum += deviation.x * deviation.y * weight;
    });
    const bigA = xDeviationSquaredSum - yDeviationSquaredSum;
    const bigB = Math.sqrt(Math.pow(bigA, 2) + 4 * Math.pow(xyDeviationSum, 2));
    const bigC = 2 * xyDeviationSum;
    const theta = Math.atan((bigA + bigB) / bigC);
    const thetaDeg = theta * 180 / Math.PI;
    let sigmaXsum = 0;
    let sigmaYsum = 0;
    let weightsum = 0;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"])(points, function(point) {
        var _a2;
        const weight = weightTerm ? ((_a2 = point.properties) == null ? void 0 : _a2[weightTerm]) || 1 : 1;
        const deviation = getDeviations((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(point), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(meanCenter));
        sigmaXsum += Math.pow(deviation.x * Math.cos(theta) - deviation.y * Math.sin(theta), 2) * weight;
        sigmaYsum += Math.pow(deviation.x * Math.sin(theta) + deviation.y * Math.cos(theta), 2) * weight;
        weightsum += weight;
    });
    const sigmaX = Math.sqrt(2 * sigmaXsum / weightsum);
    const sigmaY = Math.sqrt(2 * sigmaYsum / weightsum);
    const theEllipse = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$ellipse$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ellipse"])(meanCenter, sigmaX, sigmaY, {
        units: "degrees",
        angle: thetaDeg,
        steps,
        properties
    });
    const pointsWithinEllipse = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$points$2d$within$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pointsWithinPolygon"])(points, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])([
        theEllipse
    ]));
    const standardDeviationalEllipseProperties = {
        meanCenterCoordinates: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])(meanCenter),
        semiMajorAxis: sigmaX,
        semiMinorAxis: sigmaY,
        numberOfFeatures,
        angle: thetaDeg,
        percentageWithinEllipse: 100 * (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coordAll"])(pointsWithinEllipse).length / numberOfFeatures
    };
    theEllipse.properties = (_a = theEllipse.properties) != null ? _a : {};
    theEllipse.properties.standardDeviationalEllipse = standardDeviationalEllipseProperties;
    return theEllipse;
}
function getDeviations(coordinates, center) {
    return {
        x: coordinates[0] - center[0],
        y: coordinates[1] - center[1]
    };
}
var turf_standard_deviational_ellipse_default = standardDeviationalEllipse;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/tag/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_tag_default),
    "tag": (()=>tag)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
function tag(points, polygons, field, outField) {
    points = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(points);
    polygons = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(polygons);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"])(points, function(pt) {
        if (!pt.properties) pt.properties = {};
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"])(polygons, function(poly) {
            if (pt.properties && poly.properties) {
                if (pt.properties[outField] === void 0) {
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(pt, poly)) pt.properties[outField] = poly.properties[field];
                }
            }
        });
    });
    return points;
}
var turf_tag_default = tag;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/tesselate/node_modules/earcut/src/earcut.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
module.exports = earcut;
module.exports.default = earcut;
function earcut(data, holeIndices, dim) {
    dim = dim || 2;
    var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) return triangles;
    var minX, minY, maxX, maxY, x, y, invSize;
    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for(var i = dim; i < outerLen; i += dim){
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }
        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
    return triangles;
}
// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;
    if (clockwise === signedArea(data, start, end, dim) > 0) {
        for(i = start; i < end; i += dim)last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for(i = end - dim; i >= start; i -= dim)last = insertNode(i, data[i], data[i + 1], last);
    }
    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }
    return last;
}
// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;
    var p = start, again;
    do {
        again = false;
        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;
        } else {
            p = p.next;
        }
    }while (again || p !== end)
    return end;
}
// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;
    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
    var stop = ear, prev, next;
    // iterate through ears, slicing them one by one
    while(ear.prev !== ear.next){
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);
            removeNode(ear);
            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;
            continue;
        }
        ear = next;
        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }
            break;
        }
    }
}
// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
    // now make sure we don't have other points inside the potential ear
    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    var p = c.next;
    while(p !== a){
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }
    return true;
}
function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    // z-order range for the current triangle bbox;
    var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
    var p = ear.prevZ, n = ear.nextZ;
    // look for points inside the triangle in both directions
    while(p && p.z >= minZ && n && n.z <= maxZ){
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }
    // look for remaining points in decreasing z-order
    while(p && p.z >= minZ){
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }
    // look for remaining points in increasing z-order
    while(n && n.z <= maxZ){
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }
    return true;
}
// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev, b = p.next.next;
        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim | 0);
            triangles.push(p.i / dim | 0);
            triangles.push(b.i / dim | 0);
            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);
            p = start = b;
        }
        p = p.next;
    }while (p !== start)
    return filterPoints(p);
}
// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while(b !== a.prev){
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);
                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);
                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
                return;
            }
            b = b.next;
        }
        a = a.next;
    }while (a !== start)
}
// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [], i, len, start, end, list;
    for(i = 0, len = holeIndices.length; i < len; i++){
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    // process holes from left to right
    for(i = 0; i < queue.length; i++){
        outerNode = eliminateHole(queue[i], outerNode);
    }
    return outerNode;
}
function compareX(a, b) {
    return a.x - b.x;
}
// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    var bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
        return outerNode;
    }
    var bridgeReverse = splitPolygon(bridge, hole);
    // filter collinear points around the cuts
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
}
// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                m = p.x < p.next.x ? p : p.next;
                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
            }
        }
        p = p.next;
    }while (p !== outerNode)
    if (!m) return null;
    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point
    var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
    p = m;
    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
            if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
                m = p;
                tanMin = tan;
            }
        }
        p = p.next;
    }while (p !== stop)
    return m;
}
// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}
// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    }while (p !== start)
    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked(p);
}
// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while(p){
            numMerges++;
            q = p;
            pSize = 0;
            for(i = 0; i < inSize; i++){
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;
            while(pSize > 0 || qSize > 0 && q){
                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }
                if (tail) tail.nextZ = e;
                else list = e;
                e.prevZ = tail;
                tail = e;
            }
            p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
    }while (numMerges > 1)
    return list;
}
// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = (x - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;
    x = (x | x << 8) & 0x00FF00FF;
    x = (x | x << 4) & 0x0F0F0F0F;
    x = (x | x << 2) & 0x33333333;
    x = (x | x << 1) & 0x55555555;
    y = (y | y << 8) & 0x00FF00FF;
    y = (y | y << 4) & 0x0F0F0F0F;
    y = (y | y << 2) & 0x33333333;
    y = (y | y << 1) & 0x55555555;
    return x | y << 1;
}
// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start, leftmost = start;
    do {
        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
        p = p.next;
    }while (p !== start)
    return leftmost;
}
// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
}
// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
    (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
    (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
    equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}
// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}
// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4) return true; // general case
    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2
    return false;
}
// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}
// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
        p = p.next;
    }while (p !== a)
    return false;
}
// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
    do {
        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
        p = p.next;
    }while (p !== a)
    return inside;
}
// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
}
// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);
    if (!last) {
        p.prev = p;
        p.next = p;
    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}
function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}
function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;
    // vertex coordinates
    this.x = x;
    this.y = y;
    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;
    // z-order curve value
    this.z = 0;
    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;
    // indicates whether this is a steiner point
    this.steiner = false;
}
// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function(data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for(var i = 0, len = holeIndices.length; i < len; i++){
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }
    var trianglesArea = 0;
    for(i = 0; i < triangles.length; i += 3){
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }
    return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
};
function signedArea(data, start, end, dim) {
    var sum = 0;
    for(var i = start, j = end - dim; i < end; i += dim){
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}
// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function(data) {
    var dim = data[0][0].length, result = {
        vertices: [],
        holes: [],
        dimensions: dim
    }, holeIndex = 0;
    for(var i = 0; i < data.length; i++){
        for(var j = 0; j < data[i].length; j++){
            for(var d = 0; d < dim; d++)result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};
}}),
"[project]/node_modules/@turf/tesselate/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_tesselate_default),
    "tesselate": (()=>tesselate)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$tesselate$2f$node_modules$2f$earcut$2f$src$2f$earcut$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/tesselate/node_modules/earcut/src/earcut.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
;
function tesselate(poly) {
    if (!poly.geometry || poly.geometry.type !== "Polygon" && poly.geometry.type !== "MultiPolygon") {
        throw new Error("input must be a Polygon or MultiPolygon");
    }
    const fc = {
        type: "FeatureCollection",
        features: []
    };
    if (poly.geometry.type === "Polygon") {
        fc.features = processPolygon(poly.geometry.coordinates);
    } else {
        poly.geometry.coordinates.forEach(function(coordinates) {
            fc.features = fc.features.concat(processPolygon(coordinates));
        });
    }
    return fc;
}
function processPolygon(coordinates) {
    const data = flattenCoords(coordinates);
    const dim = 2;
    const result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$tesselate$2f$node_modules$2f$earcut$2f$src$2f$earcut$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(data.vertices, data.holes, dim);
    const features = [];
    const vertices = [];
    result.forEach(function(vert, i2) {
        const index = result[i2];
        vertices.push([
            data.vertices[index * dim],
            data.vertices[index * dim + 1]
        ]);
    });
    for(var i = 0; i < vertices.length; i += 3){
        const coords = vertices.slice(i, i + 3);
        coords.push(vertices[i]);
        features.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])([
            coords
        ]));
    }
    return features;
}
function flattenCoords(data) {
    const dim = data[0][0].length, result = {
        vertices: [],
        holes: [],
        dimensions: dim
    };
    let holeIndex = 0;
    for(let i = 0; i < data.length; i++){
        for(let j = 0; j < data[i].length; j++){
            for(let d = 0; d < dim; d++)result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
}
var turf_tesselate_default = tesselate;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/transform-translate/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_transform_translate_default),
    "transformTranslate": (()=>transformTranslate)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/rhumb-destination/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
;
function transformTranslate(geojson, distance, direction, options) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    var units = options.units;
    var zTranslation = options.zTranslation;
    var mutate = options.mutate;
    if (!geojson) throw new Error("geojson is required");
    if (distance === void 0 || distance === null || isNaN(distance)) throw new Error("distance is required");
    if (zTranslation && typeof zTranslation !== "number" && isNaN(zTranslation)) throw new Error("zTranslation is not a number");
    zTranslation = zTranslation !== void 0 ? zTranslation : 0;
    if (distance === 0 && zTranslation === 0) return geojson;
    if (direction === void 0 || direction === null || isNaN(direction)) throw new Error("direction is required");
    if (distance < 0) {
        distance = -distance;
        direction = direction + 180;
    }
    if (mutate === false || mutate === void 0) geojson = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(geojson);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coordEach"])(geojson, function(pointCoords) {
        var newCoords = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoords"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$rhumb$2d$destination$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rhumbDestination"])(pointCoords, distance, direction, {
            units
        }));
        pointCoords[0] = newCoords[0];
        pointCoords[1] = newCoords[1];
        if (zTranslation && pointCoords.length === 3) pointCoords[2] += zTranslation;
    });
    return geojson;
}
var turf_transform_translate_default = transformTranslate;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/union/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_union_default),
    "union": (()=>union2)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/polyclip-ts/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
function union2(features, options = {}) {
    const geoms = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["geomEach"])(features, (geom)=>{
        geoms.push(geom.coordinates);
    });
    if (geoms.length < 2) {
        throw new Error("Must have at least 2 geometries");
    }
    const unioned = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$polyclip$2d$ts$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.union(geoms[0], ...geoms.slice(1));
    if (unioned.length === 0) return null;
    if (unioned.length === 1) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])(unioned[0], options.properties);
    else return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiPolygon"])(unioned, options.properties);
}
var turf_union_default = union2;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/unkink-polygon/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_unkink_polygon_default),
    "unkinkPolygon": (()=>unkinkPolygon)
});
// lib/geojson-polygon-self-intersections.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$rbush$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/rbush/rbush.min.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js [app-client] (ecmascript)");
// lib/simplepolygon.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$area$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/area/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
function geojsonPolygonSelfIntersections(feature, filterFn, useSpatialIndex) {
    if (feature.geometry.type !== "Polygon") throw new Error("The input feature must be a Polygon");
    if (useSpatialIndex === void 0) useSpatialIndex = 1;
    var coord = feature.geometry.coordinates;
    var output = [];
    var seen = {};
    if (useSpatialIndex) {
        var allEdgesAsRbushTreeItems = [];
        for(var ring0 = 0; ring0 < coord.length; ring0++){
            for(var edge0 = 0; edge0 < coord[ring0].length - 1; edge0++){
                allEdgesAsRbushTreeItems.push(rbushTreeItem(ring0, edge0));
            }
        }
        var tree = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$rbush$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        tree.load(allEdgesAsRbushTreeItems);
    }
    for(var ringA = 0; ringA < coord.length; ringA++){
        for(var edgeA = 0; edgeA < coord[ringA].length - 1; edgeA++){
            if (useSpatialIndex) {
                var bboxOverlaps = tree.search(rbushTreeItem(ringA, edgeA));
                bboxOverlaps.forEach(function(bboxIsect) {
                    var ring12 = bboxIsect.ring;
                    var edge12 = bboxIsect.edge;
                    ifIsectAddToOutput(ringA, edgeA, ring12, edge12);
                });
            } else {
                for(var ring1 = 0; ring1 < coord.length; ring1++){
                    for(var edge1 = 0; edge1 < coord[ring1].length - 1; edge1++){
                        ifIsectAddToOutput(ringA, edgeA, ring1, edge1);
                    }
                }
            }
        }
    }
    if (!filterFn) output = {
        type: "Feature",
        geometry: {
            type: "MultiPoint",
            coordinates: output
        }
    };
    return output;
    "TURBOPACK unreachable";
    function ifIsectAddToOutput(ring02, edge02, ring12, edge12) {
        var start0 = coord[ring02][edge02];
        var end0 = coord[ring02][edge02 + 1];
        var start1 = coord[ring12][edge12];
        var end1 = coord[ring12][edge12 + 1];
        var isect = intersect(start0, end0, start1, end1);
        if (isect === null) return;
        var frac0;
        var frac1;
        if (end0[0] !== start0[0]) {
            frac0 = (isect[0] - start0[0]) / (end0[0] - start0[0]);
        } else {
            frac0 = (isect[1] - start0[1]) / (end0[1] - start0[1]);
        }
        if (end1[0] !== start1[0]) {
            frac1 = (isect[0] - start1[0]) / (end1[0] - start1[0]);
        } else {
            frac1 = (isect[1] - start1[1]) / (end1[1] - start1[1]);
        }
        if (frac0 >= 1 || frac0 <= 0 || frac1 >= 1 || frac1 <= 0) return;
        var key = isect;
        var unique = !seen[key];
        if (unique) {
            seen[key] = true;
        }
        if (filterFn) {
            output.push(filterFn(isect, ring02, edge02, start0, end0, frac0, ring12, edge12, start1, end1, frac1, unique));
        } else {
            output.push(isect);
        }
    }
    function rbushTreeItem(ring, edge) {
        var start = coord[ring][edge];
        var end = coord[ring][edge + 1];
        var minX;
        var maxX;
        var minY;
        var maxY;
        if (start[0] < end[0]) {
            minX = start[0];
            maxX = end[0];
        } else {
            minX = end[0];
            maxX = start[0];
        }
        if (start[1] < end[1]) {
            minY = start[1];
            maxY = end[1];
        } else {
            minY = end[1];
            maxY = start[1];
        }
        return {
            minX,
            minY,
            maxX,
            maxY,
            ring,
            edge
        };
    }
}
function intersect(start0, end0, start1, end1) {
    if (equalArrays(start0, start1) || equalArrays(start0, end1) || equalArrays(end0, start1) || equalArrays(end1, start1)) return null;
    var x0 = start0[0], y0 = start0[1], x1 = end0[0], y1 = end0[1], x2 = start1[0], y2 = start1[1], x3 = end1[0], y3 = end1[1];
    var denom = (x0 - x1) * (y2 - y3) - (y0 - y1) * (x2 - x3);
    if (denom === 0) return null;
    var x4 = ((x0 * y1 - y0 * x1) * (x2 - x3) - (x0 - x1) * (x2 * y3 - y2 * x3)) / denom;
    var y4 = ((x0 * y1 - y0 * x1) * (y2 - y3) - (y0 - y1) * (x2 * y3 - y2 * x3)) / denom;
    return [
        x4,
        y4
    ];
}
function equalArrays(array1, array2) {
    if (!array1 || !array2) return false;
    if (array1.length !== array2.length) return false;
    for(var i = 0, l = array1.length; i < l; i++){
        if (array1[i] instanceof Array && array2[i] instanceof Array) {
            if (!equalArrays(array1[i], array2[i])) return false;
        } else if (array1[i] !== array2[i]) {
            return false;
        }
    }
    return true;
}
;
;
;
;
function simplepolygon(feature) {
    if (feature.type != "Feature") throw new Error("The input must a geojson object of type Feature");
    if (feature.geometry === void 0 || feature.geometry == null) throw new Error("The input must a geojson object with a non-empty geometry");
    if (feature.geometry.type != "Polygon") throw new Error("The input must be a geojson Polygon");
    var numRings = feature.geometry.coordinates.length;
    var vertices = [];
    for(var i = 0; i < numRings; i++){
        var ring = feature.geometry.coordinates[i];
        if (!equalArrays2(ring[0], ring[ring.length - 1])) {
            ring.push(ring[0]);
        }
        for(var j = 0; j < ring.length - 1; j++){
            vertices.push(ring[j]);
        }
    }
    if (!isUnique(vertices)) throw new Error("The input polygon may not have duplicate vertices (except for the first and last vertex of each ring)");
    var numvertices = vertices.length;
    var selfIsectsData = geojsonPolygonSelfIntersections(feature, function filterFn(isect, ring0, edge0, start0, end0, frac0, ring1, edge1, start1, end1, frac1, unique) {
        return [
            isect,
            ring0,
            edge0,
            start0,
            end0,
            frac0,
            ring1,
            edge1,
            start1,
            end1,
            frac1,
            unique
        ];
    });
    var numSelfIsect = selfIsectsData.length;
    if (numSelfIsect == 0) {
        var outputFeatureArray = [];
        for(var i = 0; i < numRings; i++){
            outputFeatureArray.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])([
                feature.geometry.coordinates[i]
            ], {
                parent: -1,
                winding: windingOfRing(feature.geometry.coordinates[i])
            }));
        }
        var output = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(outputFeatureArray);
        determineParents();
        setNetWinding();
        return output;
    }
    var pseudoVtxListByRingAndEdge = [];
    var isectList = [];
    for(var i = 0; i < numRings; i++){
        pseudoVtxListByRingAndEdge.push([]);
        for(var j = 0; j < feature.geometry.coordinates[i].length - 1; j++){
            pseudoVtxListByRingAndEdge[i].push([
                new PseudoVtx(feature.geometry.coordinates[i][modulo(j + 1, feature.geometry.coordinates[i].length - 1)], 1, [
                    i,
                    j
                ], [
                    i,
                    modulo(j + 1, feature.geometry.coordinates[i].length - 1)
                ], void 0)
            ]);
            isectList.push(new Isect(feature.geometry.coordinates[i][j], [
                i,
                modulo(j - 1, feature.geometry.coordinates[i].length - 1)
            ], [
                i,
                j
            ], void 0, void 0, false, true));
        }
    }
    for(var i = 0; i < numSelfIsect; i++){
        pseudoVtxListByRingAndEdge[selfIsectsData[i][1]][selfIsectsData[i][2]].push(new PseudoVtx(selfIsectsData[i][0], selfIsectsData[i][5], [
            selfIsectsData[i][1],
            selfIsectsData[i][2]
        ], [
            selfIsectsData[i][6],
            selfIsectsData[i][7]
        ], void 0));
        if (selfIsectsData[i][11]) isectList.push(new Isect(selfIsectsData[i][0], [
            selfIsectsData[i][1],
            selfIsectsData[i][2]
        ], [
            selfIsectsData[i][6],
            selfIsectsData[i][7]
        ], void 0, void 0, true, true));
    }
    var numIsect = isectList.length;
    for(var i = 0; i < pseudoVtxListByRingAndEdge.length; i++){
        for(var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++){
            pseudoVtxListByRingAndEdge[i][j].sort(function(a, b) {
                return a.param < b.param ? -1 : 1;
            });
        }
    }
    var allIsectsAsIsectRbushTreeItem = [];
    for(var i = 0; i < numIsect; i++){
        allIsectsAsIsectRbushTreeItem.push({
            minX: isectList[i].coord[0],
            minY: isectList[i].coord[1],
            maxX: isectList[i].coord[0],
            maxY: isectList[i].coord[1],
            index: i
        });
    }
    var isectRbushTree = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rbush$2f$rbush$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    isectRbushTree.load(allIsectsAsIsectRbushTreeItem);
    for(var i = 0; i < pseudoVtxListByRingAndEdge.length; i++){
        for(var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++){
            for(var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++){
                var coordToFind;
                if (k == pseudoVtxListByRingAndEdge[i][j].length - 1) {
                    coordToFind = pseudoVtxListByRingAndEdge[i][modulo(j + 1, feature.geometry.coordinates[i].length - 1)][0].coord;
                } else {
                    coordToFind = pseudoVtxListByRingAndEdge[i][j][k + 1].coord;
                }
                var IsectRbushTreeItemFound = isectRbushTree.search({
                    minX: coordToFind[0],
                    minY: coordToFind[1],
                    maxX: coordToFind[0],
                    maxY: coordToFind[1]
                })[0];
                pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn = IsectRbushTreeItemFound.index;
            }
        }
    }
    for(var i = 0; i < pseudoVtxListByRingAndEdge.length; i++){
        for(var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++){
            for(var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++){
                var coordToFind = pseudoVtxListByRingAndEdge[i][j][k].coord;
                var IsectRbushTreeItemFound = isectRbushTree.search({
                    minX: coordToFind[0],
                    minY: coordToFind[1],
                    maxX: coordToFind[0],
                    maxY: coordToFind[1]
                })[0];
                var l = IsectRbushTreeItemFound.index;
                if (l < numvertices) {
                    isectList[l].nxtIsectAlongRingAndEdge2 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;
                } else {
                    if (equalArrays2(isectList[l].ringAndEdge1, pseudoVtxListByRingAndEdge[i][j][k].ringAndEdgeIn)) {
                        isectList[l].nxtIsectAlongRingAndEdge1 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;
                    } else {
                        isectList[l].nxtIsectAlongRingAndEdge2 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;
                    }
                }
            }
        }
    }
    var queue = [];
    var i = 0;
    for(var j = 0; j < numRings; j++){
        var leftIsect = i;
        for(var k = 0; k < feature.geometry.coordinates[j].length - 1; k++){
            if (isectList[i].coord[0] < isectList[leftIsect].coord[0]) {
                leftIsect = i;
            }
            i++;
        }
        var isectAfterLeftIsect = isectList[leftIsect].nxtIsectAlongRingAndEdge2;
        for(var k = 0; k < isectList.length; k++){
            if (isectList[k].nxtIsectAlongRingAndEdge1 == leftIsect || isectList[k].nxtIsectAlongRingAndEdge2 == leftIsect) {
                var isectBeforeLeftIsect = k;
                break;
            }
        }
        var windingAtIsect = isConvex([
            isectList[isectBeforeLeftIsect].coord,
            isectList[leftIsect].coord,
            isectList[isectAfterLeftIsect].coord
        ], true) ? 1 : -1;
        queue.push({
            isect: leftIsect,
            parent: -1,
            winding: windingAtIsect
        });
    }
    queue.sort(function(a, b) {
        return isectList[a.isect].coord > isectList[b.isect].coord ? -1 : 1;
    });
    var outputFeatureArray = [];
    while(queue.length > 0){
        var popped = queue.pop();
        var startIsect = popped.isect;
        var currentOutputRingParent = popped.parent;
        var currentOutputRingWinding = popped.winding;
        var currentOutputRing = outputFeatureArray.length;
        var currentOutputRingCoords = [
            isectList[startIsect].coord
        ];
        var currentIsect = startIsect;
        if (isectList[startIsect].ringAndEdge1Walkable) {
            var walkingRingAndEdge = isectList[startIsect].ringAndEdge1;
            var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge1;
        } else {
            var walkingRingAndEdge = isectList[startIsect].ringAndEdge2;
            var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge2;
        }
        while(!equalArrays2(isectList[startIsect].coord, isectList[nxtIsect].coord)){
            currentOutputRingCoords.push(isectList[nxtIsect].coord);
            var nxtIsectInQueue = void 0;
            for(var i = 0; i < queue.length; i++){
                if (queue[i].isect == nxtIsect) {
                    nxtIsectInQueue = i;
                    break;
                }
            }
            if (nxtIsectInQueue != void 0) {
                queue.splice(nxtIsectInQueue, 1);
            }
            if (equalArrays2(walkingRingAndEdge, isectList[nxtIsect].ringAndEdge1)) {
                walkingRingAndEdge = isectList[nxtIsect].ringAndEdge2;
                isectList[nxtIsect].ringAndEdge2Walkable = false;
                if (isectList[nxtIsect].ringAndEdge1Walkable) {
                    var pushing = {
                        isect: nxtIsect
                    };
                    if (isConvex([
                        isectList[currentIsect].coord,
                        isectList[nxtIsect].coord,
                        isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge2].coord
                    ], currentOutputRingWinding == 1)) {
                        pushing.parent = currentOutputRingParent;
                        pushing.winding = -currentOutputRingWinding;
                    } else {
                        pushing.parent = currentOutputRing;
                        pushing.winding = currentOutputRingWinding;
                    }
                    queue.push(pushing);
                }
                currentIsect = nxtIsect;
                nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge2;
            } else {
                walkingRingAndEdge = isectList[nxtIsect].ringAndEdge1;
                isectList[nxtIsect].ringAndEdge1Walkable = false;
                if (isectList[nxtIsect].ringAndEdge2Walkable) {
                    var pushing = {
                        isect: nxtIsect
                    };
                    if (isConvex([
                        isectList[currentIsect].coord,
                        isectList[nxtIsect].coord,
                        isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge1].coord
                    ], currentOutputRingWinding == 1)) {
                        pushing.parent = currentOutputRingParent;
                        pushing.winding = -currentOutputRingWinding;
                    } else {
                        pushing.parent = currentOutputRing;
                        pushing.winding = currentOutputRingWinding;
                    }
                    queue.push(pushing);
                }
                currentIsect = nxtIsect;
                nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge1;
            }
        }
        currentOutputRingCoords.push(isectList[nxtIsect].coord);
        outputFeatureArray.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])([
            currentOutputRingCoords
        ], {
            index: currentOutputRing,
            parent: currentOutputRingParent,
            winding: currentOutputRingWinding,
            netWinding: void 0
        }));
    }
    var output = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(outputFeatureArray);
    determineParents();
    setNetWinding();
    function determineParents() {
        var featuresWithoutParent = [];
        for(var i2 = 0; i2 < output.features.length; i2++){
            if (output.features[i2].properties.parent == -1) featuresWithoutParent.push(i2);
        }
        if (featuresWithoutParent.length > 1) {
            for(var i2 = 0; i2 < featuresWithoutParent.length; i2++){
                var parent = -1;
                var parentArea = Infinity;
                for(var j2 = 0; j2 < output.features.length; j2++){
                    if (featuresWithoutParent[i2] == j2) continue;
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$boolean$2d$point$2d$in$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["booleanPointInPolygon"])(output.features[featuresWithoutParent[i2]].geometry.coordinates[0][0], output.features[j2], {
                        ignoreBoundary: true
                    })) {
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$area$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["area"])(output.features[j2]) < parentArea) {
                            parent = j2;
                        }
                    }
                }
                output.features[featuresWithoutParent[i2]].properties.parent = parent;
            }
        }
    }
    function setNetWinding() {
        for(var i2 = 0; i2 < output.features.length; i2++){
            if (output.features[i2].properties.parent == -1) {
                var netWinding = output.features[i2].properties.winding;
                output.features[i2].properties.netWinding = netWinding;
                setNetWindingOfChildren(i2, netWinding);
            }
        }
    }
    function setNetWindingOfChildren(parent, ParentNetWinding) {
        for(var i2 = 0; i2 < output.features.length; i2++){
            if (output.features[i2].properties.parent == parent) {
                var netWinding = ParentNetWinding + output.features[i2].properties.winding;
                output.features[i2].properties.netWinding = netWinding;
                setNetWindingOfChildren(i2, netWinding);
            }
        }
    }
    return output;
}
var PseudoVtx = function(coord, param, ringAndEdgeIn, ringAndEdgeOut, nxtIsectAlongEdgeIn) {
    this.coord = coord;
    this.param = param;
    this.ringAndEdgeIn = ringAndEdgeIn;
    this.ringAndEdgeOut = ringAndEdgeOut;
    this.nxtIsectAlongEdgeIn = nxtIsectAlongEdgeIn;
};
var Isect = function(coord, ringAndEdge1, ringAndEdge2, nxtIsectAlongRingAndEdge1, nxtIsectAlongRingAndEdge2, ringAndEdge1Walkable, ringAndEdge2Walkable) {
    this.coord = coord;
    this.ringAndEdge1 = ringAndEdge1;
    this.ringAndEdge2 = ringAndEdge2;
    this.nxtIsectAlongRingAndEdge1 = nxtIsectAlongRingAndEdge1;
    this.nxtIsectAlongRingAndEdge2 = nxtIsectAlongRingAndEdge2;
    this.ringAndEdge1Walkable = ringAndEdge1Walkable;
    this.ringAndEdge2Walkable = ringAndEdge2Walkable;
};
function isConvex(pts, righthanded) {
    if (typeof righthanded === "undefined") righthanded = true;
    if (pts.length != 3) throw new Error("This function requires an array of three points [x,y]");
    var d = (pts[1][0] - pts[0][0]) * (pts[2][1] - pts[0][1]) - (pts[1][1] - pts[0][1]) * (pts[2][0] - pts[0][0]);
    return d >= 0 == righthanded;
}
function windingOfRing(ring) {
    var leftVtx = 0;
    for(var i = 0; i < ring.length - 1; i++){
        if (ring[i][0] < ring[leftVtx][0]) leftVtx = i;
    }
    if (isConvex([
        ring[modulo(leftVtx - 1, ring.length - 1)],
        ring[leftVtx],
        ring[modulo(leftVtx + 1, ring.length - 1)]
    ], true)) {
        var winding = 1;
    } else {
        var winding = -1;
    }
    return winding;
}
function equalArrays2(array1, array2) {
    if (!array1 || !array2) return false;
    if (array1.length != array2.length) return false;
    for(var i = 0, l = array1.length; i < l; i++){
        if (array1[i] instanceof Array && array2[i] instanceof Array) {
            if (!equalArrays2(array1[i], array2[i])) return false;
        } else if (array1[i] != array2[i]) {
            return false;
        }
    }
    return true;
}
function modulo(n, m) {
    return (n % m + m) % m;
}
function isUnique(array) {
    var u = {};
    var isUnique2 = 1;
    for(var i = 0, l = array.length; i < l; ++i){
        if (Object.prototype.hasOwnProperty.call(u, array[i])) {
            isUnique2 = 0;
            break;
        }
        u[array[i]] = 1;
    }
    return isUnique2;
}
// index.ts
function unkinkPolygon(geojson) {
    var features = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["flattenEach"])(geojson, function(feature) {
        if (feature.geometry.type !== "Polygon") return;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"])(simplepolygon(feature), function(poly) {
            features.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])(poly.geometry.coordinates, feature.properties));
        });
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(features);
}
var turf_unkink_polygon_default = unkinkPolygon;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/d3-voronoi/src/constant.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(x) {
    return function() {
        return x;
    };
}
}}),
"[project]/node_modules/d3-voronoi/src/point.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "x": (()=>x),
    "y": (()=>y)
});
function x(d) {
    return d[0];
}
function y(d) {
    return d[1];
}
}}),
"[project]/node_modules/d3-voronoi/src/RedBlackTree.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "RedBlackNode": (()=>RedBlackNode),
    "default": (()=>__TURBOPACK__default__export__)
});
function RedBlackTree() {
    this._ = null; // root node
}
function RedBlackNode(node) {
    node.U = node.C = node.L = node.R = node.P = node.N = null; // next node
}
RedBlackTree.prototype = {
    constructor: RedBlackTree,
    insert: function(after, node) {
        var parent, grandpa, uncle;
        if (after) {
            node.P = after;
            node.N = after.N;
            if (after.N) after.N.P = node;
            after.N = node;
            if (after.R) {
                after = after.R;
                while(after.L)after = after.L;
                after.L = node;
            } else {
                after.R = node;
            }
            parent = after;
        } else if (this._) {
            after = RedBlackFirst(this._);
            node.P = null;
            node.N = after;
            after.P = after.L = node;
            parent = after;
        } else {
            node.P = node.N = null;
            this._ = node;
            parent = null;
        }
        node.L = node.R = null;
        node.U = parent;
        node.C = true;
        after = node;
        while(parent && parent.C){
            grandpa = parent.U;
            if (parent === grandpa.L) {
                uncle = grandpa.R;
                if (uncle && uncle.C) {
                    parent.C = uncle.C = false;
                    grandpa.C = true;
                    after = grandpa;
                } else {
                    if (after === parent.R) {
                        RedBlackRotateLeft(this, parent);
                        after = parent;
                        parent = after.U;
                    }
                    parent.C = false;
                    grandpa.C = true;
                    RedBlackRotateRight(this, grandpa);
                }
            } else {
                uncle = grandpa.L;
                if (uncle && uncle.C) {
                    parent.C = uncle.C = false;
                    grandpa.C = true;
                    after = grandpa;
                } else {
                    if (after === parent.L) {
                        RedBlackRotateRight(this, parent);
                        after = parent;
                        parent = after.U;
                    }
                    parent.C = false;
                    grandpa.C = true;
                    RedBlackRotateLeft(this, grandpa);
                }
            }
            parent = after.U;
        }
        this._.C = false;
    },
    remove: function(node) {
        if (node.N) node.N.P = node.P;
        if (node.P) node.P.N = node.N;
        node.N = node.P = null;
        var parent = node.U, sibling, left = node.L, right = node.R, next, red;
        if (!left) next = right;
        else if (!right) next = left;
        else next = RedBlackFirst(right);
        if (parent) {
            if (parent.L === node) parent.L = next;
            else parent.R = next;
        } else {
            this._ = next;
        }
        if (left && right) {
            red = next.C;
            next.C = node.C;
            next.L = left;
            left.U = next;
            if (next !== right) {
                parent = next.U;
                next.U = node.U;
                node = next.R;
                parent.L = node;
                next.R = right;
                right.U = next;
            } else {
                next.U = parent;
                parent = next;
                node = next.R;
            }
        } else {
            red = node.C;
            node = next;
        }
        if (node) node.U = parent;
        if (red) return;
        if (node && node.C) {
            node.C = false;
            return;
        }
        do {
            if (node === this._) break;
            if (node === parent.L) {
                sibling = parent.R;
                if (sibling.C) {
                    sibling.C = false;
                    parent.C = true;
                    RedBlackRotateLeft(this, parent);
                    sibling = parent.R;
                }
                if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                    if (!sibling.R || !sibling.R.C) {
                        sibling.L.C = false;
                        sibling.C = true;
                        RedBlackRotateRight(this, sibling);
                        sibling = parent.R;
                    }
                    sibling.C = parent.C;
                    parent.C = sibling.R.C = false;
                    RedBlackRotateLeft(this, parent);
                    node = this._;
                    break;
                }
            } else {
                sibling = parent.L;
                if (sibling.C) {
                    sibling.C = false;
                    parent.C = true;
                    RedBlackRotateRight(this, parent);
                    sibling = parent.L;
                }
                if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                    if (!sibling.L || !sibling.L.C) {
                        sibling.R.C = false;
                        sibling.C = true;
                        RedBlackRotateLeft(this, sibling);
                        sibling = parent.L;
                    }
                    sibling.C = parent.C;
                    parent.C = sibling.L.C = false;
                    RedBlackRotateRight(this, parent);
                    node = this._;
                    break;
                }
            }
            sibling.C = true;
            node = parent;
            parent = parent.U;
        }while (!node.C)
        if (node) node.C = false;
    }
};
function RedBlackRotateLeft(tree, node) {
    var p = node, q = node.R, parent = p.U;
    if (parent) {
        if (parent.L === p) parent.L = q;
        else parent.R = q;
    } else {
        tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.R = q.L;
    if (p.R) p.R.U = p;
    q.L = p;
}
function RedBlackRotateRight(tree, node) {
    var p = node, q = node.L, parent = p.U;
    if (parent) {
        if (parent.L === p) parent.L = q;
        else parent.R = q;
    } else {
        tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.L = q.R;
    if (p.L) p.L.U = p;
    q.R = p;
}
function RedBlackFirst(node) {
    while(node.L)node = node.L;
    return node;
}
const __TURBOPACK__default__export__ = RedBlackTree;
}}),
"[project]/node_modules/d3-voronoi/src/Edge.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "clipEdges": (()=>clipEdges),
    "createBorderEdge": (()=>createBorderEdge),
    "createEdge": (()=>createEdge),
    "setEdgeEnd": (()=>setEdgeEnd)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-voronoi/src/Diagram.js [app-client] (ecmascript)");
;
function createEdge(left, right, v0, v1) {
    var edge = [
        null,
        null
    ], index = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["edges"].push(edge) - 1;
    edge.left = left;
    edge.right = right;
    if (v0) setEdgeEnd(edge, left, right, v0);
    if (v1) setEdgeEnd(edge, right, left, v1);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cells"][left.index].halfedges.push(index);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cells"][right.index].halfedges.push(index);
    return edge;
}
function createBorderEdge(left, v0, v1) {
    var edge = [
        v0,
        v1
    ];
    edge.left = left;
    return edge;
}
function setEdgeEnd(edge, left, right, vertex) {
    if (!edge[0] && !edge[1]) {
        edge[0] = vertex;
        edge.left = left;
        edge.right = right;
    } else if (edge.left === right) {
        edge[1] = vertex;
    } else {
        edge[0] = vertex;
    }
}
// LiangBarsky line clipping.
function clipEdge(edge, x0, y0, x1, y1) {
    var a = edge[0], b = edge[1], ax = a[0], ay = a[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
    r = x0 - ax;
    if (!dx && r > 0) return;
    r /= dx;
    if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
    } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
    }
    r = x1 - ax;
    if (!dx && r < 0) return;
    r /= dx;
    if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
    } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
    }
    r = y0 - ay;
    if (!dy && r > 0) return;
    r /= dy;
    if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
    } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
    }
    r = y1 - ay;
    if (!dy && r < 0) return;
    r /= dy;
    if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
    } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
    }
    if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?
    if (t0 > 0) edge[0] = [
        ax + t0 * dx,
        ay + t0 * dy
    ];
    if (t1 < 1) edge[1] = [
        ax + t1 * dx,
        ay + t1 * dy
    ];
    return true;
}
function connectEdge(edge, x0, y0, x1, y1) {
    var v1 = edge[1];
    if (v1) return true;
    var v0 = edge[0], left = edge.left, right = edge.right, lx = left[0], ly = left[1], rx = right[0], ry = right[1], fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
    if (ry === ly) {
        if (fx < x0 || fx >= x1) return;
        if (lx > rx) {
            if (!v0) v0 = [
                fx,
                y0
            ];
            else if (v0[1] >= y1) return;
            v1 = [
                fx,
                y1
            ];
        } else {
            if (!v0) v0 = [
                fx,
                y1
            ];
            else if (v0[1] < y0) return;
            v1 = [
                fx,
                y0
            ];
        }
    } else {
        fm = (lx - rx) / (ry - ly);
        fb = fy - fm * fx;
        if (fm < -1 || fm > 1) {
            if (lx > rx) {
                if (!v0) v0 = [
                    (y0 - fb) / fm,
                    y0
                ];
                else if (v0[1] >= y1) return;
                v1 = [
                    (y1 - fb) / fm,
                    y1
                ];
            } else {
                if (!v0) v0 = [
                    (y1 - fb) / fm,
                    y1
                ];
                else if (v0[1] < y0) return;
                v1 = [
                    (y0 - fb) / fm,
                    y0
                ];
            }
        } else {
            if (ly < ry) {
                if (!v0) v0 = [
                    x0,
                    fm * x0 + fb
                ];
                else if (v0[0] >= x1) return;
                v1 = [
                    x1,
                    fm * x1 + fb
                ];
            } else {
                if (!v0) v0 = [
                    x1,
                    fm * x1 + fb
                ];
                else if (v0[0] < x0) return;
                v1 = [
                    x0,
                    fm * x0 + fb
                ];
            }
        }
    }
    edge[0] = v0;
    edge[1] = v1;
    return true;
}
function clipEdges(x0, y0, x1, y1) {
    var i = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["edges"].length, edge;
    while(i--){
        if (!connectEdge(edge = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["edges"][i], x0, y0, x1, y1) || !clipEdge(edge, x0, y0, x1, y1) || !(Math.abs(edge[0][0] - edge[1][0]) > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["epsilon"] || Math.abs(edge[0][1] - edge[1][1]) > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["epsilon"])) {
            delete __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["edges"][i];
        }
    }
}
}}),
"[project]/node_modules/d3-voronoi/src/Cell.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "cellHalfedgeEnd": (()=>cellHalfedgeEnd),
    "cellHalfedgeStart": (()=>cellHalfedgeStart),
    "clipCells": (()=>clipCells),
    "createCell": (()=>createCell),
    "sortCellHalfedges": (()=>sortCellHalfedges)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Edge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-voronoi/src/Edge.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-voronoi/src/Diagram.js [app-client] (ecmascript)");
;
;
function createCell(site) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cells"][site.index] = {
        site: site,
        halfedges: []
    };
}
function cellHalfedgeAngle(cell, edge) {
    var site = cell.site, va = edge.left, vb = edge.right;
    if (site === vb) vb = va, va = site;
    if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
    if (site === va) va = edge[1], vb = edge[0];
    else va = edge[0], vb = edge[1];
    return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
}
function cellHalfedgeStart(cell, edge) {
    return edge[+(edge.left !== cell.site)];
}
function cellHalfedgeEnd(cell, edge) {
    return edge[+(edge.left === cell.site)];
}
function sortCellHalfedges() {
    for(var i = 0, n = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cells"].length, cell, halfedges, j, m; i < n; ++i){
        if ((cell = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cells"][i]) && (m = (halfedges = cell.halfedges).length)) {
            var index = new Array(m), array = new Array(m);
            for(j = 0; j < m; ++j)index[j] = j, array[j] = cellHalfedgeAngle(cell, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["edges"][halfedges[j]]);
            index.sort(function(i, j) {
                return array[j] - array[i];
            });
            for(j = 0; j < m; ++j)array[j] = halfedges[index[j]];
            for(j = 0; j < m; ++j)halfedges[j] = array[j];
        }
    }
}
function clipCells(x0, y0, x1, y1) {
    var nCells = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cells"].length, iCell, cell, site, iHalfedge, halfedges, nHalfedges, start, startX, startY, end, endX, endY, cover = true;
    for(iCell = 0; iCell < nCells; ++iCell){
        if (cell = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cells"][iCell]) {
            site = cell.site;
            halfedges = cell.halfedges;
            iHalfedge = halfedges.length;
            // Remove any dangling clipped edges.
            while(iHalfedge--){
                if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["edges"][halfedges[iHalfedge]]) {
                    halfedges.splice(iHalfedge, 1);
                }
            }
            // Insert any border edges as necessary.
            iHalfedge = 0, nHalfedges = halfedges.length;
            while(iHalfedge < nHalfedges){
                end = cellHalfedgeEnd(cell, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["edges"][halfedges[iHalfedge]]), endX = end[0], endY = end[1];
                start = cellHalfedgeStart(cell, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["edges"][halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
                if (Math.abs(endX - startX) > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["epsilon"] || Math.abs(endY - startY) > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["epsilon"]) {
                    halfedges.splice(iHalfedge, 0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["edges"].push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Edge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createBorderEdge"])(site, end, Math.abs(endX - x0) < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["epsilon"] && y1 - endY > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["epsilon"] ? [
                        x0,
                        Math.abs(startX - x0) < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["epsilon"] ? startY : y1
                    ] : Math.abs(endY - y1) < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["epsilon"] && x1 - endX > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["epsilon"] ? [
                        Math.abs(startY - y1) < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["epsilon"] ? startX : x1,
                        y1
                    ] : Math.abs(endX - x1) < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["epsilon"] && endY - y0 > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["epsilon"] ? [
                        x1,
                        Math.abs(startX - x1) < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["epsilon"] ? startY : y0
                    ] : Math.abs(endY - y0) < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["epsilon"] && endX - x0 > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["epsilon"] ? [
                        Math.abs(startY - y0) < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["epsilon"] ? startX : x0,
                        y0
                    ] : null)) - 1);
                    ++nHalfedges;
                }
            }
            if (nHalfedges) cover = false;
        }
    }
    // If there werent any edges, have the closest site cover the extent.
    // It doesnt matter which corner of the extent we measure!
    if (cover) {
        var dx, dy, d2, dc = Infinity;
        for(iCell = 0, cover = null; iCell < nCells; ++iCell){
            if (cell = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cells"][iCell]) {
                site = cell.site;
                dx = site[0] - x0;
                dy = site[1] - y0;
                d2 = dx * dx + dy * dy;
                if (d2 < dc) dc = d2, cover = cell;
            }
        }
        if (cover) {
            var v00 = [
                x0,
                y0
            ], v01 = [
                x0,
                y1
            ], v11 = [
                x1,
                y1
            ], v10 = [
                x1,
                y0
            ];
            cover.halfedges.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["edges"].push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Edge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createBorderEdge"])(site = cover.site, v00, v01)) - 1, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["edges"].push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Edge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createBorderEdge"])(site, v01, v11)) - 1, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["edges"].push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Edge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createBorderEdge"])(site, v11, v10)) - 1, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["edges"].push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Edge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createBorderEdge"])(site, v10, v00)) - 1);
        }
    }
    // Lastly delete any cells with no edges; these were entirely clipped.
    for(iCell = 0; iCell < nCells; ++iCell){
        if (cell = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cells"][iCell]) {
            if (!cell.halfedges.length) {
                delete __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cells"][iCell];
            }
        }
    }
}
}}),
"[project]/node_modules/d3-voronoi/src/Circle.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "attachCircle": (()=>attachCircle),
    "detachCircle": (()=>detachCircle),
    "firstCircle": (()=>firstCircle)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$RedBlackTree$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-voronoi/src/RedBlackTree.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-voronoi/src/Diagram.js [app-client] (ecmascript)");
;
;
var circlePool = [];
var firstCircle;
function Circle() {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$RedBlackTree$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RedBlackNode"])(this);
    this.x = this.y = this.arc = this.site = this.cy = null;
}
function attachCircle(arc) {
    var lArc = arc.P, rArc = arc.N;
    if (!lArc || !rArc) return;
    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
    if (lSite === rSite) return;
    var bx = cSite[0], by = cSite[1], ax = lSite[0] - bx, ay = lSite[1] - by, cx = rSite[0] - bx, cy = rSite[1] - by;
    var d = 2 * (ax * cy - ay * cx);
    if (d >= -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["epsilon2"]) return;
    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d;
    var circle = circlePool.pop() || new Circle;
    circle.arc = arc;
    circle.site = cSite;
    circle.x = x + bx;
    circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom
    arc.circle = circle;
    var before = null, node = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["circles"]._;
    while(node){
        if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
            if (node.L) node = node.L;
            else {
                before = node.P;
                break;
            }
        } else {
            if (node.R) node = node.R;
            else {
                before = node;
                break;
            }
        }
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["circles"].insert(before, circle);
    if (!before) firstCircle = circle;
}
function detachCircle(arc) {
    var circle = arc.circle;
    if (circle) {
        if (!circle.P) firstCircle = circle.N;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["circles"].remove(circle);
        circlePool.push(circle);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$RedBlackTree$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RedBlackNode"])(circle);
        arc.circle = null;
    }
}
}}),
"[project]/node_modules/d3-voronoi/src/Beach.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "addBeach": (()=>addBeach),
    "removeBeach": (()=>removeBeach)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$RedBlackTree$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-voronoi/src/RedBlackTree.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Cell$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-voronoi/src/Cell.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Circle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-voronoi/src/Circle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Edge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-voronoi/src/Edge.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-voronoi/src/Diagram.js [app-client] (ecmascript)");
;
;
;
;
;
var beachPool = [];
function Beach() {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$RedBlackTree$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RedBlackNode"])(this);
    this.edge = this.site = this.circle = null;
}
function createBeach(site) {
    var beach = beachPool.pop() || new Beach;
    beach.site = site;
    return beach;
}
function detachBeach(beach) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Circle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["detachCircle"])(beach);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["beaches"].remove(beach);
    beachPool.push(beach);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$RedBlackTree$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RedBlackNode"])(beach);
}
function removeBeach(beach) {
    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = [
        x,
        y
    ], previous = beach.P, next = beach.N, disappearing = [
        beach
    ];
    detachBeach(beach);
    var lArc = previous;
    while(lArc.circle && Math.abs(x - lArc.circle.x) < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["epsilon"] && Math.abs(y - lArc.circle.cy) < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["epsilon"]){
        previous = lArc.P;
        disappearing.unshift(lArc);
        detachBeach(lArc);
        lArc = previous;
    }
    disappearing.unshift(lArc);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Circle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["detachCircle"])(lArc);
    var rArc = next;
    while(rArc.circle && Math.abs(x - rArc.circle.x) < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["epsilon"] && Math.abs(y - rArc.circle.cy) < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["epsilon"]){
        next = rArc.N;
        disappearing.push(rArc);
        detachBeach(rArc);
        rArc = next;
    }
    disappearing.push(rArc);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Circle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["detachCircle"])(rArc);
    var nArcs = disappearing.length, iArc;
    for(iArc = 1; iArc < nArcs; ++iArc){
        rArc = disappearing[iArc];
        lArc = disappearing[iArc - 1];
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Edge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setEdgeEnd"])(rArc.edge, lArc.site, rArc.site, vertex);
    }
    lArc = disappearing[0];
    rArc = disappearing[nArcs - 1];
    rArc.edge = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Edge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createEdge"])(lArc.site, rArc.site, null, vertex);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Circle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachCircle"])(lArc);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Circle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachCircle"])(rArc);
}
function addBeach(site) {
    var x = site[0], directrix = site[1], lArc, rArc, dxl, dxr, node = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["beaches"]._;
    while(node){
        dxl = leftBreakPoint(node, directrix) - x;
        if (dxl > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["epsilon"]) node = node.L;
        else {
            dxr = x - rightBreakPoint(node, directrix);
            if (dxr > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["epsilon"]) {
                if (!node.R) {
                    lArc = node;
                    break;
                }
                node = node.R;
            } else {
                if (dxl > -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["epsilon"]) {
                    lArc = node.P;
                    rArc = node;
                } else if (dxr > -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["epsilon"]) {
                    lArc = node;
                    rArc = node.N;
                } else {
                    lArc = rArc = node;
                }
                break;
            }
        }
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Cell$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createCell"])(site);
    var newArc = createBeach(site);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["beaches"].insert(lArc, newArc);
    if (!lArc && !rArc) return;
    if (lArc === rArc) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Circle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["detachCircle"])(lArc);
        rArc = createBeach(lArc.site);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["beaches"].insert(newArc, rArc);
        newArc.edge = rArc.edge = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Edge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createEdge"])(lArc.site, newArc.site);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Circle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachCircle"])(lArc);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Circle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachCircle"])(rArc);
        return;
    }
    if (!rArc) {
        newArc.edge = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Edge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createEdge"])(lArc.site, newArc.site);
        return;
    }
    // else lArc !== rArc
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Circle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["detachCircle"])(lArc);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Circle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["detachCircle"])(rArc);
    var lSite = lArc.site, ax = lSite[0], ay = lSite[1], bx = site[0] - ax, by = site[1] - ay, rSite = rArc.site, cx = rSite[0] - ax, cy = rSite[1] - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = [
        (cy * hb - by * hc) / d + ax,
        (bx * hc - cx * hb) / d + ay
    ];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Edge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setEdgeEnd"])(rArc.edge, lSite, rSite, vertex);
    newArc.edge = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Edge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createEdge"])(lSite, site, null, vertex);
    rArc.edge = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Edge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createEdge"])(site, rSite, null, vertex);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Circle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachCircle"])(lArc);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Circle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachCircle"])(rArc);
}
function leftBreakPoint(arc, directrix) {
    var site = arc.site, rfocx = site[0], rfocy = site[1], pby2 = rfocy - directrix;
    if (!pby2) return rfocx;
    var lArc = arc.P;
    if (!lArc) return -Infinity;
    site = lArc.site;
    var lfocx = site[0], lfocy = site[1], plby2 = lfocy - directrix;
    if (!plby2) return lfocx;
    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
    return (rfocx + lfocx) / 2;
}
function rightBreakPoint(arc, directrix) {
    var rArc = arc.N;
    if (rArc) return leftBreakPoint(rArc, directrix);
    var site = arc.site;
    return site[1] === directrix ? site[0] : Infinity;
}
}}),
"[project]/node_modules/d3-voronoi/src/Diagram.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "beaches": (()=>beaches),
    "cells": (()=>cells),
    "circles": (()=>circles),
    "default": (()=>Diagram),
    "edges": (()=>edges),
    "epsilon": (()=>epsilon),
    "epsilon2": (()=>epsilon2)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Beach$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-voronoi/src/Beach.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Cell$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-voronoi/src/Cell.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Circle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-voronoi/src/Circle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Edge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-voronoi/src/Edge.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$RedBlackTree$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-voronoi/src/RedBlackTree.js [app-client] (ecmascript)");
;
;
;
;
;
var epsilon = 1e-6;
var epsilon2 = 1e-12;
var beaches;
var cells;
var circles;
var edges;
function triangleArea(a, b, c) {
    return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
}
function lexicographic(a, b) {
    return b[1] - a[1] || b[0] - a[0];
}
function Diagram(sites, extent) {
    var site = sites.sort(lexicographic).pop(), x, y, circle;
    edges = [];
    cells = new Array(sites.length);
    beaches = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$RedBlackTree$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
    circles = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$RedBlackTree$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
    while(true){
        circle = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Circle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["firstCircle"];
        if (site && (!circle || site[1] < circle.y || site[1] === circle.y && site[0] < circle.x)) {
            if (site[0] !== x || site[1] !== y) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Beach$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addBeach"])(site);
                x = site[0], y = site[1];
            }
            site = sites.pop();
        } else if (circle) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Beach$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["removeBeach"])(circle.arc);
        } else {
            break;
        }
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Cell$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sortCellHalfedges"])();
    if (extent) {
        var x0 = +extent[0][0], y0 = +extent[0][1], x1 = +extent[1][0], y1 = +extent[1][1];
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Edge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clipEdges"])(x0, y0, x1, y1);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Cell$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clipCells"])(x0, y0, x1, y1);
    }
    this.edges = edges;
    this.cells = cells;
    beaches = circles = edges = cells = null;
}
Diagram.prototype = {
    constructor: Diagram,
    polygons: function() {
        var edges = this.edges;
        return this.cells.map(function(cell) {
            var polygon = cell.halfedges.map(function(i) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Cell$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cellHalfedgeStart"])(cell, edges[i]);
            });
            polygon.data = cell.site.data;
            return polygon;
        });
    },
    triangles: function() {
        var triangles = [], edges = this.edges;
        this.cells.forEach(function(cell, i) {
            if (!(m = (halfedges = cell.halfedges).length)) return;
            var site = cell.site, halfedges, j = -1, m, s0, e1 = edges[halfedges[m - 1]], s1 = e1.left === site ? e1.right : e1.left;
            while(++j < m){
                s0 = s1;
                e1 = edges[halfedges[j]];
                s1 = e1.left === site ? e1.right : e1.left;
                if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
                    triangles.push([
                        site.data,
                        s0.data,
                        s1.data
                    ]);
                }
            }
        });
        return triangles;
    },
    links: function() {
        return this.edges.filter(function(edge) {
            return edge.right;
        }).map(function(edge) {
            return {
                source: edge.left.data,
                target: edge.right.data
            };
        });
    },
    find: function(x, y, radius) {
        var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;
        // Use the previously-found cell, or start with an arbitrary one.
        while(!(cell = that.cells[i1]))if (++i1 >= n) return null;
        var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;
        // Traverse the half-edges to find a closer cell, if any.
        do {
            cell = that.cells[i0 = i1], i1 = null;
            cell.halfedges.forEach(function(e) {
                var edge = that.edges[e], v = edge.left;
                if ((v === cell.site || !v) && !(v = edge.right)) return;
                var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;
                if (v2 < d2) d2 = v2, i1 = v.index;
            });
        }while (i1 !== null)
        that._found = i0;
        return radius == null || d2 <= radius * radius ? cell.site : null;
    }
};
}}),
"[project]/node_modules/d3-voronoi/src/voronoi.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-voronoi/src/constant.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-voronoi/src/point.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-voronoi/src/Diagram.js [app-client] (ecmascript)");
;
;
;
function __TURBOPACK__default__export__() {
    var x = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["x"], y = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$point$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["y"], extent = null;
    function voronoi(data) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](data.map(function(d, i) {
            var s = [
                Math.round(x(d, i, data) / __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["epsilon"]) * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["epsilon"],
                Math.round(y(d, i, data) / __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["epsilon"]) * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$Diagram$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["epsilon"]
            ];
            s.index = i;
            s.data = d;
            return s;
        }), extent);
    }
    voronoi.polygons = function(data) {
        return voronoi(data).polygons();
    };
    voronoi.links = function(data) {
        return voronoi(data).links();
    };
    voronoi.triangles = function(data) {
        return voronoi(data).triangles();
    };
    voronoi.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(+_), voronoi) : x;
    };
    voronoi.y = function(_) {
        return arguments.length ? (y = typeof _ === "function" ? _ : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(+_), voronoi) : y;
    };
    voronoi.extent = function(_) {
        return arguments.length ? (extent = _ == null ? null : [
            [
                +_[0][0],
                +_[0][1]
            ],
            [
                +_[1][0],
                +_[1][1]
            ]
        ], voronoi) : extent && [
            [
                extent[0][0],
                extent[0][1]
            ],
            [
                extent[1][0],
                extent[1][1]
            ]
        ];
    };
    voronoi.size = function(_) {
        return arguments.length ? (extent = _ == null ? null : [
            [
                0,
                0
            ],
            [
                +_[0],
                +_[1]
            ]
        ], voronoi) : extent && [
            extent[1][0] - extent[0][0],
            extent[1][1] - extent[0][1]
        ];
    };
    return voronoi;
}
}}),
"[project]/node_modules/d3-voronoi/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({});
;
}}),
"[project]/node_modules/d3-voronoi/index.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$voronoi$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-voronoi/src/voronoi.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/d3-voronoi/index.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/d3-voronoi/index.js [app-client] (ecmascript) <exports>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "voronoi": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$voronoi$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$src$2f$voronoi$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-voronoi/src/voronoi.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/d3-voronoi/index.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/d3-voronoi/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "voronoi": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__["voronoi"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/d3-voronoi/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$exports$3e$__ = __turbopack_import__("[project]/node_modules/d3-voronoi/index.js [app-client] (ecmascript) <exports>");
}}),
"[project]/node_modules/@turf/voronoi/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_voronoi_default),
    "voronoi": (()=>voronoi2)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/d3-voronoi/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/d3-voronoi/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/clone/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
function coordsToPolygon(coords) {
    coords = coords.slice();
    coords.push(coords[0]);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["polygon"])([
        coords
    ]);
}
function voronoi2(points, options) {
    options = options || {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(options)) throw new Error("options is invalid");
    const bbox = options.bbox || [
        -180,
        -85,
        180,
        85
    ];
    if (!points) throw new Error("points is required");
    if (!Array.isArray(bbox)) throw new Error("bbox is invalid");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["collectionOf"])(points, "Point", "points");
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$voronoi$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.voronoi().x((feature)=>feature.geometry.coordinates[0]).y((feature)=>feature.geometry.coordinates[1]).extent([
        [
            bbox[0],
            bbox[1]
        ],
        [
            bbox[2],
            bbox[3]
        ]
    ]).polygons(points.features).map(function(coords, index) {
        return Object.assign(coordsToPolygon(coords), {
            properties: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$clone$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cloneProperties"])(points.features[index].properties)
        });
    }));
}
var turf_voronoi_default = voronoi2;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/nearest-neighbor-analysis/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_nearest_neighbor_analysis_default),
    "nearestNeighborAnalysis": (()=>nearestNeighborAnalysis)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox-polygon/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/meta/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/centroid/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/nearest-point/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$area$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/area/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
function nearestNeighborAnalysis(dataset, options) {
    options = options || {};
    const studyArea = options.studyArea || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bboxPolygon"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bbox"])(dataset));
    const properties = options.properties || {};
    const units = options.units || "kilometers";
    const features = [];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$meta$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureEach"])(dataset, (feature)=>{
        features.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$centroid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["centroid"])(feature));
    });
    const n = features.length;
    const observedMeanDistance = features.map((feature, index)=>{
        const otherFeatures = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollection"])(features.filter((f, i)=>{
            return i !== index;
        }));
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(feature, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$nearest$2d$point$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nearestPoint"])(feature, otherFeatures).geometry.coordinates, {
            units
        });
    }).reduce((sum, value)=>{
        return sum + value;
    }, 0) / n;
    const populationDensity = n / (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertArea"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$area$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["area"])(studyArea), "meters", units);
    const expectedMeanDistance = 1 / (2 * Math.sqrt(populationDensity));
    const variance = 0.26136 / Math.sqrt(n * populationDensity);
    properties.nearestNeighborAnalysis = {
        units,
        arealUnits: units + "\xB2",
        observedMeanDistance,
        expectedMeanDistance,
        nearestNeighborIndex: observedMeanDistance / expectedMeanDistance,
        numberOfPoints: n,
        zScore: (observedMeanDistance - expectedMeanDistance) / variance
    };
    studyArea.properties = properties;
    return studyArea;
}
var turf_nearest_neighbor_analysis_default = nearestNeighborAnalysis;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@turf/quadrat-analysis/dist/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// index.ts
__turbopack_esm__({
    "default": (()=>turf_quadrat_analysis_default),
    "quadratAnalysis": (()=>quadratAnalysis)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$area$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/area/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bbox-polygon/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$square$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/square-grid/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/esm/index.js [app-client] (ecmascript)");
;
;
;
;
;
function quadratAnalysis(pointFeatureSet, options) {
    options = options || {};
    const studyBbox = options.studyBbox || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bbox"])(pointFeatureSet);
    const confidenceLevel = options.confidenceLevel || 20;
    const points = pointFeatureSet.features;
    const numOfPoints = points.length;
    const sizeOfArea = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$area$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["area"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2d$polygon$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bboxPolygon"])(studyBbox));
    const lengthOfSide = Math.sqrt(sizeOfArea / numOfPoints * 2);
    const grid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$square$2d$grid$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["squareGrid"])(studyBbox, lengthOfSide, {
        units: "meters"
    });
    const quadrats = grid.features;
    const quadratIdDict = {};
    for(let i = 0; i < quadrats.length; i++){
        quadratIdDict[i] = {
            box: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bbox$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bbox"])(quadrats[i]),
            cnt: 0
        };
    }
    let sumOfPoint = 0;
    for (const pt of points){
        for (const key of Object.keys(quadratIdDict)){
            const box = quadratIdDict[key].box;
            if (inBBox((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(pt), box)) {
                quadratIdDict[key].cnt += 1;
                sumOfPoint += 1;
                break;
            }
        }
    }
    let maxCnt = 0;
    for (const key of Object.keys(quadratIdDict)){
        const cnt = quadratIdDict[key].cnt;
        if (cnt > maxCnt) {
            maxCnt = cnt;
        }
    }
    const expectedDistribution = [];
    const numOfQuadrat = Object.keys(quadratIdDict).length;
    const lambda = sumOfPoint / numOfQuadrat;
    let cumulativeProbility = 0;
    for(let x = 0; x < maxCnt + 1; x++){
        cumulativeProbility += Math.exp(-lambda) * Math.pow(lambda, x) / factorial(x);
        expectedDistribution.push(cumulativeProbility);
    }
    const observedDistribution = [];
    let cumulativeObservedQuads = 0;
    for(let x = 0; x < maxCnt + 1; x++){
        for (const key of Object.keys(quadratIdDict)){
            if (quadratIdDict[key].cnt === x) {
                cumulativeObservedQuads += 1;
            }
        }
        const p = cumulativeObservedQuads / numOfQuadrat;
        observedDistribution.push(p);
    }
    let maxDifference = 0;
    for(let x = 0; x < maxCnt + 1; x++){
        const difference = Math.abs(expectedDistribution[x] - observedDistribution[x]);
        if (difference > maxDifference) {
            maxDifference = difference;
        }
    }
    const k = K_TABLE[confidenceLevel];
    const criticalValue = k / Math.sqrt(numOfQuadrat);
    const result = {
        criticalValue,
        isRandom: true,
        maxAbsoluteDifference: maxDifference,
        observedDistribution
    };
    if (maxDifference > criticalValue) {
        result.isRandom = false;
    }
    return result;
}
var K_TABLE = {
    20: 1.07275,
    15: 1.13795,
    10: 1.22385,
    5: 1.3581,
    2: 1.51743,
    1: 1.62762
};
function inBBox(pt, bbox) {
    return bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1];
}
function factorial(num) {
    const f = [];
    function inner(n) {
        if (n === 0 || n === 1) {
            return 1;
        }
        if (f[n] > 0) {
            return f[n];
        }
        return f[n] = inner(n - 1) * n;
    }
    return inner(num);
}
var turf_quadrat_analysis_default = quadratAnalysis;
;
 //# sourceMappingURL=index.js.map
}}),
}]);

//# sourceMappingURL=node_modules_b0ab7a._.js.map